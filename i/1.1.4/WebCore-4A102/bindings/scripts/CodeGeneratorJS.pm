# 
# KDOM IDL parser
#
# Copyright (C) 2005 Nikolas Zimmermann <wildfox@kde.org>
# Copyright (C) 2006 Anders Carlsson <andersca@mac.com> 
# Copyright (C) 2006 Apple Computer, Inc.
#
# This file is part of the KDE project
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU Library General Public License
# aint with this library; see the file COPYING.LIB.  If not, write to
# the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#

package CodeGeneratorJS;

use File::stat;

my $module = "";
my $outputDir = "";
my %implIncludes = ();

# Default .h template
my $headerTemplate = << "EOF";
/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/
EOF

# Default constructor
sub new
{
	my $object = shift;
	my $reference = { };
	
	$codeGenerator = shift;
	$outputDir = shift;
	
	bless($reference, $object);
	return $reference;
}

sub finish
{
	my $object = shift;
	
	# Commit changes!
	$object->WriteData();
}

sub leftShift($$) {
    my ($value, $distance) = @_;
    return (($value << $distance) & 0xFFFFFFFF);
}

# Params: 'domClass' struct
sub GenerateInterface
{
	my $object = shift;
	my $dataNode = shift;
	
	# FIXME: Check dates to see if we need to re-generate anything
	
    # Start actual generation..
    $object->GenerateHeader($dataNode);
    $object->GenerateImplementation($dataNode);
    
    my $name = $dataNode->name;
    
    # Open files for writing...
    my $headerFileName = "$outputDir/JS$name.h";
    my $implFileName = "$outputDir/JS$name.cpp";
    
    open($IMPL, ">$implFileName") || die "Couldn't open file $implFileName";
    open($HEADER, ">$headerFileName") || die "Couldn't open file $headerFileName";
}

# Params: 'idlDocument' struct
sub GenerateModule
{
    my $object = shift;
    my $dataNode = shift;  
    
    $module = $dataNode->module;    
}

sub GetParentClassName
{
    my $dataNode = shift;
    return $dataNode->extendedAttributes->{"LegacyParent"} if $dataNode->extendedAttributes->{"LegacyParent"};
    return "KJS::DOMObject" if @{$dataNode->parents} eq 0;
    return "JS" . $codeGenerator->StripModule($dataNode->parents(0));
}

sub GetLegacyHeaderIncludes
{
    my $legacyParent = shift;
    if ($legacyParent eq "JSHTMLInputElementBase") {
        return "#include \"JSHTMLInputElementBase.h\"\n\n";
    } elsif ($legacyParent eq "KJS::Window") {
        return "#include \"kjs_window.h\"\n\n";
    } elsif ($legacyParent eq "KJS::DOMNode") {
        return "#include \"kjs_domnode.h\"\n\n";
    } elsif ($module eq "events") {
        return "#include \"kjs_events.h\"\n\n";
    } elsif ($module eq "core") {
        return "#include \"kjs_dom.h\"\n\n";
    } elsif ($module eq "css") {
        return "#include \"kjs_css.h\"\n\n";
    } elsif ($module eq "html") {
        return "#include \"kjs_html.h\"\n\n";
    } elsif ($module eq "traversal") {
        return "#include \"kjs_traversal.h\"\n\n";
    } else {
        die ("Don't know what headers to include for module $module");
    }
}

sub AddIncludesForType
{
    my $type = $codeGenerator->StripModule(shift);
    
    # When we're finished with the one-file-per-class 
    # reorganization, we won't need these special cases.
    if ($codeGenerator->IsPrimitiveType($type)
        or $type eq "DOMString" or $type eq "DOMObject" or $type eq "RGBColor" or $type eq "Rect") {
    } else {
        # default, include the same named file
        $implIncludes{"${type}.h"} = 1;
    }

    # additional includes (things needed to compile the bindings but not the header)

    if ($type eq "CanvasRenderingContext2D") {
        $implIncludes{"CanvasGradient.h"} = 1;
        $implIncludes{"CanvasPattern.h"} = 1;
        $implIncludes{"CanvasStyle.h"} = 1;
    }

    if ($type eq "CanvasGradient" or $type eq "XPathNSResolver") {
        $implIncludes{"PlatformString.h"} = 1;
    }
}

sub GenerateHeader
{
    my $object = shift;
    my $dataNode = shift;
    
    my $interfaceName = $dataNode->name;
    my $className = "JS$interfaceName";
    my $implClassName = $interfaceName;
    
    # FIXME: For SVG we need to support more than one parent
    # But no more than one parent can be "concrete"
    # Right now concrete vs. abstract parents are not respected
    # we just use the first parent listed and ignore all others
    # Until we fix that, we special case SVG not to die here.
    if (@{$dataNode->parents} > 1 && !($interfaceName =~ /SVG/)) {
        die "A class can't have more than one parent";
    }
    
    my $hasLegacyParent = $dataNode->extendedAttributes->{"LegacyParent"};
    my $hasRealParent = @{$dataNode->parents} > 0;
    my $hasParent = $hasLegacyParent || $hasRealParent;
    my $parentClassName = GetParentClassName($dataNode);
    my $conditional = $dataNode->extendedAttributes->{"Conditional"};
    
    # - Add default header template
    @headerContent = split("\r", $headerTemplate);
    
    # - Add header protection
    push(@headerContent, "\n#ifndef $className" . "_H");
    push(@headerContent, "\n#define $className" . "_H\n\n");
    
    push(@headerContent, "#if ${conditional}_SUPPORT\n\n") if $conditional;
    
    if (exists $dataNode->extendedAttributes->{"LegacyParent"}) {
        push(@headerContent, GetLegacyHeaderIncludes($dataNode->extendedAttributes->{"LegacyParent"}));
    } else {
        if ($hasParent) {
            push(@headerContent, "#include \"$parentClassName.h\"\n");
        } else {
            push(@headerContent, "#include \"kjs_binding.h\"\n");
        }
    }
  
    my $numAttributes = @{$dataNode->attributes};
    my $numFunctions = @{$dataNode->functions};
    my $numConstants = @{$dataNode->constants};
    
    push(@headerContent, "\nnamespace WebCore {\n\n");
    
    # Implementation class forward declaration
    push(@headerContent, "class $implClassName;\n\n");
    
    # Class declaration
    push(@headerContent, "class $className : public $parentClassName {\n");
    push(@headerContent, "public:\n");
    
    # Constructor
    if ($dataNode->extendedAttributes->{"DoNotCache"}) {
        push(@headerContent, "    $className($implClassName*);\n");
    } else {
        push(@headerContent, "    $className(KJS::ExecState*, $implClassName*);\n");
    }
    
    # Destructor
    if (!$hasParent or $interfaceName eq "Document") {
        push(@headerContent, "    virtual ~$className();\n");
    }
  
    # Getters
    if ($numAttributes > 0) {
        push(@headerContent, "    virtual bool getOwnPropertySlot(KJS::ExecState*, const KJS::Identifier&, KJS::PropertySlot&);\n");
        push(@headerContent, "    KJS::JSValue* getValueProperty(KJS::ExecState*, int token) const;\n");
    }
    
    # Check if we have any writable properties
    my $hasReadWriteProperties = 0;
    foreach(@{$dataNode->attributes}) {
        if($_->type !~ /^readonly\ attribute$/) {
            $hasReadWriteProperties = 1;
        }
    }
    
    if ($hasReadWriteProperties) {
        push(@headerContent, "    virtual void put(KJS::ExecState*, const KJS::Identifier&, KJS::JSValue*, int attr = KJS::None);\n");
        push(@headerContent, "    void putValueProperty(KJS::ExecState*, int, KJS::JSValue*, int attr);\n");
    }
    
    # Class info
    push(@headerContent, "    virtual const KJS::ClassInfo* classInfo() const { return &info; }\n");
    push(@headerContent, "    static const KJS::ClassInfo info;\n");
    
    # Custom mark function
    if ($dataNode->extendedAttributes->{"CustomMarkFunction"}) {
        push(@headerContent, "\n    virtual void mark();\n\n");
    }
    
    # Constructor object getter
    if ($dataNode->extendedAttributes->{"GenerateConstructor"}) {
        push(@headerContent, "    static KJS::JSValue* getConstructor(KJS::ExecState*);\n");
    }
    
    # Make object undetectable
    if ($dataNode->extendedAttributes->{"Undetectable"}) {
        push(@headerContent, "    virtual bool toBoolean(KJS::ExecState*) const { return false; }\n");
        push(@headerContent, "    virtual bool masqueradeAsUndefined() const { return true; }\n");
    }

    my $numCustomFunctions = 0;
    my $numCustomAttributes = 0;
    
    # Attribute and function enums
    if ($numAttributes + $numFunctions > 0) {
        push(@headerContent, "    enum {\n")
    }
  
    if ($numAttributes > 0) {
        push(@headerContent, "        // Attributes\n        ");
        
        my $i = -1;
        foreach(@{$dataNode->attributes}) {
            my $attribute = $_;
            
            $numCustomAttributes++ if $attribute->signature->extendedAttributes->{"Custom"};
            $numCustomAttributes++ if $attribute->signature->extendedAttributes->{"CustomGetter"};
            $numCustomAttributes++ if $attribute->signature->extendedAttributes->{"CustomSetter"};
            
            $i++;
            if((($i % 4) eq 0) and ($i ne 0)) {
                push(@headerContent, "\n        ");
            }
            
            my $value = $attribute->signature->type =~ /Constructor$/
                      ? $attribute->signature->name . "ConstructorAttrNum" 
                      : ucfirst($attribute->signature->name) . "AttrNum";
            $value .= ", " if(($i < $numAttributes - 1));
            $value .= ", " if(($i eq $numAttributes - 1) and ($numFunctions ne 0));
            push(@headerContent, $value);
        }
    }
    
    if ($numFunctions > 0) {
        if ($numAttributes > 0) {
            push(@headerContent, "\n\n");
        }
        push(@headerContent,"        // Functions\n        ");
        
        $i = -1;
        foreach(@{$dataNode->functions}) {
            my $function = $_;
            
            $i++;
            if ((($i % 4) eq 0) and ($i ne 0)) {
                push(@headerContent, "\n        ");
            }
            
            $numCustomFunctions++ if $function->signature->extendedAttributes->{"Custom"};
            
            my $value = ucfirst($function->signature->name) . "FuncNum";
            $value .= ", " if ($i < $numFunctions - 1);
            push(@headerContent, $value);
        }
    }
  
    if ($numAttributes + $numFunctions > 0) {
        push(@headerContent, "\n    };\n");
    }

    if ($numCustomAttributes > 0) {
        push(@headerContent, "\n    // Custom attributes\n");
        
        foreach(@{$dataNode->attributes}) {
            my $attribute = $_;
              
            if ($attribute->signature->extendedAttributes->{"Custom"}) {
                push(@headerContent, "    KJS::JSValue* " . $attribute->signature->name . "(KJS::ExecState*) const;\n");
                if ($attribute->type !~ /^readonly/) {
                    push(@headerContent, "    void set" . ucfirst($attribute->signature->name) . "(KJS::ExecState*, KJS::JSValue*);\n");        
                }
            } elsif ($attribute->signature->extendedAttributes->{"CustomGetter"}) {
                push(@headerContent, "    KJS::JSValue* " . $attribute->signature->name . "(KJS::ExecState*) const;\n");
            } elsif ($attribute->signature->extendedAttributes->{"CustomSetter"}) {
                if ($attribute->type !~ /^readonly/) {
                    push(@headerContent, "    void set" . ucfirst($attribute->signature->name) . "(KJS::ExecState*, KJS::JSValue*);\n");
                }
            }
        }
    }
  
    if ($numCustomFunctions > 0) {      
        push(@headerContent, "\n    // Custom functions\n");
        foreach(@{$dataNode->functions}) {
            my $function = $_;
              
            if ($function->signature->extendedAttributes->{"Custom"}) {
                push(@headerContent, "    KJS::JSValue* " . $function->signature->name . "(KJS::ExecState*, const KJS::List&);\n");
            }
        }
    }

    # Index setter
    if ($dataNode->extendedAttributes->{"HasCustomIndexSetter"}) {
        push(@headerContent, "    void indexSetter(KJS::ExecState*, const KJS::Identifier &propertyName, KJS::JSValue*, int attr);\n");
    }

    if (!$hasParent) {
        push(@headerContent, "    $implClassName* impl() const { return m_impl.get(); }\n");
        push(@headerContent, "private:\n");
        push(@headerContent, "    RefPtr<$implClassName> m_impl;\n");
    } elsif ($dataNode->extendedAttributes->{"GenerateNativeConverter"}) {
        push(@headerContent, "    $implClassName* impl() const;\n");
    }
  
    # Index getter
    if ($dataNode->extendedAttributes->{"HasIndexGetter"}) {
        push(@headerContent, "private:\n");
        push(@headerContent, "    static KJS::JSValue* indexGetter(KJS::ExecState*, KJS::JSObject*, const KJS::Identifier&, const KJS::PropertySlot&);\n");
    }
    # Name getter
    if ($dataNode->extendedAttributes->{"HasNameGetter"}) {
        push(@headerContent, "private:\n");
        push(@headerContent, "    static KJS::JSValue* nameGetter(KJS::ExecState*, KJS::JSObject*, const KJS::Identifier&, const KJS::PropertySlot&);\n");
        push(@headerContent, "    static bool canGetItemsForName(KJS::ExecState*, $implClassName*, const AtomicString&);\n")
    }
  
    push(@headerContent, "};\n\n");
    
    if (!$hasParent) {
        push(@headerContent, "KJS::JSValue* toJS(KJS::ExecState*, $implClassName*);\n");
    }
    if (!$hasParent || $dataNode->extendedAttributes->{"GenerateNativeConverter"}) {
        push(@headerContent, "$implClassName* to${interfaceName}(KJS::JSValue*);\n");
    }
    push(@headerContent, "\n");
    
    # Add prototype declaration -- code adopted from the KJS_DEFINE_PROTOTYPE and KJS_DEFINE_PROTOTYPE_WITH_PROTOTYPE macros
    push(@headerContent, "class ${className}Proto : public KJS::JSObject {\n");
    if (!$dataNode->extendedAttributes->{"DoNotCache"}) {
        push(@headerContent, "    friend KJS::JSObject* KJS_GCC_ROOT_NS_HACK cacheGlobalObject<${className}Proto>(KJS::ExecState*, const KJS::Identifier& propertyName);\n");
    }
    push(@headerContent, "public:\n");
    if ($dataNode->extendedAttributes->{"DoNotCache"}) {
        push(@headerContent, "    static KJS::JSObject* self();\n");
    } else {
        push(@headerContent, "    static KJS::JSObject* self(KJS::ExecState* exec);\n");
    }
    push(@headerContent, "    virtual const KJS::ClassInfo* classInfo() const { return &info; }\n");
    push(@headerContent, "    static const KJS::ClassInfo info;\n");
    if ($numFunctions > 0 || $numConstants > 0) {
        push(@headerContent, "    bool getOwnPropertySlot(KJS::ExecState*, const KJS::Identifier&, KJS::PropertySlot&);\n");
    }
    if ($numConstants ne 0) {
        push(@headerContent, "    KJS::JSValue* getValueProperty(KJS::ExecState*, int token) const;\n");
    }
    push(@headerContent, "protected:\n");
    if ($dataNode->extendedAttributes->{"DoNotCache"}) {
        push(@headerContent, "    ${className}Proto() { }\n");
    } else {
        push(@headerContent, "    ${className}Proto(KJS::ExecState* exec)\n");
        if ($hasParent && $parentClassName ne "KJS::DOMCSSRule" && $parentClassName ne "KJS::DOMNodeFilter") {
            push(@headerContent, "        : KJS::JSObject(${parentClassName}Proto::self(exec)) { }\n");
        } else {
            push(@headerContent, "        : KJS::JSObject(exec->lexicalInterpreter()->builtinObjectPrototype()) { }\n");
        }
    }
    
    push(@headerContent, "};\n\n");
    
    push(@headerContent, "}\n\n");
    
    push(@headerContent, "#endif // ${conditional}_SUPPORT\n\n") if $conditional;
    
    push(@headerContent, "#endif\n");
}

sub GenerateImplementation
{
  my ($object, $dataNode) = @_; 
  
  my $interfaceName = $dataNode->name;
  my $className = "JS$interfaceName";
  my $implClassName = $interfaceName;
  
  my $hasLegacyParent = $dataNode->extendedAttributes->{"LegacyParent"};
  my $hasRealParent = @{$dataNode->parents} > 0;
  my $hasParent = $hasLegacyParent || $hasRealParent;
  my $parentClassName = GetParentClassName($dataNode);
  my $conditional = $dataNode->extendedAttributes->{"Conditional"};
  
  # - Add default header template
  @implContentHeader = split("\r", $headerTemplate);
  push(@implContentHeader, "\n");
  push(@implContentHeader,, "#include \"config.h\"\n\n");
  
  push(@implContentHeader, "#if ${conditional}_SUPPORT\n\n") if $conditional;
  
  push(@implContentHeader, "#include \"$className.h\"\n\n");

  AddIncludesForType($interfaceName);

  @implContent = ();

  push(@implContent, "\nusing namespace KJS;\n\n");  
  push(@implContent, "namespace WebCore {\n\n");
  
  # - Add all attributes in a hashtable definition
  my $numAttributes = @{$dataNode->attributes};
  if ($numAttributes > 0) {
    my $hashSize = $numAttributes;
    my $hashName = $className . "Table";

    my @hashKeys = ();      # ie. 'insertBefore'
    my @hashValues = ();    # ie. 'JSNode::InsertBefore'
    my @hashSpecials = ();    # ie. 'DontDelete|Function'
    my @hashParameters = ();  # ie. '2'

    foreach my $attribute (@{$dataNode->attributes}) {
      my $name = $attribute->signature->name;
      push(@hashKeys, $name);
      
      my $value = $className . "::" . ($attribute->signature->type =~ /Constructor$/ 
                                       ? $attribute->signature->name . "ConstructorAttrNum" 
                                       : ucfirst($attribute->signature->name) . "AttrNum");      
      push(@hashValues, $value);

      my $special = "DontDelete";
      $special .= "|ReadOnly" if($attribute->type =~ /readonly/);
      push(@hashSpecials, $special);

      my $numParameters = "0";
      push(@hashParameters, $numParameters);      
    }

    $object->GenerateHashTable($hashName, $hashSize,
                               \@hashKeys, \@hashValues,
                               \@hashSpecials, \@hashParameters);
  }
  
  my $numConstants = @{$dataNode->constants};
  my $numFunctions = @{$dataNode->functions};

  # - Add all constants
  if ($dataNode->extendedAttributes->{"GenerateConstructor"}) {
    $hashSize = $numConstants;
    $hashName = $className . "ConstructorTable";

    @hashKeys = ();
    @hashValues = ();
    @hashSpecials = ();
    @hashParameters = ();

    foreach my $constant (@{$dataNode->constants}) {
      my $name = $constant->name;
      push(@hashKeys, $name);
      
      my $value = "${implClassName}::$name";
      push(@hashValues, $value);
      
      my $special = "DontDelete|ReadOnly";
      push(@hashSpecials, $special);
      
      my $numParameters = 0;
      push(@hashParameters, $numParameters); 
    }

    $object->GenerateHashTable($hashName, $hashSize,
                               \@hashKeys, \@hashValues,
                               \@hashSpecials, \@hashParameters);

    my $protoClassName;
    $protoClassName = "${className}Proto";

    push(@implContent, constructorFor($className, $protoClassName, $interfaceName, $dataNode->extendedAttributes->{"CanBeConstructed"}));
  }
  
  # - Add functions and constants to a hashtable definition
  $hashSize = $numFunctions + $numConstants;
  $hashName = $className . "ProtoTable";

  @hashKeys = ();
  @hashValues = ();
  @hashSpecials = ();
  @hashParameters = ();

  foreach my $constant (@{$dataNode->constants}) {
      my $name = $constant->name;
      push(@hashKeys, $name);
        
      my $value = "${implClassName}::$name";
      push(@hashValues, $value);
        
      my $special = "DontDelete|ReadOnly";
      push(@hashSpecials, $special);
        
      my $numParameters = 0;
      push(@hashParameters, $numParameters); 
  }
    
  foreach my $function (@{$dataNode->functions}) {
    my $name = $function->signature->name;
    push(@hashKeys, $name);
    
    my $value = $className . "::" . ucfirst($name) . "FuncNum";
    push(@hashValues, $value);
    
    my $special = "DontDelete|Function";
    push(@hashSpecials, $special);
    
    my $numParameters = @{$function->parameters};
    push(@hashParameters, $numParameters);
  }
    
  $object->GenerateHashTable($hashName, $hashSize,
                             \@hashKeys, \@hashValues,
                             \@hashSpecials, \@hashParameters);

  if($numFunctions > 0) {
      push(@implContent, protoFuncFor($className));
  }

  push(@implContent, "const ClassInfo ${className}Proto::info = { \"$interfaceName\", 0, &${className}ProtoTable, 0 };\n\n");
  if ($dataNode->extendedAttributes->{"DoNotCache"}) {
      push(@implContent, "JSObject* ${className}Proto::self()\n");
      push(@implContent, "{\n");
      push(@implContent, "    return new ${className}Proto();\n");
      push(@implContent, "}\n\n");
  } else {
      push(@implContent, "JSObject* ${className}Proto::self(ExecState* exec)\n");
      push(@implContent, "{\n");
      push(@implContent, "    return ::cacheGlobalObject<${className}Proto>(exec, \"[[${className}.prototype]]\");\n");
      push(@implContent, "}\n\n");
  }
  if ($numConstants > 0 || $numFunctions > 0) {
      push(@implContent, "bool ${className}Proto::getOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n");
      push(@implContent, "{\n");
      if ($numConstants eq 0) {
          push(@implContent, "    return getStaticFunctionSlot<${className}ProtoFunc, JSObject>(exec, &${className}ProtoTable, this, propertyName, slot);\n");
      } elsif ($numFunctions eq 0) {
          push(@implContent, "    return getStaticValueSlot<${className}Proto, JSObject>(exec, &${className}ProtoTable, this, propertyName, slot);\n");
      } else {
          push(@implContent, "    return getStaticPropertySlot<${className}ProtoFunc, ${className}Proto, JSObject>(exec, &${className}ProtoTable, this, propertyName, slot);\n");
      }
      push(@implContent, "}\n\n");
  }
  if ($numConstants ne 0) {
      push(@implContent, "JSValue* ${className}Proto::getValueProperty(ExecState*, int token) const\n{\n");
      push(@implContent, "    // The token is the numeric value of its associated constant\n");
      push(@implContent, "    return jsNumber(token);\n}\n\n");
  }
  
  # - Initialize static ClassInfo object
  push(@implContent, "const ClassInfo $className" . "::info = { \"$interfaceName\", ");
  if ($hasParent) {
    push(@implContent, "&" .$parentClassName . "::info, ");
  } else {
    push(@implContent, "0, ");
  }
  
  if ($numAttributes > 0) {
    push(@implContent, "&${className}Table, ");
  } else {
    push(@implContent, "0, ")
  }
  push(@implContent, "0 };\n\n");
    
  # Constructor
  if ($dataNode->extendedAttributes->{"DoNotCache"}) {
      push(@implContent, "${className}::$className($implClassName* impl)\n");
      push(@implContent, "    : $parentClassName(impl)\n");
  } else {
      push(@implContent, "${className}::$className(ExecState* exec, $implClassName* impl)\n");
      if ($hasParent) {
          push(@implContent, "    : $parentClassName(exec, impl)\n");
      } else {
          push(@implContent, "    : m_impl(impl)\n");
      }
  }
  
  if ($dataNode->extendedAttributes->{"DoNotCache"}) {
      push(@implContent, "{\n    setPrototype(${className}Proto::self());\n}\n\n");
  } else {
      push(@implContent, "{\n    setPrototype(${className}Proto::self(exec));\n}\n\n");
  }
  
  # Destructor
  if (!$hasParent) {
    push(@implContent, "${className}::~$className()\n");
    push(@implContent, "{\n    ScriptInterpreter::forgetDOMObject(m_impl.get());\n}\n\n");    
  }

  # Document needs a special destructor because it's a special case for caching. It needs
  # its own special handling rather than relying on the caching that Node normally does.
  if ($interfaceName eq "Document") {
    push(@implContent, "${className}::~$className()\n");
    push(@implContent, "{\n    ScriptInterpreter::forgetDOMObject(static_cast<${implClassName}*>(m_impl.get()));\n}\n\n");    
  }
  
  # Attributes
  if ($numAttributes ne 0) {
    push(@implContent, "bool ${className}::getOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n");
    push(@implContent, "{\n");
    # FIXME: We need to provide scalable hooks/attributes for this kind of extension
    if ($interfaceName eq "DOMWindow") {
        push(@implContent, "    if (getOverridePropertySlot(exec, propertyName, slot))\n");
        push(@implContent, "        return true;\n");
    }
    
    my $requiresManualLookup = $dataNode->extendedAttributes->{"HasIndexGetter"} || $dataNode->extendedAttributes->{"HasNameGetter"};
    if ($requiresManualLookup) {
        push(@implContent, "    const HashEntry* entry = Lookup::findEntry(&${className}Table, propertyName);\n");
        push(@implContent, "    if (entry) {\n");
        push(@implContent, "        slot.setStaticEntry(this, entry, staticValueGetter<$className>);\n");
        push(@implContent, "        return true;\n");
        push(@implContent, "    }\n");
    }
    
    if ($dataNode->extendedAttributes->{"HasNameGetter"}) {
        # if it has a prototype, we need to check that first too
        push(@implContent, "    if (prototype()->isObject() && static_cast<JSObject*>(prototype())->hasProperty(exec, propertyName))\n");
        push(@implContent, "        return false;\n");
    }
    
    if ($dataNode->extendedAttributes->{"HasIndexGetter"}) {
        push(@implContent, "    bool ok;\n");
        push(@implContent, "    unsigned u = propertyName.toUInt32(&ok);\n");
        push(@implContent, "    if (ok && u < static_cast<$implClassName*>(impl())->length()) {\n");
        push(@implContent, "        slot.setCustomIndex(this, u, indexGetter);\n");
        push(@implContent, "        return true;\n");
        push(@implContent, "    }\n");
    }
    
    if ($dataNode->extendedAttributes->{"HasNameGetter"}) {
        push(@implContent, "    if (canGetItemsForName(exec, static_cast<$implClassName*>(impl()), propertyName)) {\n");
        push(@implContent, "        slot.setCustom(this, nameGetter);\n");
        push(@implContent, "        return true;\n");
        push(@implContent, "    }\n");
    }
    
    if ($requiresManualLookup) {
        push(@implContent, "    return ${parentClassName}::getOwnPropertySlot(exec, propertyName, slot);\n");
    } else {
        push(@implContent, "    return getStaticValueSlot<$className, $parentClassName>(exec, &${className}Table, this, propertyName, slot);\n");
    }
    push(@implContent, "}\n\n");
  
    push(@implContent, "JSValue* ${className}::getValueProperty(ExecState* exec, int token) const\n{\n");
    push(@implContent, "    $implClassName* imp = static_cast<$implClassName*>(impl());\n\n");
    my $impArrayIndex = $#implContent;
    my $impNeedsDeclaration = 0;
    push(@implContent, "    switch (token) {\n");

    foreach my $attribute (@{$dataNode->attributes}) {
      my $name = $attribute->signature->name;
        
      if ($attribute->signature->extendedAttributes->{"Custom"} || $attribute->signature->extendedAttributes->{"CustomGetter"}) {
        push(@implContent, "    case " . ucfirst($name) . "AttrNum:\n");
          if ($dataNode->extendedAttributes->{"CheckDomainSecurity"} && !$attribute->signature->extendedAttributes->{"DoNotCheckDomainSecurity"}) { 
              push(@implContent, "        if (!isSafeScript(exec))\n"); 
              push(@implContent, "            return jsUndefined();\n"); 
          } 
          push(@implContent, "        return $name(exec);\n");
      } elsif ($attribute->signature->type =~ /Constructor$/) {
        my $constructorType = $codeGenerator->StripModule($attribute->signature->type);
        $constructorType =~ s/Constructor$//;

        push(@implContent, "    case " . $name . "ConstructorAttrNum:\n");
        if ($dataNode->extendedAttributes->{"CheckDomainSecurity"} && !$attribute->signature->extendedAttributes->{"DoNotCheckDomainSecurity"}) { 
            push(@implContent, "        if (!isSafeScript(exec))\n"); 
            push(@implContent, "            return jsUndefined();\n"); 
        } 
        push(@implContent, "        return JS" . $constructorType . "::getConstructor(exec);\n");
      } elsif (!@{$attribute->getterExceptions}) {
        push(@implContent, "    case " . ucfirst($name) . "AttrNum:\n");
          if ($dataNode->extendedAttributes->{"CheckDomainSecurity"} && !$attribute->signature->extendedAttributes->{"DoNotCheckDomainSecurity"}) { 
              push(@implContent, "        if (!isSafeScript(exec))\n"); 
              push(@implContent, "            return jsUndefined();\n"); 
          } 
          $impNeedsDeclaration++;
          push(@implContent, "        return " . NativeToJSValue($attribute->signature, "imp->$name()") . ";\n");
      } else {
          push(@implContent, "    case " . ucfirst($name) . "AttrNum: {\n");
          if ($dataNode->extendedAttributes->{"CheckDomainSecurity"} && !$attribute->signature->extendedAttributes->{"DoNotCheckDomainSecurity"}) { 
              push(@implContent, "        if (!isSafeScript(exec))\n"); 
              push(@implContent, "            return jsUndefined();\n"); 
          } 
          $impNeedsDeclaration++;
        push(@implContent, "        ExceptionCode ec = 0;\n");
        push(@implContent, "        KJS::JSValue* result = " . NativeToJSValue($attribute->signature, "imp->$name(ec)") . ";\n");
        push(@implContent, "        setDOMException(exec, ec);\n");
        push(@implContent, "        return result;\n");
        push(@implContent, "    }\n");
      }
    }

    $implContent[$impArrayIndex] = "" unless $impNeedsDeclaration;

    push(@implContent, "    }\n    return 0;\n}\n\n");
    
    # Check if we have any writable attributes
    my $hasReadWriteProperties = 0;
    foreach my $attribute (@{$dataNode->attributes}) {
      $hasReadWriteProperties = 1 if $attribute->type !~ /^readonly/;
    }
    if ($hasReadWriteProperties) {
      push(@implContent, "void ${className}::put(ExecState* exec, const Identifier& propertyName, JSValue* value, int attr)\n");
      if ($dataNode->extendedAttributes->{"HasCustomIndexSetter"}) {
        push(@implContent, "{\n" .
                           "    if (!lookupPut<$className>(exec, propertyName, value, attr, &${className}Table, this))\n");
        push(@implContent, "        indexSetter(exec, propertyName, value, attr);\n");
        push(@implContent, "}\n\n");
      }
      else {
        push(@implContent, "{\n    lookupPut<$className, $parentClassName>" .
                           "(exec, propertyName, value, attr, &${className}Table, this);\n}\n\n");
      }

      push(@implContent, "void ${className}::putValueProperty(ExecState* exec, int token, JSValue* value, int /*attr*/)\n");
      push(@implContent, "{\n");
      push(@implContent, "    $implClassName* imp = static_cast<$implClassName*>(impl());\n\n");
      my $impArrayIndex = $#implContent;
      my $impNeedsDeclaration = 0;
      push(@implContent, "    switch (token) {\n");

      foreach my $attribute (@{$dataNode->attributes}) {
        if ($attribute->type !~ /^readonly/) {
          my $name = $attribute->signature->name;
 
          if ($attribute->signature->extendedAttributes->{"Custom"} || $attribute->signature->extendedAttributes->{"CustomSetter"}) {
              push(@implContent, "    case " . ucfirst($name) . "AttrNum: {\n");
              push(@implContent, "        set" . ucfirst($name) . "(exec, value);\n");
          } elsif ($attribute->signature->type =~ /Constructor$/) {
              my $constructorType = $attribute->signature->type;
              $constructorType =~ s/Constructor$//;

              $implIncludes{"JS" . $constructorType . ".h"} = 1;
              push(@implContent, "    case " . $name ."ConstructorAttrNum: {\n");
              push(@implContent, "        // Shadowing a built-in constructor\n");

              # FIXME: We need to provide scalable hooks/attributes for this kind of extension
              push(@implContent, "        if (isSafeScript(exec))\n");
              push(@implContent, "            JSObject::put(exec, \"$name\", value);\n");
          } elsif ($attribute->signature->extendedAttributes->{"Replaceable"}) {
              push(@implContent, "    case " . ucfirst($name) . "AttrNum: {\n");
              push(@implContent, "        // Shadowing a built-in object\n");

              # FIXME: We need to provide scalable hooks/attributes for this kind of extension
              push(@implContent, "        if (isSafeScript(exec))\n");
              push(@implContent, "            JSObject::put(exec, \"$name\", value);\n");
          } else {
              push(@implContent, "    case " . ucfirst($name) ."AttrNum: {\n");
              $impNeedsDeclaration++;
              push(@implContent, "        ExceptionCode ec = 0;\n") if @{$attribute->setterExceptions};
              push(@implContent, "        imp->set" . ucfirst($name) . "(" . JSValueToNative($attribute->signature, "value"));
              push(@implContent, ", ec") if @{$attribute->setterExceptions};
              push(@implContent, ");\n");
              push(@implContent, "        setDOMException(exec, ec);\n") if @{$attribute->setterExceptions};
          }
          push(@implContent, "        break;\n");
          push(@implContent, "    }\n");
        }
      }
      push(@implContent, "    }\n"); # end switch
        
      $implContent[$impArrayIndex] = "" unless $impNeedsDeclaration;

      push(@implContent, "}\n\n"); # end function
    }
  }

  if ($dataNode->extendedAttributes->{"GenerateConstructor"}) {
    push(@implContent, "JSValue* ${className}::getConstructor(ExecState* exec)\n{\n");
    push(@implContent, "    return cacheGlobalObject<${className}Constructor>(exec, \"[[${interfaceName}.constructor]]\");\n");
    push(@implContent, "}\n");
  }    
  
  # Functions
  if($numFunctions ne 0) {
    push(@implContent, "JSValue* ${className}ProtoFunc::callAsFunction(ExecState* exec, JSObject* thisObj, const List& args)\n{\n");
    push(@implContent, "    if (!thisObj->inherits(&${className}::info))\n");
    push(@implContent, "      return throwError(exec, TypeError);\n\n");

    push(@implContent, "    $implClassName* imp = static_cast<$implClassName*>(static_cast<$className*>(thisObj)->impl());\n\n");

    push(@implContent, "    switch (id) {\n");
    foreach my $function (@{$dataNode->functions}) {
      push(@implContent, "    case ${className}::" . ucfirst($function->signature->name) . "FuncNum: {\n");

      if ($function->signature->extendedAttributes->{"Custom"}) {
        push(@implContent, "        return static_cast<${className}*>(thisObj)->" . $function->signature->name . "(exec, args);\n    }\n");
        next;
      }

      AddIncludesForType($function->signature->type);

      if (@{$function->raisesExceptions}) {
        push(@implContent, "        ExceptionCode ec = 0;\n");
      }

      my $paramIndex = 0;
      my $functionString = "imp->" . $function->signature->name . "(";
      my $numParameters = @{$function->parameters};
      my $hasOptionalArguments = 0;

      foreach my $parameter (@{$function->parameters}) {
        if (!$hasOptionalArguments && $parameter->extendedAttributes->{"Optional"}) {
          push(@implContent, "\n        int argsCount = args.size();\n");
          $hasOptionalArguments = 1;
        }

        if ($hasOptionalArguments) {
          push(@implContent, "        if (argsCount < " . ($paramIndex + 1) . ") {\n");
          GenerateImplementationFunctionCall($function, $functionString, $paramIndex, "    " x 3);
          push(@implContent, "        }\n\n");
        }

        my $name = $parameter->name;
        push(@implContent, "        bool ${name}Ok;\n") if TypeCanFailConversion($parameter);
        push(@implContent, "        " . GetNativeType($parameter) . " $name = " . JSValueToNative($parameter, "args[$paramIndex]", TypeCanFailConversion($parameter) ? "${name}Ok" : undef) . ";\n");        
        if (TypeCanFailConversion($parameter)) {
          push(@implContent, "        if (!${name}Ok) {\n");
          push(@implContent, "            setDOMException(exec, TYPE_MISMATCH_ERR);\n");
          push(@implContent, "            return jsUndefined();\n        }\n");
        }          

        # If a parameter is "an index", it should throw an INDEX_SIZE_ERR
        # exception        
        if ($parameter->extendedAttributes->{"IsIndex"}) {
          $implIncludes{"ExceptionCode.h"} = 1;
          push(@implContent, "        if ($name < 0) {\n");
          push(@implContent, "            setDOMException(exec, INDEX_SIZE_ERR);\n");
          push(@implContent, "            return jsUndefined();\n        }\n");          
        }

        $functionString .= ", " if $paramIndex;
        $functionString .= $name;

        $paramIndex++;
      }

      push(@implContent, "\n");
      GenerateImplementationFunctionCall($function, $functionString, $paramIndex, "    " x 2);

      push(@implContent, "    }\n"); # end case
    }
    push(@implContent, "    }\n"); # end switch
    push(@implContent, "    return 0;\n");
    push(@implContent, "}\n");
  }

  if ($dataNode->extendedAttributes->{"HasIndexGetter"}) {
    push(@implContent, "\nJSValue* ${className}::indexGetter(ExecState* exec, JSObject* originalObject, const Identifier& propertyName, const PropertySlot& slot)\n");
    push(@implContent, "{\n");
    push(@implContent, "    ${className}* thisObj = static_cast<$className*>(slot.slotBase());\n");
    push(@implContent, "    return toJS(exec, static_cast<$implClassName*>(thisObj->impl())->item(slot.index()));\n");
    push(@implContent, "}\n");
  }

  if (!$hasParent) {
    my $implContent = << "EOF";
KJS::JSValue* toJS(KJS::ExecState* exec, $implClassName* obj)
{
    return KJS::cacheDOMObject<$implClassName, $className>(exec, obj);
}
EOF
    push(@implContent, $implContent);
   }

   if (!$hasParent || $dataNode->extendedAttributes->{"GenerateNativeConverter"}) {
    my $implContent = << "EOF";
$implClassName* to${interfaceName}(KJS::JSValue* val)
{
    return val->isObject(&${className}::info) ? static_cast<$className*>(val)->impl() : 0;
}
EOF
    push(@implContent, $implContent);
  }
  
  if ($dataNode->extendedAttributes->{"GenerateNativeConverter"} && $hasParent) {
    push(@implContent, "\n$implClassName* ${className}::impl() const\n");
    push(@implContent, "{\n");
    push(@implContent, "    return static_cast<$implClassName*>(${parentClassName}::impl());\n");
    push(@implContent, "}\n");
  }

  push(@implContent, "\n}\n");
    
  push(@implContent, "\n#endif // ${conditional}_SUPPORT\n") if $conditional;
}

sub GenerateImplementationFunctionCall()
{
    my $function = shift;
    my $functionString = shift;
    my $paramIndex = shift;
    my $indent = shift;
    
    if (@{$function->raisesExceptions}) {
        $functionString .= ", " if $paramIndex;
        $functionString .= "ec";
    }
    $functionString .= ")";
    
    if ($function->signature->type eq "void") {
        if ($function->signature->extendedAttributes->{"Disabled"}) {
             push(@implContent, "#if 0\n");
        }
        push(@implContent, $indent . "$functionString;\n");
        if ($function->signature->extendedAttributes->{"Disabled"}) {
            push(@implContent, "#endif\n");
        }
        push(@implContent, $indent . "setDOMException(exec, ec);\n") if @{$function->raisesExceptions};
        push(@implContent, $indent . "return jsUndefined();\n");
    } else {
        push(@implContent, "\n" . $indent . "KJS::JSValue* result = " . NativeToJSValue($function->signature, $functionString) . ";\n");
        push(@implContent, $indent . "setDOMException(exec, ec);\n") if @{$function->raisesExceptions};
        push(@implContent, $indent . "return result;\n");
    }
}

sub GetNativeType
{
    my $signature = shift;
    
    my $type = $codeGenerator->StripModule($signature->type);
    
    if ($type eq "boolean") {
        return "bool";
    } elsif ($type eq "unsigned long") {
        if ($signature->extendedAttributes->{"IsIndex"}) {
            # Special-case index arguments because we need to check that
            # they aren't < 0.        
            return "int";
        } else {
            return "unsigned";
        } 
    } elsif ($type eq "long") {
        return "int";
    } elsif ($type eq "unsigned short" or $type eq "float") {
        return $type;
    } elsif ($type eq "AtomicString") {
        return "AtomicString";
    } elsif ($type eq "DOMString") {
        return "String";
    } elsif ($type eq "NodeFilter") {
        return "PassRefPtr<${type}>";
    } elsif ($type eq "CompareHow") {
        return "Range::CompareHow";
    } elsif ($type eq "EventTarget") {
        return "EventTargetNode*";
    } elsif ($type eq "SVGRect") {
        return "FloatRect";
    } elsif ($type eq "SVGPoint") {
        return "FloatPoint";
    }
    # Default, assume native type is a pointer with same type name as idl type
    return "${type}*";
}

sub TypeCanFailConversion
{
  my $signature = shift;
  
  my $type = $codeGenerator->StripModule($signature->type);

  if ($type eq "boolean") {
    return 0;
  } elsif ($type eq "unsigned long" or $type eq "long") {
    $implIncludes{"ExceptionCode.h"} = 1;
    return 1;
  } elsif ($type eq "unsigned short") {
    return 0; # or can it?
  } elsif ($type eq "CompareHow") {
    return 0; # or can it?
  } elsif ($type eq "float") {
    return 0;
  } elsif ($type eq "Attr") {
      $implIncludes{"ExceptionCode.h"} = 1;
      return 1;
  } elsif ($type eq "AtomicString" or
           $type eq "DOMString" or
           $type eq "Node" or
           $type eq "Element" or
           $type eq "DocumentType" or
           $type eq "EventTarget" or
           $type eq "Range" or
           $type eq "NodeFilter" or
           $type eq "DOMWindow" or
           $type eq "XPathEvaluator" or
           $type eq "XPathNSResolver" or
           $type eq "XPathResult" or
           $type eq "SVGMatrix" or
           $type eq "SVGRect" or
           $type eq "SVGElement" or
           $type eq "HTMLOptionElement") {
      return 0;
  } else {
    die "Don't know whether a JS value can fail conversion to type $type."
  }
}

sub JSValueToNative
{
    my $signature = shift;
    my $value = shift;
    my $okParam = shift;
    my $maybeOkParam = $okParam ? ", ${okParam}" : "";
    
    my $type = $codeGenerator->StripModule($signature->type);
    
    if ($type eq "boolean") {
        my $conv = $signature->extendedAttributes->{"ConvertUndefinedToTrue"};
        if (defined $conv) {
            return "valueToBooleanTreatUndefinedAsTrue(exec, $value)";
        } else {
            return "$value->toBoolean(exec)";
        }
    } elsif ($type eq "unsigned long" or
             $type eq "long" or
             $type eq "unsigned short") {
        if ($maybeOkParam) {
            return "$value->toInt32(exec${maybeOkParam})";
        } else {
            return "$value->toInt32(exec)";
        }
    } elsif ($type eq "CompareHow") {
        return "static_cast<Range::CompareHow>($value->toInt32(exec))";
    } elsif ($type eq "float") {
        return "$value->toNumber(exec)";
    } elsif ($type eq "AtomicString") {
        return "$value->toString(exec)";
    } elsif ($type eq "DOMString") {
        if ($signature->extendedAttributes->{"ConvertNullToNullString"}) {
            return "valueToStringWithNullCheck(exec, $value)";
        } else {
            return "$value->toString(exec)";
        }
    } elsif ($type eq "Node") {
        $implIncludes{"kjs_dom.h"} = 1;
        return "toNode($value)";
    } elsif ($type eq "EventTarget") {
        $implIncludes{"kjs_dom.h"} = 1;
        return "toEventTargetNode($value)";
    }  elsif ($type eq "Attr") {
        $implIncludes{"kjs_dom.h"} = 1;
        return "toAttr($value${maybeOkParam})";
    } elsif ($type eq "DocumentType") {
        $implIncludes{"kjs_dom.h"} = 1;
        return "toDocumentType($value)";
    } elsif ($type eq "Element") {
        $implIncludes{"kjs_dom.h"} = 1;
        return "toElement($value)";
    } elsif ($type eq "NodeFilter") {
        $implIncludes{"kjs_traversal.h"} = 1;
        return "toNodeFilter($value)";
    } elsif ($type eq "DOMWindow") {
        $implIncludes{"kjs_window.h"} = 1;
        return "toDOMWindow($value)";
    } elsif ($type eq "SVGRect") {
        $implIncludes{"JSSVGRect.h"} = 1;
        return "toFloatRect($value)";
    } elsif ($type eq "SVGPoint") {
        $implIncludes{"JSSVGPoint.h"} = 1;
        return "toFloatPoint($value)";
    }
    # Default, assume autogenerated type conversion routines
    $implIncludes{"JS$type.h"} = 1;
    return "to$type($value)";
}

sub NativeToJSValue
{
    my $signature = shift;
    my $value = shift;
    
    my $type = $codeGenerator->StripModule($signature->type);
    
    if ($type eq "boolean") {
        return "jsBoolean($value)";
    } elsif ($type eq "long" or
             $type eq "unsigned long" or 
             $type eq "short" or 
             $type eq "unsigned short" or
             $type eq "float" or 
             $type eq "double") {
        return "jsNumber($value)";
    } elsif ($type eq "DOMString") {
        my $conv = $signature->extendedAttributes->{"ConvertNullStringTo"};
        if (defined $conv) {
            if ($conv eq "Null") {
                return "jsStringOrNull($value)";
            } elsif ($conv eq "Undefined") {
                return "jsStringOrUndefined($value)";
            } elsif ($conv eq "False") {
                return "jsStringOrFalse($value)";
            } else {
                die "Unknown value for ConvertNullStringTo extended attribute";
            }
        } else {
            return "jsString($value)";
        }
    } elsif ($type eq "DOMImplementation") {
        $implIncludes{"kjs_dom.h"} = 1;
        $implIncludes{"JSDOMImplementation.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "Attr" or
             $type eq "CDATASection" or
             $type eq "Comment" or
             $type eq "Document" or
             $type eq "DocumentFragment" or
             $type eq "DocumentType" or
             $type eq "Element" or
             $type eq "EntityReference" or
             $type eq "HTMLDocument" or
             $type eq "Node" or
             $type eq "ProcessingInstruction" or
             $type eq "Text") {
        $implIncludes{"kjs_dom.h"} = 1;
        $implIncludes{"Comment.h"} = 1;
        $implIncludes{"CDATASection.h"} = 1;
        $implIncludes{"Node.h"} = 1;
        $implIncludes{"Element.h"} = 1;
        $implIncludes{"DocumentType.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "EventTarget") {
        $implIncludes{"kjs_dom.h"} = 1;
        $implIncludes{"EventTargetNode.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "Event") {
        $implIncludes{"kjs_events.h"} = 1;
        $implIncludes{"Event.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "NodeList" or $type eq "NamedNodeMap") {
        $implIncludes{"kjs_dom.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "CSSStyleSheet" or $type eq "StyleSheet" or $type eq "MediaList") {
        $implIncludes{"CSSStyleSheet.h"} = 1;
        $implIncludes{"MediaList.h"} = 1;
        $implIncludes{"kjs_css.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "StyleSheetList") {
        $implIncludes{"StyleSheetList.h"} = 1;
        $implIncludes{"kjs_css.h"} = 1;
        return "toJS(exec, $value, imp)";
    } elsif ($type eq "CSSStyleDeclaration" or $type eq "Rect") {
        $implIncludes{"CSSStyleDeclaration.h"} = 1;
        $implIncludes{"RectImpl.h"} = 1;
        $implIncludes{"kjs_css.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "RGBColor") {
        $implIncludes{"kjs_css.h"} = 1;
        return "getDOMRGBColor(exec, $value)";
    } elsif ($type eq "HTMLCanvasElement") {
        $implIncludes{"kjs_dom.h"} = 1;
        $implIncludes{"HTMLCanvasElement.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "NodeIterator" or
             $type eq "TreeWalker") {
        $implIncludes{"kjs_traversal.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "DOMWindow") {
        $implIncludes{"kjs_window.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "DOMObject") {
        $implIncludes{"JSCanvasRenderingContext2D.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "HTMLFormElement") {
        $implIncludes{"kjs_html.h"} = 1;
        $implIncludes{"HTMLFormElement.h"} = 1;
        return "toJS(exec, $value)";
    } elsif ($type eq "HTMLCollection") {
        $implIncludes{"kjs_html.h"} = 1;
        $implIncludes{"HTMLCollection.h"} = 1;
        return "getHTMLCollection(exec, $value.get())";
    } elsif ($type eq "SVGRect" or
             $type eq "SVGPoint" or
             $type eq "SVGNumber") {
        $implIncludes{"JS$type.h"} = 1;
        return "getJS$type(exec, $value)";
    }

    # Default, include header with same name.
    $implIncludes{"JS$type.h"} = 1;
    $implIncludes{"$type.h"} = 1;
    return "toJS(exec, $value)";
}

# Internal Helper
sub GenerateHashTable
{
    my $object = shift;
    
    my $name = shift;
    my $size = shift;
    my $keys = shift;
    my $values = shift;
    my $specials = shift;
    my $parameters = shift;
    
    # Helpers
    my @table = ();
    my @links = ();
    
    my $maxDepth = 0;
    my $collisions = 0;
    my $numEntries = $size;
    
    # Collect hashtable information...
    my $i = 0;
    foreach(@{$keys}) {
        my $depth = 0;
        my $h = $object->GenerateHashValue($_) % $numEntries;
        
        while(defined($table[$h])) {
            if (defined($links[$h])) {
                $h = $links[$h];
                $depth++;
            } else {
                $collisions++;
                $links[$h] = $size;
                $h = $size;
                $size++;
            }
        }
        
        $table[$h] = $i;
        
        $i++;
        $maxDepth = $depth if ($depth > $maxDepth);
    }
    
    # Ensure table is big enough (in case of undef entries at the end)
    if ($#table + 1 < $size) {
        $#table = $size - 1;
    }
    
    # Start outputing the hashtables...
    my $nameEntries = "${name}Entries";
    $nameEntries =~ s/:/_/g;
    
    # first, build the string table
    my %soffset = ();
    if (($name =~ /Proto/) or ($name =~ /Constructor/)) {
        my $type = $name;
        my $implClass;
        
        if ($name =~ /Proto/) {
            $type =~ s/Proto.*//;
            $implClass = $type; $implClass =~ s/Wrapper$//;
            push(@implContent, "/* Hash table for prototype */\n");
        } else {
            $type =~ s/Constructor.*//;
            $implClass = $type; $implClass =~ s/Constructor$//;
            push(@implContent, "/* Hash table for constructor */\n");
        }
    } else {
        push(@implContent, "/* Hash table */\n");
    }
    
    # Dump the hash table...
    push(@implContent, "\nstatic const HashEntry $nameEntries\[\] =\n\{\n");
    
    $i = 0;
    foreach $entry (@table) {
        if (defined($entry)) {
            my $key = @$keys[$entry];
            
            push(@implContent, "    \{ \"" . $key . "\"");
            push(@implContent, ", " . @$values[$entry]);
            push(@implContent, ", " . @$specials[$entry]);
            push(@implContent, ", " . @$parameters[$entry]);
            push(@implContent, ", ");
            
            if (defined($links[$i])) {
                push(@implContent, "&${nameEntries}[$links[$i]]" . " \}");
            } else {
                push(@implContent, "0 \}");
            }
        } else {
            push(@implContent, "    \{ 0, 0, 0, 0, 0 \}");
        }
        
        push(@implContent, ",") unless($i eq $size - 1);
        push(@implContent, "\n");
        
        $i++;
    }
    
    if ($size eq 0) {
        # dummy bucket -- an empty table would crash Lookup::findEntry
        push(@implContent, "    \{ 0, 0, 0, 0, 0 \}\n") ;
        $numEntries = 1;
        $size = 1;
    }
    push(@implContent, "};\n\n");
    push(@implContent, "static const HashTable $name = \n");
    push(@implContent, "{\n    2, $size, $nameEntries, $numEntries\n};\n\n");
}

# Internal helper
sub GenerateHashValue
{
    my $object = shift;
    
    @chars = split(/ */, $_[0]);
    
    # This hash is designed to work on 16-bit chunks at a time. But since the normal case
    # (above) is to hash UTF-16 characters, we just treat the 8-bit chars as if they
    # were 16-bit chunks, which should give matching results
    
    my $EXP2_32 = 4294967296;
    
    my $hash = 0x9e3779b9;
    my $l    = scalar @chars; #I wish this was in Ruby --- Maks
    my $rem  = $l & 1;
    $l = $l >> 1;
    
    my $s = 0;
    
    # Main loop
    for (; $l > 0; $l--) {
        $hash   += ord($chars[$s]);
        my $tmp = leftShift(ord($chars[$s+1]), 11) ^ $hash;
        $hash   = (leftShift($hash, 16)% $EXP2_32) ^ $tmp;
        $s += 2;
        $hash += $hash >> 11;
    }
    
    # Handle end case
    if ($rem !=0) {
        $hash += ord($chars[$s]);
        $hash ^= (leftShift($hash, 11)% $EXP2_32);
        $hash += $hash >> 17;
    }
    
    # Force "avalanching" of final 127 bits
    $hash ^= leftShift($hash, 3);
    $hash += ($hash >> 5);
    $hash = ($hash% $EXP2_32);
    $hash ^= (leftShift($hash, 2)% $EXP2_32);
    $hash += ($hash >> 15);
    $hash = $hash% $EXP2_32;
    $hash ^= (leftShift($hash, 10)% $EXP2_32);
    
    # this avoids ever returning a hash code of 0, since that is used to
    # signal "hash not computed yet", using a value that is likely to be
    # effectively the same as 0 when the low bits are masked
    $hash = 0x80000000  if ($hash == 0);
    
    return $hash;
}

# Internal helper
sub WriteData
{
    if (defined($IMPL)) {
        # Write content to file.
        print $IMPL @implContentHeader;
        
        foreach my $implInclude (sort keys(%implIncludes)) {
            print $IMPL "#include \"$implInclude\"\n";
        }
        
        print $IMPL @implContent;
        close($IMPL);
        undef($IMPL);
        
        @implHeaderContent = "";
        @implContent = "";    
        %implIncludes = ();
    }
        
    if (defined($HEADER)) {
        # Write content to file.
        print $HEADER @headerContent;
        close($HEADER);
        undef($HEADER);
        
        @headerContent = "";
    }
}

sub constructorFor
{
    my $className = shift;
    my $protoClassName = shift;
    my $interfaceName = shift;
    my $canConstruct = shift;
    
my $implContent = << "EOF";
class ${className}Constructor : public DOMObject {
public:
    ${className}Constructor(ExecState* exec) 
    { 
        setPrototype(exec->lexicalInterpreter()->builtinObjectPrototype()); 
        putDirect(prototypePropertyName, ${protoClassName}::self(exec), None);
    }
    virtual bool getOwnPropertySlot(ExecState*, const Identifier&, PropertySlot&);
    JSValue* getValueProperty(ExecState*, int token) const;
    virtual const ClassInfo* classInfo() const { return &info; }
    static const ClassInfo info;
EOF

    if ($canConstruct) {
$implContent .= << "EOF";
    virtual bool implementsConstruct() const { return true; }
    virtual JSObject* construct(ExecState* exec, const List& args) { return static_cast<JSObject*>(toJS(exec, new $interfaceName)); }
EOF
    }

$implContent .= << "EOF";
};

const ClassInfo ${className}Constructor::info = { "${interfaceName}Constructor", 0, &${className}ConstructorTable, 0 };

bool ${className}Constructor::getOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
{
    return getStaticValueSlot<${className}Constructor, DOMObject>(exec, &${className}ConstructorTable, this, propertyName, slot);
}

JSValue* ${className}Constructor::getValueProperty(ExecState*, int token) const
{
    // The token is the numeric value of its associated constant
    return jsNumber(token);
}

EOF

    return $implContent;
}

sub protoFuncFor
{
    my $className = shift;
    
my $implContent = << "EOF";
class ${className}ProtoFunc : public InternalFunctionImp {
public:
    ${className}ProtoFunc(ExecState* exec, int i, int len, const Identifier& name)
    : InternalFunctionImp(static_cast<FunctionPrototype*>(exec->lexicalInterpreter()->builtinFunctionPrototype()), name)
    , id(i)
    {
        put(exec, lengthPropertyName, jsNumber(len), DontDelete|ReadOnly|DontEnum);
    }
    virtual JSValue* callAsFunction(ExecState* exec, JSObject* thisObj, const List& args);
private:
    int id;
};

EOF
  
    return $implContent;
}

1;
