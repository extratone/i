#   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006, 2007
#   Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Please email any bugs, comments, and/or additions to this file to:
# gcc-patches@gcc.gnu.org

# This file defines procs for determining features supported by the target.

# Try to compile some code and return the messages printed by the compiler,
# and optionally the contents for assembly files.  Either a string or
# a list of two strings are returned, depending on WANT_OUTPUT.
#
# BASENAME is a basename to use for temporary files.
# WANT_OUTPUT is a flag which is 0 to request returning just the
#   compiler messages, or 1 to return the messages and the contents
#   of the assembly file.  TYPE should be "assembly" if WANT_OUTPUT
#   is set.
# TYPE is the type of compilation to perform (see target_compile).
# CONTENTS gives the contents of the input file.
# The rest is optional:
# OPTIONS: additional compiler options to use.
proc get_compiler_messages {basename want_output type contents args} {
    global tool

    if { [llength $args] > 0 } {
	set options [list "additional_flags=[lindex $args 0]"]
    } else {
	set options ""
    }

    set src ${basename}[pid].c
    switch $type {
	assembly { set output ${basename}[pid].s }
	object { set output ${basename}[pid].o }
    }
    set f [open $src "w"]
    puts $f $contents
    close $f
    set lines [${tool}_target_compile $src $output $type "$options"]
    file delete $src

    if { $want_output } {
	if { $type != "assembly" } {
	    error "WANT_OUTPUT can only be used with assembly output"
	} elseif { ![string match "" $lines] } {
	    # An error occurred.
	    set result [list $lines ""]
	} else {
	    set text ""
	    set chan [open "$output"]
	    while {[gets $chan line] >= 0} {
		append text "$line\n"
	    }
	    close $chan
	    set result [list $lines $text]
	}
    } else {
	set result $lines
    }

    remote_file build delete $output
    return $result
}

proc current_target_name { } {
    global target_info
    if [info exists target_info(target,name)] {
	set answer $target_info(target,name)
    } else {
	set answer ""
    }
    return $answer
}

# Implement an effective-target check for property PROP by invoking
# the compiler and seeing if it prints any messages.  Assume that the
# property holds if the compiler doesn't print anything.  The other
# arguments are as for get_compiler_messages, starting with TYPE.
proc check_no_compiler_messages {prop args} {
    global et_cache

    set target [current_target_name]
    if {![info exists et_cache($prop,target)]
	|| $et_cache($prop,target) != $target} {
	verbose "check_no_compiler_messages $prop: compiling source for $target" 2
	set et_cache($prop,target) $target
	set et_cache($prop,value) \
	    [string match "" [eval get_compiler_messages $prop 0 $args]]
    }
    set value $et_cache($prop,value)
    verbose "check_no_compiler_messages $prop: returning $value for $target" 2
    return $value
}

# Similar to check_no_compiler_messages, but also verify that the regular
# expression PATTERN matches the compiler's output.
proc check_no_messages_and_pattern {prop pattern args} {
    global et_cache

    set target [current_target_name]
    if {![info exists et_cache($prop,target)]
	|| $et_cache($prop,target) != $target} {
	verbose "check_no_messages_and_pattern $prop: compiling source for $target" 2
	set et_cache($prop,target) $target
	set results [eval get_compiler_messages $prop 1 $args]
	set et_cache($prop,value) \
	    [expr [string match "" [lindex $results 0]] \
		 && [regexp $pattern [lindex $results 1]]]
    }
    set value $et_cache($prop,value)
    verbose "check_no_messages_and_pattern $prop: returning $value for $target" 2
    return $value
}

###############################
# proc check_weak_available { }
###############################

# weak symbols are only supported in some configs/object formats
# this proc returns 1 if they're supported, 0 if they're not, or -1 if unsure

proc check_weak_available { } {
    global target_triplet
    global target_cpu

    # All mips targets should support it

    if { [ string first "mips" $target_cpu ] >= 0 } {
        return 1
    }

    # All solaris2 targets should support it

    if { [regexp ".*-solaris2.*" $target_triplet] } {
        return 1
    }

    # DEC OSF/1/Digital UNIX/Tru64 UNIX supports it

    if { [regexp "alpha.*osf.*" $target_triplet] } {
	return 1
    }

    # Windows targets Cygwin and MingW32 support it

    if { [regexp ".*mingw32|.*cygwin" $target_triplet] } {
	return 1
    }

    # HP-UX 10.X doesn't support it

    if { [istarget "hppa*-*-hpux10*"] } {
	return 0
    }

    # ELF and ECOFF support it. a.out does with gas/gld but may also with
    # other linkers, so we should try it

    set objformat [gcc_target_object_format]

    switch $objformat {
        elf      { return 1 }
        ecoff    { return 1 }
        a.out    { return 1 }
	mach-o	 { return 1 }
	som	 { return 1 }
        unknown  { return -1 }
        default  { return 0 }
    }
}

###############################
# proc check_visibility_available { what_kind }
###############################

# The visibility attribute is only support in some object formats
# This proc returns 1 if it is supported, 0 if not.
# The argument is the kind of visibility, default/protected/hidden/internal.

proc check_visibility_available { what_kind } {
    global tool
    global target_triplet

    # On NetWare, support makes no sense.
    if { [istarget *-*-netware*] } {
        return 0
    }

    if [string match "" $what_kind] { set what_kind "hidden" }

    return [check_no_compiler_messages visibility_available_$what_kind object "
	void f() __attribute__((visibility(\"$what_kind\")));
	void f() {}
    "]
}

###############################
# proc check_alias_available { }
###############################

# Determine if the target toolchain supports the alias attribute.

# Returns 2 if the target supports aliases.  Returns 1 if the target
# only supports weak aliased.  Returns 0 if the target does not
# support aliases at all.  Returns -1 if support for aliases could not
# be determined.

proc check_alias_available { } {
    global alias_available_saved
    global tool

    if [info exists alias_available_saved] {
        verbose "check_alias_available  returning saved $alias_available_saved" 2
    } else {
	set src alias[pid].c
	set obj alias[pid].o
        verbose "check_alias_available  compiling testfile $src" 2
	set f [open $src "w"]
	# Compile a small test program.  The definition of "g" is
	# necessary to keep the Solaris assembler from complaining
	# about the program.
	puts $f "#ifdef __cplusplus\nextern \"C\"\n#endif\n"
	puts $f "void g() {} void f() __attribute__((alias(\"g\")));"
	close $f
	set lines [${tool}_target_compile $src $obj object ""]
	file delete $src
	remote_file build delete $obj

	if [string match "" $lines] then {
	    # No error messages, everything is OK.
	    set alias_available_saved 2
	} else {
	    if [regexp "alias definitions not supported" $lines] {
		verbose "check_alias_available  target does not support aliases" 2

		set objformat [gcc_target_object_format]

		if { $objformat == "elf" } {
		    verbose "check_alias_available  but target uses ELF format, so it ought to" 2
		    set alias_available_saved -1
		} else {
		    set alias_available_saved 0
		}
	    } else {
		if [regexp "only weak aliases are supported" $lines] {
		verbose "check_alias_available  target supports only weak aliases" 2
		set alias_available_saved 1
		} else {
		    set alias_available_saved -1
		}
	    }
	}

	verbose "check_alias_available  returning $alias_available_saved" 2
    }

    return $alias_available_saved
}

# Returns true if --gc-sections is supported on the target.

proc check_gc_sections_available { } {
    global gc_sections_available_saved
    global tool

    if {![info exists gc_sections_available_saved]} {
	# Some targets don't support gc-sections despite whatever's
	# advertised by ld's options.
	if { [istarget alpha*-*-*]
	     || [istarget ia64-*-*] } {
	    set gc_sections_available_saved 0
	    return 0
	}

	# Check if the ld used by gcc supports --gc-sections.
	set gcc_spec [${tool}_target_compile "-dumpspecs" "" "none" ""]
	regsub ".*\n\*linker:\[ \t\]*\n(\[^ \t\n\]*).*" "$gcc_spec" {\1} linker
	set gcc_ld [lindex [${tool}_target_compile "-print-prog-name=$linker" "" "none" ""] 0]
	set ld_output [remote_exec host "$gcc_ld" "--help"]
	if { [ string first "--gc-sections" $ld_output ] >= 0 } {
	    set gc_sections_available_saved 1
	} else {
	    set gc_sections_available_saved 0
	}
    }
    return $gc_sections_available_saved
}

# Return true if profiling is supported on the target.

proc check_profiling_available { test_what } {
    global profiling_available_saved

    verbose "Profiling argument is <$test_what>" 1

    # These conditions depend on the argument so examine them before
    # looking at the cache variable.

    # Support for -p on solaris2 relies on mcrt1.o which comes with the
    # vendor compiler.  We cannot reliably predict the directory where the
    # vendor compiler (and thus mcrt1.o) is installed so we can't
    # necessarily find mcrt1.o even if we have it.
    if { [istarget *-*-solaris2*] && [lindex $test_what 1] == "-p" } {
	return 0
    }

    # Support for -p on irix relies on libprof1.a which doesn't appear to
    # exist on any irix6 system currently posting testsuite results.
    # Support for -pg on irix relies on gcrt1.o which doesn't exist yet.
    # See: http://gcc.gnu.org/ml/gcc/2002-10/msg00169.html
    if { [istarget mips*-*-irix*]
    && ([lindex $test_what 1] == "-p" || [lindex $test_what 1] == "-pg") } {
	return 0
    }

    # At present, there is no profiling support on NetWare.
    if { [istarget *-*-netware*] } {
	return 0
    }

    # Now examine the cache variable.
    if {![info exists profiling_available_saved]} {
	# Some targets don't have any implementation of __bb_init_func or are
	# missing other needed machinery.
	if { [istarget mmix-*-*]
	     || [istarget arm*-*-eabi*]
	     || [istarget arm*-*-elf]
	     || [istarget arm*-*-symbianelf*]
	     || [istarget powerpc-*-eabi*]
	     || [istarget strongarm*-*-elf]
	     || [istarget xscale*-*-elf]
	     || [istarget cris-*-*]
	     || [istarget h8300-*-*]
	     || [istarget m32c-*-elf]
	     || [istarget m68k-*-elf]
	     || [istarget mips*-*-elf]
	     || [istarget xtensa-*-elf]
	     || [istarget *-*-windiss] } {
	    set profiling_available_saved 0
	} else {
	    set profiling_available_saved 1
	}
    }

    return $profiling_available_saved
}

# Return 1 if target has packed layout of structure members by
# default, 0 otherwise.  Note that this is slightly different than
# whether the target has "natural alignment": both attributes may be
# false.

proc check_effective_target_default_packed { } {
    return [check_no_compiler_messages default_packed assembly {
	struct x { char a; long b; } c;
	int s[sizeof (c) == sizeof (char) + sizeof (long) ? 1 : -1];
    }]
}

# Return 1 if target has PCC_BITFIELD_TYPE_MATTERS defined.  See
# documentation, where the test also comes from.

proc check_effective_target_pcc_bitfield_type_matters { } {
    # PCC_BITFIELD_TYPE_MATTERS isn't just about unnamed or empty
    # bitfields, but let's stick to the example code from the docs.
    return [check_no_compiler_messages pcc_bitfield_type_matters assembly {
	struct foo1 { char x; char :0; char y; };
	struct foo2 { char x; int :0; char y; };
	int s[sizeof (struct foo1) != sizeof (struct foo2) ? 1 : -1];
    }]
}

# Return 1 if thread local storage (TLS) is supported, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_tls {} {
    global et_tls_saved
    global tool

    if [info exists et_tls_saved] {
	verbose "check_effective_target_tls: using cached result" 2
    } else {
	set et_tls_saved 1

	set src tls[pid].c
	set asm tls[pid].S
	verbose "check_effective_target_tls: compiling testfile $src" 2
	set f [open $src "w"]
	# Compile a small test program.
	puts $f "__thread int i;\n"
	close $f

	# Test for thread-local data supported by the platform.
	set comp_output \
	    [${tool}_target_compile $src $asm assembly ""]
	file delete $src
	if { [string match "*not supported*" $comp_output] } {
	    set et_tls_saved 0
	}
	remove-build-file $asm
    }
    verbose "check_effective_target_tls: returning $et_tls_saved" 2
    return $et_tls_saved
}

# Return 1 if TLS executables can run correctly, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_tls_runtime {} {
    global et_tls_runtime_saved
    global tool

    if [info exists et_tls_runtime_saved] {
	verbose "check_effective_target_tls_runtime: using cached result" 2
    } else {
	set et_tls_runtime_saved 0

	set src tls_runtime[pid].c
	set exe tls_runtime[pid].x
	verbose "check_effective_target_tls_runtime: compiling testfile $src" 2
	set f [open $src "w"]
	# Compile a small test program.
	puts $f "__thread int thr = 0;\n"
	puts $f "int main(void)\n {\n return thr;\n}"
	close $f

	set comp_output \
	    [${tool}_target_compile $src $exe executable ""]
	file delete $src

	if [string match "" $comp_output] then {
	    # No error messages, everything is OK.

	    set result [remote_load target "./$exe" "" ""]
	    set status [lindex $result 0]
	    remote_file build delete $exe

	    verbose "check_effective_target_tls_runtime status is <$status>" 2

	    if { $status == "pass" } {
		set et_tls_runtime_saved 1
	    }

	    verbose "check_effective_target_tls_runtime: returning $et_tls_runtime_saved" 2
	}
    }

    return $et_tls_runtime_saved
}

# Return 1 if compilation with -fopenmp is error-free for trivial
# code, 0 otherwise.

proc check_effective_target_fopenmp {} {
    return [check_no_compiler_messages fopenmp object {
	void foo (void) { }
    } "-fopenmp"]
}

# Return 1 if compilation with -freorder-blocks-and-partition is error-free
# for trivial code, 0 otherwise.

proc check_effective_target_freorder {} {
    return [check_no_compiler_messages freorder object {
	void foo (void) { }
    } "-freorder-blocks-and-partition"]
}

# Return 1 if -fpic and -fPIC are supported, as in no warnings or errors
# emitted, 0 otherwise.  Whether a shared library can actually be built is
# out of scope for this test.

proc check_effective_target_fpic { } {
    # Note that M68K has a multilib that supports -fpic but not
    # -fPIC, so we need to check both.  We test with a program that
    # requires GOT references.
    foreach arg {fpic fPIC} {
	if [check_no_compiler_messages $arg object {
	    extern int foo (void); extern int bar;
	    int baz (void) { return foo () + bar; }
	} "-$arg"] {
	    return 1
	}
    }
    return 0
}

# Return true if the target supports -mpaired-single (as used on MIPS).

proc check_effective_target_mpaired_single { } {
    return [check_no_compiler_messages mpaired_single object {
	void foo (void) { }
    } "-mpaired-single"]
}

# Return true if iconv is supported on the target. In particular IBM1047.

proc check_iconv_available { test_what } {
    global tool
    global libiconv

    set result ""

    set src iconv[pid].c
    set exe iconv[pid].x
    verbose "check_iconv_available compiling testfile $src" 2
    set f [open $src "w"]
    # Compile a small test program.
    puts $f "#include <iconv.h>\n"
    puts $f "int main (void)\n {\n iconv_t cd; \n"
    puts $f "cd = iconv_open (\"[lindex $test_what 1]\", \"UTF-8\");\n"
    puts $f "if (cd == (iconv_t) -1)\n return 1;\n"
    puts $f "return 0;\n}"
    close $f

    # If the tool configuration file has not set libiconv, try "-liconv"
    if { ![info exists libiconv] } {
	set libiconv "-liconv"
    }
    set lines [${tool}_target_compile $src $exe executable "libs=$libiconv" ]
    file delete $src

    if [string match "" $lines] then {
	# No error messages, everything is OK.

	set result [${tool}_load "./$exe" "" ""]
	set status [lindex $result 0]
	remote_file build delete $exe

	verbose "check_iconv_available status is <$status>" 2

	if { $status == "pass" } then {
	    return 1
	}
    }

    return 0
}

# Return true if named sections are supported on this target.

proc check_named_sections_available { } {
    return [check_no_compiler_messages named_sections assembly {
	int __attribute__ ((section("whatever"))) foo;
    }]
}

# Return 1 if the target supports Fortran real kinds larger than real(8),
# 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_fortran_large_real { } {
    global et_fortran_large_real_saved
    global et_fortran_large_real_target_name
    global tool

    if { ![info exists et_fortran_large_real_target_name] } {
	set et_fortran_large_real_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_fortran_large_real_target_name } {
	verbose "check_effective_target_fortran_large_real: `$et_fortran_large_real_target_name' `$current_target'" 2
	set et_fortran_large_real_target_name $current_target
	if [info exists et_fortran_large_real_saved] {
	    verbose "check_effective_target_fortran_large_real: removing cached result" 2
	    unset et_fortran_large_real_saved
	}
    }

    if [info exists et_fortran_large_real_saved] {
	verbose "check_effective_target_fortran_large_real returning saved $et_fortran_large_real_saved" 2
    } else {
	set et_fortran_large_real_saved 0

	# Set up, compile, and execute a test program using large real
	# kinds.  Include the current process ID in the file names to
	# prevent conflicts with invocations for multiple testsuites.
	set src real[pid].f90
        set exe real[pid].x

	set f [open $src "w"]
	puts $f "integer,parameter :: k = &"
        puts $f "  selected_real_kind (precision (0.0_8) + 1)"
        puts $f "real(kind=k) :: x"
        puts $f "x = cos (x);"
	puts $f "end"
	close $f

	verbose "check_effective_target_fortran_large_real compiling testfile $src" 2
	set lines [${tool}_target_compile $src $exe executable ""]
	file delete $src

	if [string match "" $lines] then {
	    # No error message, compilation succeeded.
  	    set et_fortran_large_real_saved 1
	}
    }

    return $et_fortran_large_real_saved
}

# Return 1 if the target supports Fortran integer kinds larger than
# integer(8), 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_fortran_large_int { } {
    global et_fortran_large_int_saved
    global et_fortran_large_int_target_name
    global tool

    if { ![info exists et_fortran_large_int_target_name] } {
	set et_fortran_large_int_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_fortran_large_int_target_name } {
	verbose "check_effective_target_fortran_large_int: `$et_fortran_large_int_target_name' `$current_target'" 2
	set et_fortran_large_int_target_name $current_target
	if [info exists et_fortran_large_int_saved] {
	    verbose "check_effective_target_fortran_large_int: removing cached result" 2
	    unset et_fortran_large_int_saved
	}
    }

    if [info exists et_fortran_large_int_saved] {
	verbose "check_effective_target_fortran_large_int returning saved $et_fortran_large_int_saved" 2
    } else {
	set et_fortran_large_int_saved 0

	# Set up, compile, and execute a test program using large integer
	# kinds.  Include the current process ID in the file names to
	# prevent conflicts with invocations for multiple testsuites.
	set src int[pid].f90
        set exe int[pid].x

	set f [open $src "w"]
	puts $f "integer,parameter :: k = &"
        puts $f "  selected_int_kind (range (0_8) + 1)"
        puts $f "integer(kind=k) :: i"
	puts $f "end"
	close $f

	verbose "check_effective_target_fortran_large_int compiling testfile $src" 2
	set lines [${tool}_target_compile $src $exe executable ""]
	file delete $src

	if [string match "" $lines] then {
	    # No error message, compilation succeeded.
	    set et_fortran_large_int_saved 1
	}
    }

    return $et_fortran_large_int_saved
}

# Return 1 if we can statically link libgfortran, 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_static_libgfortran { } {
    global et_static_libgfortran
    global et_static_libgfortran_target_name
    global tool

    if { ![info exists et_static_libgfortran_target_name] } {
       set et_static_libgfortran_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_static_libgfortran_target_name } {
       verbose "check_effective_target_static_libgfortran: `$et_static_libgfortran_target_name' `$current_target'" 2
       set et_static_libgfortran_target_name $current_target
       if [info exists et_static_libgfortran_saved] {
           verbose "check_effective_target_static_libgfortran: removing cached result" 2
           unset et_static_libgfortran_saved
       }
    }

    if [info exists et_static_libgfortran_saved] {
       verbose "check_effective_target_static_libgfortran returning saved $et_static_libgfortran_saved" 2
    } else {
       set et_static_libgfortran_saved 0

       # Set up, compile, and execute a test program using static linking.
       # Include the current process ID in the file names to prevent
       # conflicts with invocations for multiple testsuites.
       set opts "additional_flags=-static"
       set src static[pid].f
       set exe static[pid].x

       set f [open $src "w"]
       puts $f "      print *, 'test'"
       puts $f "      end"
       close $f

       verbose "check_effective_target_static_libgfortran compiling testfile $src" 2
       set lines [${tool}_target_compile $src $exe executable "$opts"]
       file delete $src

       if [string match "" $lines] then {
           # No error message, compilation succeeded.
           set et_static_libgfortran_saved 1
       }
    }

    return $et_static_libgfortran_saved
}

# Return 1 if the target supports executing AltiVec instructions, 0
# otherwise.  Cache the result.

proc check_vmx_hw_available { } {
    global vmx_hw_available_saved
    global tool

    if [info exists vmx_hw_available_saved] {
	verbose "check_hw_available  returning saved $vmx_hw_available_saved" 2
    } else {
	set vmx_hw_available_saved 0

	# Some simulators are known to not support VMX instructions.
	if { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] } {
	    verbose "check_hw_available  returning 0" 2
	    return $vmx_hw_available_saved
	}

	# Set up, compile, and execute a test program containing VMX
	# instructions.  Include the current process ID in the file
	# names to prevent conflicts with invocations for multiple
	# testsuites.
	set src vmx[pid].c
	set exe vmx[pid].x

	set f [open $src "w"]
	puts $f "int main() {"
	puts $f "#ifdef __MACH__"
	puts $f "  asm volatile (\"vor v0,v0,v0\");"
	puts $f "#else"
	puts $f "  asm volatile (\"vor 0,0,0\");"
	puts $f "#endif"
	puts $f "  return 0; }"
	close $f

	# Most targets don't require special flags for this test case, but
	# Darwin does.
	if [istarget *-*-darwin*] {
	  set opts "additional_flags=-maltivec"
	} else {
	  set opts ""
	}

	verbose "check_vmx_hw_available  compiling testfile $src" 2
	set lines [${tool}_target_compile $src $exe executable "$opts"]
	file delete $src

	if [string match "" $lines] then {
	    # No error message, compilation succeeded.
	    set result [${tool}_load "./$exe" "" ""]
	    set status [lindex $result 0]
	    remote_file build delete $exe
	    verbose "check_vmx_hw_available testfile status is <$status>" 2

	    if { $status == "pass" } then {
		set vmx_hw_available_saved 1
	    }
	} else {
	    verbose "check_vmx_hw_availalble testfile compilation failed" 2
	}
    }

    return $vmx_hw_available_saved
}

# GCC 3.4.0 for powerpc64-*-linux* included an ABI fix for passing
# complex float arguments.  This affects gfortran tests that call cabsf
# in libm built by an earlier compiler.  Return 1 if libm uses the same
# argument passing as the compiler under test, 0 otherwise.
#
# When the target name changes, replace the cached result.

proc check_effective_target_broken_cplxf_arg { } {
    global et_broken_cplxf_arg_saved
    global et_broken_cplxf_arg_target_name
    global tool

    # Skip the work for targets known not to be affected.
    if { ![istarget powerpc64-*-linux*] } {
	return 0
    } elseif { [is-effective-target ilp32] } {
	return 0
    }

    if { ![info exists et_broken_cplxf_arg_target_name] } {
	set et_broken_cplxf_arg_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_broken_cplxf_arg_target_name } {
	verbose "check_effective_target_broken_cplxf_arg: `$et_broken_cplxf_arg_target_name'" 2
	set et_broken_cplxf_arg_target_name $current_target
	if [info exists et_broken_cplxf_arg_saved] {
	    verbose "check_effective_target_broken_cplxf_arg: removing cached result" 2
	    unset et_broken_cplxf_arg_saved
	}
    }

    if [info exists et_broken_cplxf_arg_saved] {
	verbose "check_effective_target_broken_cplxf_arg: using cached result" 2
    } else {
	set et_broken_cplxf_arg_saved 0
	# This is only known to affect one target.
	if { ![istarget powerpc64-*-linux*] || ![is-effective-target lp64] } {
	    set et_broken_cplxf_arg_saved 0
	    verbose "check_effective_target_broken_cplxf_arg: caching 0" 2
	    return $et_broken_cplxf_arg_saved
	}

	# Set up, compile, and execute a C test program that calls cabsf.
	set src cabsf[pid].c
	set exe cabsf[pid].x

	set f [open $src "w"]
	puts $f "#include <complex.h>"
	puts $f "extern void abort (void);"
	puts $f "float fabsf (float);"
	puts $f "float cabsf (_Complex float);"
	puts $f "int main ()"
	puts $f "{"
	puts $f "  _Complex float cf;"
	puts $f "  float f;"
	puts $f "  cf = 3 + 4.0fi;"
	puts $f "  f = cabsf (cf);"
	puts $f "  if (fabsf (f - 5.0) > 0.0001) abort ();"
	puts $f "  return 0;"
	puts $f "}"
	close $f

	set lines [${tool}_target_compile $src $exe executable "-lm"]
	file delete $src

	if [string match "" $lines] {
	    # No error message, compilation succeeded.
	    set result [${tool}_load "./$exe" "" ""]
	    set status [lindex $result 0]
	    remote_file build delete $exe

	    verbose "check_effective_target_broken_cplxf_arg: status is <$status>" 2

	    if { $status != "pass" } {
		set et_broken_cplxf_arg_saved 1
	    }
	} else {
	    verbose "check_effective_target_broken_cplxf_arg: compilation failed" 2
	}
    }
    return $et_broken_cplxf_arg_saved
}

proc check_alpha_max_hw_available { } {
    global alpha_max_hw_available_saved
    global tool

    if [info exists alpha_max_hw_available_saved] {
	verbose "check_alpha_max_hw_available returning saved $alpha_max_hw_available_saved" 2
    } else {
	set alpha_max_hw_available_saved 0

	# Set up, compile, and execute a test program probing bit 8 of the
	# architecture mask, which indicates presence of MAX instructions.
	set src max[pid].c
	set exe max[pid].x

	set f [open $src "w"]
	puts $f "int main() { return __builtin_alpha_amask(1<<8) != 0; }"
	close $f

	verbose "check_alpha_max_hw_available compiling testfile $src" 2
	set lines [${tool}_target_compile $src $exe executable ""]
	file delete $src

	if [string match "" $lines] then {
	    # No error message, compilation succeeded.
	    set result [${tool}_load "./$exe" "" ""]
	    set status [lindex $result 0]
	    remote_file build delete $exe
	    verbose "check_alpha_max_hw_available testfile status is <$status>" 2

	    if { $status == "pass" } then {
		set alpha_max_hw_available_saved 1
	    }
	} else {
	    verbose "check_alpha_max_hw_availalble testfile compilation failed" 2
	}
    }

    return $alpha_max_hw_available_saved
}

# Returns true iff the FUNCTION is available on the target system.
# (This is essentially a Tcl implementation of Autoconf's
# AC_CHECK_FUNC.)

proc check_function_available { function } {
    set var "${function}_available_saved"
    global $var
    global tool

    if {![info exists $var]} {
	# Assume it exists.
	set $var 1
	# Check to make sure.
	set src "function[pid].c"
	set exe "function[pid].exe"

	set f [open $src "w"]
	puts $f "#ifdef __cplusplus\nextern \"C\"\n#endif\n"
	puts $f "char $function ();\n"
	puts $f "int main () { $function (); }"
	close $f

	set lines [${tool}_target_compile $src $exe executable ""]
	file delete $src
	file delete $exe

	if {![string match "" $lines]} then {
	    set $var 0
	    verbose -log "$function is not available"
	} else {
	    verbose -log "$function is available"
	}
    }

    eval return \$$var
}

# Returns true iff "fork" is available on the target system.

proc check_fork_available {} {
    return [check_function_available "fork"]
}

# Returns true iff "mkfifo" is available on the target system.

proc check_mkfifo_available {} {
    if {[istarget *-*-cygwin*]} {
       # Cygwin has mkfifo, but support is incomplete.
       return 0
     }

    return [check_function_available "mkfifo"]
}

# Returns true iff "__cxa_atexit" is used on the target system.

proc check_cxa_atexit_available { } {
    global et_cxa_atexit
    global et_cxa_atexit_target_name
    global tool	

    if { ![info exists et_cxa_atexit_target_name] } {
	set et_cxa_atexit_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_cxa_atexit_target_name } {
	verbose "check_cxa_atexit_available: `$et_cxa_atexit_target_name'" 2
	set et_cxa_atexit_target_name $current_target
	if [info exists et_cxa_atexit] {
	    verbose "check_cxa_atexit_available: removing cached result" 2
	    unset et_cxa_atexit
	}
    }

    if [info exists et_cxa_atexit] {
	verbose "check_cxa_atexit_available: using cached result" 2
    } elseif { [istarget "hppa*-*-hpux10*"] } {
	# HP-UX 10 doesn't have __cxa_atexit but subsequent test passes.
	set et_cxa_atexit 0
    } else {
	set et_cxa_atexit 0

	# Set up, compile, and execute a C++ test program that depends
	# on correct ordering of static object destructors. This is
	# indicative of the presence and use of __cxa_atexit.
	set src cxaatexit[pid].cc
	set exe cxaatexit[pid].x

	set f [open $src "w"]
	puts $f "#include <stdlib.h>"
	puts $f "static unsigned int count;"
	puts $f "struct X"
	puts $f "{"
	puts $f "  X() { count = 1; }"
	puts $f "  ~X()"
	puts $f "  {"
	puts $f "    if (count != 3)"
	puts $f "      exit(1);"
	puts $f "    count = 4;"
        puts $f "  }"
        puts $f "};"
	puts $f "void f()"
	puts $f "{"
	puts $f "  static X x;"
        puts $f "}"
	puts $f "struct Y"
	puts $f "{"
	puts $f "  Y() { f(); count = 2; }"
	puts $f "  ~Y()"
	puts $f "  {"
	puts $f "    if (count != 2)"
	puts $f "      exit(1);"
	puts $f "    count = 3;"
        puts $f "  }"
        puts $f "};"
	puts $f "Y y;"
	puts $f "int main()"
	puts $f "{ return 0; }"
	close $f

	set lines [${tool}_target_compile $src $exe executable ""]
	file delete $src

	if [string match "" $lines] {
	    # No error message, compilation succeeded.
	    set result [${tool}_load "./$exe" "" ""]
	    set status [lindex $result 0]
	    remote_file build delete $exe

	    verbose "check_cxa_atexit_available: status is <$status>" 2

	    if { $status == "pass" } {
		set et_cxa_atexit 1
	    }
	} else {
	    verbose "check_cxa_atexit_available: compilation failed" 2
	}
    }
    return $et_cxa_atexit
}


# Return 1 if we're generating 32-bit code using default options, 0
# otherwise.

proc check_effective_target_ilp32 { } {
    return [check_no_compiler_messages ilp32 object {
	int dummy[sizeof (int) == 4
		  && sizeof (void *) == 4
		  && sizeof (long) == 4 ? 1 : -1];
    }]
}

# Return 1 if we're generating 32-bit or larger integers using default
# options, 0 otherwise.

proc check_effective_target_int32plus { } {
    return [check_no_compiler_messages int32plus object {
	int dummy[sizeof (int) >= 4 ? 1 : -1];
    }]
}

# Return 1 if we're generating 32-bit or larger pointers using default
# options, 0 otherwise.

proc check_effective_target_ptr32plus { } {
    return [check_no_compiler_messages ptr32plus object {
	int dummy[sizeof (void *) >= 4 ? 1 : -1];
    }]
}

# Return 1 if we support 32-bit or larger array and structure sizes
# using default options, 0 otherwise.

proc check_effective_target_size32plus { } {
    return [check_no_compiler_messages size32plus object {
	char dummy[65537];
    }]
}

# Returns 1 if we're generating 16-bit or smaller integers with the
# default options, 0 otherwise.

proc check_effective_target_int16 { } {
    return [check_no_compiler_messages int16 object {
	int dummy[sizeof (int) < 4 ? 1 : -1];
    }]
}

# Return 1 if we're generating 64-bit code using default options, 0
# otherwise.

proc check_effective_target_lp64 { } {
    return [check_no_compiler_messages lp64 object {
	int dummy[sizeof (int) == 4
		  && sizeof (void *) == 8
		  && sizeof (long) == 8 ? 1 : -1];
    }]
}

# Return 1 if the target supports compiling decimal floating point,
# 0 otherwise.

proc check_effective_target_dfp_nocache { } {
    verbose "check_effective_target_dfp_nocache: compiling source" 2
    set ret [string match "" [get_compiler_messages dfp 0 object {
        _Decimal32 x; _Decimal64 y; _Decimal128 z;
    }]]
    verbose "check_effective_target_dfp_nocache: returning $ret" 2
    return $ret
}

proc check_effective_target_dfprt_nocache { } {
    global tool

    set ret 0

    verbose "check_effective_target_dfprt_nocache: compiling source" 2
    # Set up, compile, and execute a test program containing decimal
    # float operations.
    set src dfprt[pid].c
    set exe dfprt[pid].x

    set f [open $src "w"]
    puts $f "_Decimal32 x = 1.2df; _Decimal64 y = 2.3dd; _Decimal128 z;"
    puts $f "int main () { z = x + y; return 0; }"
    close $f

    verbose "check_effective_target_dfprt_nocache: compiling testfile $src" 2
    set lines [${tool}_target_compile $src $exe executable ""]
    file delete $src

    if [string match "" $lines] then {
	# No error message, compilation succeeded.
	set result [${tool}_load "./$exe" "" ""]
	set status [lindex $result 0]
	remote_file build delete $exe
	verbose "check_effective_target_dfprt_nocache: testfile status is <$status>" 2
	if { $status == "pass" } then {
	    set ret 1
	}
    }
    return $ret
    verbose "check_effective_target_dfprt_nocache: returning $ret" 2
}

# Return 1 if the target supports compiling Decimal Floating Point,
# 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_dfp { } {
    global et_dfp_saved

    if [info exists et_dfp_saved] {
	verbose "check_effective_target_dfp: using cached result" 2
    } else {
	set et_dfp_saved [check_effective_target_dfp_nocache]
    }
    verbose "check_effective_target_dfp: returning $et_dfp_saved" 2
    return $et_dfp_saved
}

# Return 1 if the target supports linking and executing Decimal Floating
# Point, # 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_dfprt { } {
    global et_dfprt_saved
    global tool

    if [info exists et_dfprt_saved] {
	verbose "check_effective_target_dfprt: using cached result" 2
    } else {
	set et_dfprt_saved [check_effective_target_dfprt_nocache]
    }
    verbose "check_effective_target_dfprt: returning $et_dfprt_saved" 2
    return $et_dfprt_saved
}

# Return 1 if the target needs a command line argument to enable a SIMD
# instruction set.

proc check_effective_target_vect_cmdline_needed { } {
    global et_vect_cmdline_needed_saved
    global et_vect_cmdline_needed_target_name

    if { ![info exists et_vect_cmdline_needed_target_name] } {
	set et_vect_cmdline_needed_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_vect_cmdline_needed_target_name } {
	verbose "check_effective_target_vect_cmdline_needed: `$et_vect_cmdline_needed_target_name' `$current_target'" 2
	set et_vect_cmdline_needed_target_name $current_target
	if { [info exists et_vect_cmdline_needed_saved] } {
	    verbose "check_effective_target_vect_cmdline_needed: removing cached result" 2
	    unset et_vect_cmdline_needed_saved
	}
    }

    if [info exists et_vect_cmdline_needed_saved] {
	verbose "check_effective_target_vect_cmdline_needed: using cached result" 2
    } else {
	set et_vect_cmdline_needed_saved 1
	if { [istarget ia64-*-*]
	     || (([istarget x86_64-*-*] || [istarget i?86-*-*])
		 && [check_effective_target_lp64])
	     || ([istarget powerpc*-*-*]
		 && ([check_effective_target_powerpc_spe]
		     || [check_effective_target_powerpc_altivec]))} {
	   set et_vect_cmdline_needed_saved 0
	}
    }

    verbose "check_effective_target_vect_cmdline_needed: returning $et_vect_cmdline_needed_saved" 2
    return $et_vect_cmdline_needed_saved
}

# Return 1 if the target supports hardware vectors of int, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_int { } {
    global et_vect_int_saved

    if [info exists et_vect_int_saved] {
	verbose "check_effective_target_vect_int: using cached result" 2
    } else {
	set et_vect_int_saved 0
	if { [istarget i?86-*-*]
	      || [istarget powerpc*-*-*]
	      || [istarget x86_64-*-*]
	      || [istarget sparc*-*-*]
	      || [istarget alpha*-*-*]
	      || [istarget ia64-*-*] } {
	   set et_vect_int_saved 1
	}
    }

    verbose "check_effective_target_vect_int: returning $et_vect_int_saved" 2
    return $et_vect_int_saved
}

# Return 1 is this is an arm target using 32-bit instructions
proc check_effective_target_arm32 { } {
    global et_arm32_saved
    global et_arm32_target_name
    global compiler_flags

    if { ![info exists et_arm32_target_name] } {
	set et_arm32_target_name ""
    }

    # If the target has changed since we set the cached value, clear it.
    set current_target [current_target_name]
    if { $current_target != $et_arm32_target_name } {
	verbose "check_effective_target_arm32: `$et_arm32_target_name' `$current_target'" 2
	set et_arm32_target_name $current_target
	if { [info exists et_arm32_saved] } {
	    verbose "check_effective_target_arm32: removing cached result" 2
	    unset et_arm32_saved
	}
    }

    if [info exists et_arm32_saved] {
	verbose "check-effective_target_arm32: using cached result" 2
    } else {
	set et_arm32_saved 0
	if { [istarget arm-*-*]
	      || [istarget strongarm*-*-*]
	      || [istarget xscale-*-*] } {
	    if ![string match "*-mthumb *" $compiler_flags] {
		set et_arm32_saved 1
	    }
	}
    }
    verbose "check_effective_target_arm32: returning $et_arm32_saved" 2
    return $et_arm32_saved
}

# Return 1 if this is an ARM target supporting -mfpu=vfp
# -mfloat-abi=softfp.  Some multilibs may be incompatible with these
# options.

proc check_effective_target_arm_vfp_ok { } {
    if { [check_effective_target_arm32] } {
	return [check_no_compiler_messages arm_vfp_ok object {
	    int dummy;
	} "-mfpu=vfp -mfloat-abi=softfp"]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target with floating-point registers.

proc check_effective_target_powerpc_fprs { } {
    if { [istarget powerpc*-*-*]
	 || [istarget rs6000-*-*] } {
	return [check_no_compiler_messages powerpc_fprs object {
	    #ifdef __NO_FPRS__
	    #error no FPRs
	    #else
	    int dummy;
	    #endif
	}]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target supporting -maltivec.

proc check_effective_target_powerpc_altivec_ok { } {
    if { [istarget powerpc*-*-*]
	 || [istarget rs6000-*-*] } {
	# AltiVec is not supported on Aix.
	if { [istarget powerpc*-*-aix*] } {
	    return 0
	}
	return [check_no_compiler_messages powerpc_altivec_ok object {
	    int dummy;
	} "-maltivec"]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target with SPE enabled.

proc check_effective_target_powerpc_spe { } {
    if { [istarget powerpc*-*-*] } {
	return [check_no_compiler_messages powerpc_spe object {
	    #ifndef __SPE__
	    #error not SPE
	    #else
	    int dummy;
	    #endif
	}]
    } else {
	return 0
    }
}

# Return 1 if this is a PowerPC target with Altivec enabled.

proc check_effective_target_powerpc_altivec { } {
    if { [istarget powerpc*-*-*] } {
	return [check_no_compiler_messages powerpc_altivec object {
	    #ifndef __ALTIVEC__
	    #error not Altivec
	    #else
	    int dummy;
	    #endif
	}]
    } else {
	return 0
    }
}

# Return 1 if the target supports hardware vector shift operation.

proc check_effective_target_vect_shift { } {
    global et_vect_shift_saved

    if [info exists et_vect_shift_saved] {
	verbose "check_effective_target_vect_shift: using cached result" 2
    } else {
	set et_vect_shift_saved 0
	if { [istarget powerpc*-*-*]
	     || [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*] } {
	   set et_vect_shift_saved 1
	}
    }

    verbose "check_effective_target_vect_shift: returning $et_vect_shift_saved" 2
    return $et_vect_shift_saved
}

# Return 1 if the target supports hardware vectors of long, 0 otherwise.
#
# This can change for different subtargets so do not cache the result.

proc check_effective_target_vect_long { } {
    if { [istarget i?86-*-*]
	 || ([istarget powerpc*-*-*] && [check_effective_target_ilp32])
	 || [istarget x86_64-*-*]
	 || ([istarget sparc*-*-*] && [check_effective_target_ilp32]) } {
	set answer 1
    } else {
	set answer 0
    }

    verbose "check_effective_target_vect_long: returning $answer" 2
    return $answer
}

# Return 1 if the target supports hardware vectors of float, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_float { } {
    global et_vect_float_saved

    if [info exists et_vect_float_saved] {
	verbose "check_effective_target_vect_float: using cached result" 2
    } else {
	set et_vect_float_saved 0
	if { [istarget i?86-*-*]
	      || [istarget powerpc*-*-*]
	      || [istarget mipsisa64*-*-*]
	      || [istarget x86_64-*-*]
	      || [istarget ia64-*-*] } {
	   set et_vect_float_saved 1
	}
    }

    verbose "check_effective_target_vect_float: returning $et_vect_float_saved" 2
    return $et_vect_float_saved
}

# Return 1 if the target supports hardware vectors of double, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_double { } {
    global et_vect_double_saved

    if [info exists et_vect_double_saved] {
	verbose "check_effective_target_vect_double: using cached result" 2
    } else {
	set et_vect_double_saved 0
	if { [istarget i?86-*-*]
	      || [istarget x86_64-*-*] } {
	   set et_vect_double_saved 1
	}
    }

    verbose "check_effective_target_vect_double: returning $et_vect_double_saved" 2
    return $et_vect_double_saved
}

# Return 1 if the target plus current options does not support a vector
# max instruction on "int", 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_no_int_max { } {
    global et_vect_no_int_max_saved

    if [info exists et_vect_no_int_max_saved] {
	verbose "check_effective_target_vect_no_int_max: using cached result" 2
    } else {
	set et_vect_no_int_max_saved 0
	if { [istarget sparc*-*-*]
	     || [istarget alpha*-*-*] } {
	    set et_vect_no_int_max_saved 1
	}
    }
    verbose "check_effective_target_vect_no_int_max: returning $et_vect_no_int_max_saved" 2
    return $et_vect_no_int_max_saved
}

# Return 1 if the target plus current options does not support a vector
# add instruction on "int", 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_no_int_add { } {
    global et_vect_no_int_add_saved

    if [info exists et_vect_no_int_add_saved] {
	verbose "check_effective_target_vect_no_int_add: using cached result" 2
    } else {
	set et_vect_no_int_add_saved 0
	# Alpha only supports vector add on V8QI and V4HI.
	if { [istarget alpha*-*-*] } {
	    set et_vect_no_int_add_saved 1
	}
    }
    verbose "check_effective_target_vect_no_int_add: returning $et_vect_no_int_add_saved" 2
    return $et_vect_no_int_add_saved
}

# Return 1 if the target plus current options does not support vector
# bitwise instructions, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_no_bitwise { } {
    global et_vect_no_bitwise_saved

    if [info exists et_vect_no_bitwise_saved] {
	verbose "check_effective_target_vect_no_bitwise: using cached result" 2
    } else {
	set et_vect_no_bitwise_saved 0
    }
    verbose "check_effective_target_vect_no_bitwise: returning $et_vect_no_bitwise_saved" 2
    return $et_vect_no_bitwise_saved
}

# Return 1 if the target plus current options supports a vector
# widening summation of *short* args into *int* result, 0 otherwise.
#
# This won't change for different subtargets so cache the result.
                                                                                                
proc check_effective_target_vect_widen_sum_hi_to_si { } {
    global et_vect_widen_sum_hi_to_si
                                                                                                
    if [info exists et_vect_widen_sum_hi_to_si_saved] {
        verbose "check_effective_target_vect_widen_sum_hi_to_si: using cached result" 2
    } else {
        set et_vect_widen_sum_hi_to_si_saved 0
        if { [istarget powerpc*-*-*]
	     || [istarget ia64-*-*] } {
            set et_vect_widen_sum_hi_to_si_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_sum_hi_to_si: returning $et_vect_widen_sum_hi_to_si_saved" 2
    return $et_vect_widen_sum_hi_to_si_saved
}

# Return 1 if the target plus current options supports a vector
# widening summation of *char* args into *short* result, 0 otherwise.
#
# This won't change for different subtargets so cache the result.
                                                                                                
proc check_effective_target_vect_widen_sum_qi_to_hi { } {
    global et_vect_widen_sum_qi_to_hi
                                                                                                
    if [info exists et_vect_widen_sum_qi_to_hi_saved] {
        verbose "check_effective_target_vect_widen_sum_qi_to_hi: using cached result" 2
    } else {
        set et_vect_widen_sum_qi_to_hi_saved 0
        if { [istarget ia64-*-*] } {
            set et_vect_widen_sum_qi_to_hi_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_sum_qi_to_hi: returning $et_vect_widen_sum_qi_to_hi_saved" 2
    return $et_vect_widen_sum_qi_to_hi_saved
}

# Return 1 if the target plus current options supports a vector
# widening summation of *char* args into *int* result, 0 otherwise.
#
# This won't change for different subtargets so cache the result.
                                                                                                
proc check_effective_target_vect_widen_sum_qi_to_si { } {
    global et_vect_widen_sum_qi_to_si
                                                                                                
    if [info exists et_vect_widen_sum_qi_to_si_saved] {
        verbose "check_effective_target_vect_widen_sum_qi_to_si: using cached result" 2
    } else {
        set et_vect_widen_sum_qi_to_si_saved 0
        if { [istarget powerpc*-*-*] } {
            set et_vect_widen_sum_qi_to_si_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_sum_qi_to_si: returning $et_vect_widen_sum_qi_to_si_saved" 2
    return $et_vect_widen_sum_qi_to_si_saved
}

# Return 1 if the target plus current options supports a vector
# widening summation, 0 otherwise.
#
# This won't change for different subtargets so cache the result.
                                                                                                
proc check_effective_target_vect_widen_sum { } {
    global et_vect_widen_sum
                                                                                                
    if [info exists et_vect_widen_sum_saved] {
        verbose "check_effective_target_vect_widen_sum: using cached result" 2
    } else {
        set et_vect_widen_sum_saved 0
        if { [istarget powerpc*-*-*]
	     || [istarget ia64-*-*] } {
            set et_vect_widen_sum_saved 1
        }
    }
    verbose "check_effective_target_vect_widen_sum: returning $et_vect_widen_sum_saved" 2
    return $et_vect_widen_sum_saved
}

# Return 1 if the target plus current options supports a vector
# dot-product of signed chars, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_sdot_qi { } {
    global et_vect_sdot_qi

    if [info exists et_vect_sdot_qi_saved] {
        verbose "check_effective_target_vect_sdot_qi: using cached result" 2
    } else {
        set et_vect_sdot_qi_saved 0
        if { [istarget ia64-*-*] } {
            set et_vect_sdot_qi_saved 1
        }
    }
    verbose "check_effective_target_vect_sdot_qi: returning $et_vect_sdot_qi_saved" 2
    return $et_vect_sdot_qi_saved
}

# Return 1 if the target plus current options supports a vector
# dot-product of unsigned chars, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_udot_qi { } {
    global et_vect_udot_qi

    if [info exists et_vect_udot_qi_saved] {
        verbose "check_effective_target_vect_udot_qi: using cached result" 2
    } else {
        set et_vect_udot_qi_saved 0
        if { [istarget powerpc*-*-*]
             || [istarget ia64-*-*] } {
            set et_vect_udot_qi_saved 1
        }
    }
    verbose "check_effective_target_vect_udot_qi: returning $et_vect_udot_qi_saved" 2
    return $et_vect_udot_qi_saved
}

# Return 1 if the target plus current options supports a vector
# dot-product of signed shorts, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_sdot_hi { } {
    global et_vect_sdot_hi

    if [info exists et_vect_sdot_hi_saved] {
        verbose "check_effective_target_vect_sdot_hi: using cached result" 2
    } else {
        set et_vect_sdot_hi_saved 0
        if { [istarget powerpc*-*-*] 
	     || [istarget i?86-*-*]
             || [istarget x86_64-*-*]
             || [istarget ia64-*-*] } {
            set et_vect_sdot_hi_saved 1
        }
    }
    verbose "check_effective_target_vect_sdot_hi: returning $et_vect_sdot_hi_saved" 2
    return $et_vect_sdot_hi_saved
}

# Return 1 if the target plus current options supports a vector
# dot-product of unsigned shorts, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_udot_hi { } {
    global et_vect_udot_hi

    if [info exists et_vect_udot_hi_saved] {
        verbose "check_effective_target_vect_udot_hi: using cached result" 2
    } else {
        set et_vect_udot_hi_saved 0
        if { [istarget powerpc*-*-*] } {
            set et_vect_udot_hi_saved 1
        }
    }
    verbose "check_effective_target_vect_udot_hi: returning $et_vect_udot_hi_saved" 2
    return $et_vect_udot_hi_saved
}


# Return 1 if the target plus current options does not support a vector
# alignment mechanism, 0 otherwise.
#
# This won't change for different subtargets so cache the result.

proc check_effective_target_vect_no_align { } {
    global et_vect_no_align_saved

    if [info exists et_vect_no_align_saved] {
	verbose "check_effective_target_vect_no_align: using cached result" 2
    } else {
	set et_vect_no_align_saved 0
	if { [istarget mipsisa64*-*-*]
	     || [istarget sparc*-*-*]
	     || [istarget ia64-*-*] } {
	    set et_vect_no_align_saved 1
	}
    }
    verbose "check_effective_target_vect_no_align: returning $et_vect_no_align_saved" 2
    return $et_vect_no_align_saved
}

# Return 1 if the target supports vector conditional operations, 0 otherwise.

proc check_effective_target_vect_condition { } {
    global et_vect_cond_saved

    if [info exists et_vect_cond_saved] {
	verbose "check_effective_target_vect_cond: using cached result" 2
    } else {
	set et_vect_cond_saved 0
	if { [istarget powerpc*-*-*]
	     || [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*] } {
	   set et_vect_cond_saved 1
	}
    }

    verbose "check_effective_target_vect_cond: returning $et_vect_cond_saved" 2
    return $et_vect_cond_saved
}

# Return 1 if the target supports vector char multiplication, 0 otherwise.

proc check_effective_target_vect_char_mult { } {
    global et_vect_char_mult_saved

    if [info exists et_vect_char_mult_saved] {
	verbose "check_effective_target_vect_char_mult: using cached result" 2
    } else {
	set et_vect_char_mult_saved 0
	if { [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*] } {
	   set et_vect_char_mult_saved 1
	}
    }

    verbose "check_effective_target_vect_char_mult: returning $et_vect_char_mult_saved" 2
    return $et_vect_char_mult_saved
}

# Return 1 if the target supports vector short multiplication, 0 otherwise.

proc check_effective_target_vect_short_mult { } {
    global et_vect_short_mult_saved

    if [info exists et_vect_short_mult_saved] {
	verbose "check_effective_target_vect_short_mult: using cached result" 2
    } else {
	set et_vect_short_mult_saved 0
	if { [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*] } {
	   set et_vect_short_mult_saved 1
	}
    }

    verbose "check_effective_target_vect_short_mult: returning $et_vect_short_mult_saved" 2
    return $et_vect_short_mult_saved
}

# Return 1 if the target supports vector int multiplication, 0 otherwise.

proc check_effective_target_vect_int_mult { } {
    global et_vect_int_mult_saved

    if [info exists et_vect_int_mult_saved] {
	verbose "check_effective_target_vect_int_mult: using cached result" 2
    } else {
	set et_vect_int_mult_saved 0
	if { [istarget powerpc*-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*] } {
	   set et_vect_int_mult_saved 1
	}
    }

    verbose "check_effective_target_vect_int_mult: returning $et_vect_int_mult_saved" 2
    return $et_vect_int_mult_saved
}

# Return 1 if the target supports section-anchors

proc check_effective_target_section_anchors { } {
    global et_section_anchors_saved

    if [info exists et_section_anchors_saved] {
        verbose "check_effective_target_section_anchors: using cached result" 2
    } else {
        set et_section_anchors_saved 0
        if { [istarget powerpc*-*-*] } {
           set et_section_anchors_saved 1
        }
    }

    verbose "check_effective_target_section_anchors: returning $et_section_anchors_saved" 2
    return $et_section_anchors_saved
}

# Return 1 if the target supports atomic operations on "int" and "long".

proc check_effective_target_sync_int_long { } {
    global et_sync_int_long_saved

    if [info exists et_sync_int_long_saved] {
        verbose "check_effective_target_sync_int_long: using cached result" 2
    } else {
        set et_sync_int_long_saved 0
# This is intentionally powerpc but not rs6000, rs6000 doesn't have the
# load-reserved/store-conditional instructions.
        if { [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*]
	     || [istarget alpha*-*-*] 
	     || [istarget s390*-*-*] 
	     || [istarget powerpc*-*-*]
	     || [istarget sparc64-*-*]
	     || [istarget sparcv9-*-*] } {
           set et_sync_int_long_saved 1
        }
    }

    verbose "check_effective_target_sync_int_long: returning $et_sync_int_long_saved" 2
    return $et_sync_int_long_saved
}

# Return 1 if the target supports atomic operations on "char" and "short".

proc check_effective_target_sync_char_short { } {
    global et_sync_char_short_saved

    if [info exists et_sync_char_short_saved] {
        verbose "check_effective_target_sync_char_short: using cached result" 2
    } else {
        set et_sync_char_short_saved 0
# This is intentionally powerpc but not rs6000, rs6000 doesn't have the
# load-reserved/store-conditional instructions.
        if { [istarget ia64-*-*]
	     || [istarget i?86-*-*]
	     || [istarget x86_64-*-*]
	     || [istarget alpha*-*-*] 
	     || [istarget s390*-*-*] 
	     || [istarget powerpc*-*-*]
	     || [istarget sparc64-*-*]
	     || [istarget sparcv9-*-*] } {
           set et_sync_char_short_saved 1
        }
    }

    verbose "check_effective_target_sync_char_short: returning $et_sync_char_short_saved" 2
    return $et_sync_char_short_saved
}

# Return 1 if the target matches the effective target 'arg', 0 otherwise.
# This can be used with any check_* proc that takes no argument and
# returns only 1 or 0.  It could be used with check_* procs that take
# arguments with keywords that pass particular arguments.

proc is-effective-target { arg } {
    set selected 0
    if { [info procs check_effective_target_${arg}] != [list] } {
	set selected [check_effective_target_${arg}]
    } else {
	switch $arg {
	  "vmx_hw"         { set selected [check_vmx_hw_available] }
	  "named_sections" { set selected [check_named_sections_available] }
	  "gc_sections"    { set selected [check_gc_sections_available] }
	  "cxa_atexit"     { set selected [check_cxa_atexit_available] }
	  default          { error "unknown effective target keyword `$arg'" }
	}
    }
    verbose "is-effective-target: $arg $selected" 2
    return $selected
}

# Return 1 if the argument is an effective-target keyword, 0 otherwise.

proc is-effective-target-keyword { arg } {
    if { [info procs check_effective_target_${arg}] != [list] } {
	return 1
    } else {
	# These have different names for their check_* procs.
	switch $arg {
	  "vmx_hw"         { return 1 }
	  "named_sections" { return 1 }
	  "gc_sections"    { return 1 }
	  "cxa_atexit"     { return 1 }
	  default          { return 0 }
	}
    }
}

# Return 1 if target default to short enums

proc check_effective_target_short_enums { } {
    return [check_no_compiler_messages short_enums assembly {
	enum foo { bar };
	int s[sizeof (enum foo) == 1 ? 1 : -1];
    }]
}

# Return 1 if target supports merging string constants at link time.

proc check_effective_target_string_merging { } {
    return [check_no_messages_and_pattern string_merging \
		"rodata\\.str" assembly {
		    const char *var = "String";
		} {-O2}]
}

# Return 1 if programs are intended to be run on a simulator
# (i.e. slowly) rather than hardware (i.e. fast).

proc check_effective_target_simulator { } {

    # All "src/sim" simulators set this one.
    if [board_info target exists is_simulator] {
	return [board_info target is_simulator]
    }

    # The "sid" simulators don't set that one, but at least they set
    # this one.
    if [board_info target exists slow_simulator] {
	return [board_info target slow_simulator]
    }

    return 0
}
