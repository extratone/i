This is doc/gfortran.info, produced by makeinfo version 4.8 from
/scratch/mitchell/gcc-releases/gcc-4.2.1/gcc-4.2.1/gcc/fortran/gfortran.texi.

   Copyright (C) 1999-2007 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License" and "Funding Free
Software", the Front-Cover texts being (a) (see below), and with the
Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled "GNU Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* gfortran: (gfortran).                  The GNU Fortran Compiler.
END-INFO-DIR-ENTRY
   This file documents the use and the internals of the GNU Fortran
compiler, (`gfortran').

   Published by the Free Software Foundation 51 Franklin Street, Fifth
Floor Boston, MA 02110-1301 USA

   Copyright (C) 1999-2007 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License" and "Funding Free
Software", the Front-Cover texts being (a) (see below), and with the
Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled "GNU Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.


File: gfortran.info,  Node: Top,  Next: Introduction,  Up: (dir)

Introduction
************

This manual documents the use of `gfortran', the GNU Fortran compiler.
You can find in this manual how to invoke `gfortran', as well as its
features and incompatibilities.

* Menu:

* Introduction::

Part I: Invoking GNU Fortran
* Invoking GNU Fortran:: Command options supported by `gfortran'.
* Runtime::              Influencing runtime behavior with environment variables.

Part II: Language Reference
* Fortran 2003 status::  Fortran 2003 features supported by GNU Fortran.
* Extensions::           Language extensions implemented by GNU Fortran.
* Intrinsic Procedures:: Intrinsic procedures supported by GNU Fortran.

* Contributing::         How you can help.
* Copying::              GNU General Public License says
                         how you can copy and share GNU Fortran.
* GNU Free Documentation License::
		         How you can copy and share this manual.
* Funding::              How to help assure continued work for free software.
* Option Index::         Index of command line options
* Keyword Index::        Index of concepts


File: gfortran.info,  Node: Introduction,  Next: Invoking GNU Fortran,  Prev: Top,  Up: Top

1 Introduction
**************

The GNU Fortran compiler front end was designed initially as a free
replacement for, or alternative to, the unix `f95' command; `gfortran'
is the command you'll use to invoke the compiler.

* Menu:

* About GNU Fortran::    What you should know about the GNU Fortran compiler.
* GNU Fortran and GCC::  You can compile Fortran, C, or other programs.
* GNU Fortran and G77::  Why we chose to start from scratch.
* Project Status::       Status of GNU Fortran, roadmap, proposed extensions.
* Standards::	         Standards supported by GNU Fortran.


File: gfortran.info,  Node: About GNU Fortran,  Next: GNU Fortran and GCC,  Up: Introduction

1.1 About GNU Fortran
=====================

The GNU Fortran compiler is still in an early state of development.  It
can generate code for most constructs and expressions, but much work
remains to be done.

   When the GNU Fortran compiler is finished, it will do everything you
expect from any decent compiler:

   * Read a user's program, stored in a file and containing
     instructions written in Fortran 77, Fortran 90, Fortran 95 or
     Fortran 2003.  This file contains "source code".

   * Translate the user's program into instructions a computer can
     carry out more quickly than it takes to translate the instructions
     in the first place.  The result after compilation of a program is
     "machine code", code designed to be efficiently translated and
     processed by a machine such as your computer.  Humans usually
     aren't as good writing machine code as they are at writing Fortran
     (or C++, Ada, or Java), because is easy to make tiny mistakes
     writing machine code.

   * Provide the user with information about the reasons why the
     compiler is unable to create a binary from the source code.
     Usually this will be the case if the source code is flawed.  When
     writing Fortran, it is easy to make big mistakes.  The Fortran 90
     requires that the compiler can point out mistakes to the user.  An
     incorrect usage of the language causes an "error message".

     The compiler will also attempt to diagnose cases where the user's
     program contains a correct usage of the language, but instructs
     the computer to do something questionable.  This kind of
     diagnostics message is called a "warning message".

   * Provide optional information about the translation passes from the
     source code to machine code.  This can help a user of the compiler
     to find the cause of certain bugs which may not be obvious in the
     source code, but may be more easily found at a lower level
     compiler output.  It also helps developers to find bugs in the
     compiler itself.

   * Provide information in the generated machine code that can make it
     easier to find bugs in the program (using a debugging tool, called
     a "debugger", such as the GNU Debugger `gdb').

   * Locate and gather machine code already generated to perform
     actions requested by statements in the user's program.  This
     machine code is organized into "modules" and is located and
     "linked" to the user program.

   The GNU Fortran compiler consists of several components:

   * A version of the `gcc' command (which also might be installed as
     the system's `cc' command) that also understands and accepts
     Fortran source code.  The `gcc' command is the "driver" program for
     all the languages in the GNU Compiler Collection (GCC); With `gcc',
     you can compile the source code of any language for which a front
     end is available in GCC.

   * The `gfortran' command itself, which also might be installed as the
     system's `f95' command.  `gfortran' is just another driver program,
     but specifically for the Fortran compiler only.  The difference
     with `gcc' is that `gfortran' will automatically link the correct
     libraries to your program.

   * A collection of run-time libraries.  These libraries contain the
     machine code needed to support capabilities of the Fortran
     language that are not directly provided by the machine code
     generated by the `gfortran' compilation phase, such as intrinsic
     functions and subroutines, and routines for interaction with files
     and the operating system.

   * The Fortran compiler itself, (`f951').  This is the GNU Fortran
     parser and code generator, linked to and interfaced with the GCC
     backend library.  `f951' "translates" the source code to assembler
     code.  You would typically not use this program directly; instead,
     the `gcc' or `gfortran' driver programs will call it for you.


File: gfortran.info,  Node: GNU Fortran and GCC,  Next: GNU Fortran and G77,  Prev: About GNU Fortran,  Up: Introduction

1.2 GNU Fortran and GCC
=======================

GNU Fortran is a part of GCC, the "GNU Compiler Collection".  GCC
consists of a collection of front ends for various languages, which
translate the source code into a language-independent form called
"GENERIC".  This is then processed by a common middle end which
provides optimization, and then passed to one of a collection of back
ends which generate code for different computer architectures and
operating systems.

   Functionally, this is implemented with a driver program (`gcc')
which provides the command-line interface for the compiler.  It calls
the relevant compiler front-end program (e.g., `f951' for Fortran) for
each file in the source code, and then calls the assembler and linker
as appropriate to produce the compiled output. In a copy of GCC which
has been compiled with Fortran language support enabled, `gcc' will
recognize files with `.f', `.f90', `.f95', and `.f03' extensions as
Fortran source code, and compile it accordingly.  A `gfortran' driver
program is also provided, which is identical to `gcc' except that it
automatically links the Fortran runtime libraries into the compiled
program.

   This manual specifically documents the Fortran front end, which
handles the programming language's syntax and semantics.  The aspects
of GCC which relate to the optimization passes and the back-end code
generation are documented in the GCC manual; see *Note Introduction:
(gcc)Top.  The two manuals together provide a complete reference for
the GNU Fortran compiler.


File: gfortran.info,  Node: GNU Fortran and G77,  Next: Project Status,  Prev: GNU Fortran and GCC,  Up: Introduction

1.3 GNU Fortran and G77
=======================

The GNU Fortran compiler is the successor to `g77', the Fortran 77
front end included in GCC prior to version 4.  It is an entirely new
program that has been designed to provide Fortran 95 support and
extensibility for future Fortran language standards, as well as
providing backwards compatibility for Fortran 77 and nearly all of the
GNU language extensions supported by `g77'.


File: gfortran.info,  Node: Project Status,  Next: Standards,  Prev: GNU Fortran and G77,  Up: Introduction

1.4 Project Status
==================

     As soon as `gfortran' can parse all of the statements correctly,
     it will be in the "larva" state.  When we generate code, the
     "puppa" state.  When `gfortran' is done, we'll see if it will be a
     beautiful butterfly, or just a big bug....

     -Andy Vaught, April 2000

   The start of the GNU Fortran 95 project was announced on the GCC
homepage in March 18, 2000 (even though Andy had already been working
on it for a while, of course).

   The GNU Fortran compiler is able to compile nearly all
standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,
including a number of standard and non-standard extensions, and can be
used on real-world programs.  In particular, the supported extensions
include OpenMP, Cray-style pointers, and several Fortran 2003 features
such as enumeration, stream I/O, and some of the enhancements to
allocatable array support from TR 15581.  However, it is still under
development and has a few remaining rough edges.

   At present, the GNU Fortran compiler passes the NIST Fortran 77 Test
Suite (http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html), and
produces acceptable results on the LAPACK Test Suite
(http://www.netlib.org/lapack/faq.html#1.21).  It also provides
respectable performance on the Polyhedron Fortran compiler benchmarks
(http://www.polyhedron.com/pb05.html) and the Livermore Fortran Kernels
test
(http://www.llnl.gov/asci_benchmarks/asci/limited/lfk/README.html).  It
has been used to compile a number of large real-world programs,
including the HIRLAM weather-forecasting code
(http://mysite.verizon.net/serveall/moene.pdf) and the Tonto quantum
chemistry package (http://www.theochem.uwa.edu.au/tonto/); see
`http://gcc.gnu.org/wiki/GfortranApps' for an extended list.

   Among other things, the GNU Fortran compiler is intended as a
replacement for G77.  At this point, nearly all programs that could be
compiled with G77 can be compiled with GNU Fortran, although there are
a few minor known regressions.

   The primary work remaining to be done on GNU Fortran falls into three
categories: bug fixing (primarily regarding the treatment of invalid
code and providing useful error messages), improving the compiler
optimizations and the performance of compiled code, and extending the
compiler to support future standards--in particular, Fortran 2003.


File: gfortran.info,  Node: Standards,  Prev: Project Status,  Up: Introduction

1.5 Standards
=============

The GNU Fortran compiler implements ISO/IEC 1539:1997 (Fortran 95).  As
such, it can also compile essentially all standard-compliant Fortran 90
and Fortran 77 programs.   It also supports the ISO/IEC TR-15581
enhancements to allocatable arrays, and the OpenMP Application Program
Interface v2.5 (http://www.openmp.org/drupal/mp-documents/spec25.pdf)
specification.

   In the future, the GNU Fortran compiler may also support other
standard variants of and extensions to the Fortran language.  These
include ISO/IEC 1539-1:2004 (Fortran 2003).


File: gfortran.info,  Node: Invoking GNU Fortran,  Next: Runtime,  Prev: Introduction,  Up: Top

2 GNU Fortran Command Options
*****************************

The `gfortran' command supports all the options supported by the `gcc'
command.  Only options specific to GNU Fortran are documented here.

   *Note GCC Command Options: (gcc)Invoking GCC, for information on the
non-Fortran-specific aspects of the `gcc' command (and, therefore, the
`gfortran' command).

   All GCC and GNU Fortran options are accepted both by `gfortran' and
by `gcc' (as well as any other drivers built at the same time, such as
`g++'), since adding GNU Fortran to the GCC distribution enables
acceptance of GNU Fortran options by all of the relevant drivers.

   In some cases, options have positive and negative forms; the
negative form of `-ffoo' would be `-fno-foo'.  This manual documents
only one of these two forms, whichever one is not the default.

* Menu:

* Option Summary::      Brief list of all `gfortran' options,
                        without explanations.
* Fortran Dialect Options::  Controlling the variant of Fortran language
                             compiled.
* Error and Warning Options::     How picky should the compiler be?
* Debugging Options::   Symbol tables, measurements, and debugging dumps.
* Directory Options::   Where to find module files
* Runtime Options::     Influencing runtime behavior
* Code Gen Options::    Specifying conventions for function calls, data layout
                        and register usage.
* Environment Variables:: Env vars that affect `gfortran'.


File: gfortran.info,  Node: Option Summary,  Next: Fortran Dialect Options,  Up: Invoking GNU Fortran

2.1 Option Summary
==================

Here is a summary of all the options specific to GNU Fortran, grouped
by type.  Explanations are in the following sections.

_Fortran Language Options_
     *Note Options Controlling Fortran Dialect: Fortran Dialect Options.
          -fall-intrinsics  -ffree-form  -fno-fixed-form
          -fdollar-ok  -fimplicit-none  -fmax-identifier-length
          -std=STD -fd-lines-as-code  -fd-lines-as-comments
          -ffixed-line-length-N  -ffixed-line-length-none
          -ffree-line-length-N  -ffree-line-length-none
          -fdefault-double-8  -fdefault-integer-8  -fdefault-real-8
          -fcray-pointer  -fopenmp  -frange-check -fno-backslash

_Error and Warning Options_
     *Note Options to Request or Suppress Errors and Warnings: Error
     and Warning Options.
          -fmax-errors=N
          -fsyntax-only  -pedantic  -pedantic-errors
          -w  -Wall  -Waliasing  -Wampersand  -Wcharacter-truncation  -Wconversion
          -Wimplicit-interface  -Wline-truncation  -Wnonstd-intrinsics  -Wsurprising
          -Wno-tabs  -Wunderflow  -W

_Debugging Options_
     *Note Options for Debugging Your Program or GCC: Debugging Options.
          -fdump-parse-tree  -ffpe-trap=LIST

_Directory Options_
     *Note Options for Directory Search: Directory Options.
          -IDIR  -JDIR  -MDIR

_Runtime Options_
     *Note Options for influencing runtime behavior: Runtime Options.
          -fconvert=CONVERSION  -frecord-marker=LENGTH
          -fmax-subrecord-length=LENGTH

_Code Generation Options_
     *Note Options for Code Generation Conventions: Code Gen Options.
          -fno-automatic  -ff2c  -fno-underscoring
          -fsecond-underscore
          -fbounds-check  -fmax-stack-var-size=N
          -fpack-derived  -frepack-arrays  -fshort-enums


* Menu:

* Fortran Dialect Options::  Controlling the variant of Fortran language
                             compiled.
* Error and Warning Options::     How picky should the compiler be?
* Debugging Options::   Symbol tables, measurements, and debugging dumps.
* Directory Options::   Where to find module files
* Runtime Options::     Influencing runtime behavior
* Code Gen Options::    Specifying conventions for function calls, data layout
                        and register usage.


File: gfortran.info,  Node: Fortran Dialect Options,  Next: Error and Warning Options,  Prev: Option Summary,  Up: Invoking GNU Fortran

2.2 Options Controlling Fortran Dialect
=======================================

The following options control the details of the Fortran dialect
accepted by the compiler:

`-ffree-form'

`-ffixed-form'
     Specify the layout used by the source file.  The free form layout
     was introduced in Fortran 90.  Fixed form was traditionally used in
     older Fortran programs.  When neither option is specified, the
     source form is determined by the file extension.

`-fall-intrinsics'
     Accept all of the intrinsic procedures provided in libgfortran
     without regard to the setting of `-std'.  In particular, this
     option can be quite useful with `-std=f95'.  Additionally,
     `gfortran' will ignore `-Wnonstd-intrinsics'.

`-fd-lines-as-code'

`-fd-lines-as-comments'
     Enable special treatment for lines beginning with `d' or `D' in
     fixed form sources.  If the `-fd-lines-as-code' option is given
     they are treated as if the first column contained a blank.  If the
     `-fd-lines-as-comments' option is given, they are treated as
     comment lines.

`-fdefault-double-8'
     Set the `DOUBLE PRECISION' type to an 8 byte wide type.

`-fdefault-integer-8'
     Set the default integer and logical types to an 8 byte wide type.
     Do nothing if this is already the default.

`-fdefault-real-8'
     Set the default real type to an 8 byte wide type.  Do nothing if
     this is already the default.

`-fdollar-ok'
     Allow `$' as a valid character in a symbol name.

`-fno-backslash'
     Change the interpretation of backslashes in string literals from
     "C-style" escape characters to a single backslash character.

`-ffixed-line-length-N'
     Set column after which characters are ignored in typical fixed-form
     lines in the source file, and through which spaces are assumed (as
     if padded to that length) after the ends of short fixed-form lines.

     Popular values for N include 72 (the standard and the default), 80
     (card image), and 132 (corresponding to "extended-source" options
     in some popular compilers).  N may also be `none', meaning that
     the entire line is meaningful and that continued character
     constants never have implicit spaces appended to them to fill out
     the line.  `-ffixed-line-length-0' means the same thing as
     `-ffixed-line-length-none'.

`-ffree-line-length-N'
     Set column after which characters are ignored in typical free-form
     lines in the source file. The default value is 132.  N may be
     `none', meaning that the entire line is meaningful.
     `-ffree-line-length-0' means the same thing as
     `-ffree-line-length-none'.

`-fmax-identifier-length=N'
     Specify the maximum allowed identifier length. Typical values are
     31 (Fortran 95) and 63 (Fortran 2003).

`-fimplicit-none'
     Specify that no implicit typing is allowed, unless overridden by
     explicit `IMPLICIT' statements.  This is the equivalent of adding
     `implicit none' to the start of every procedure.

`-fcray-pointer'
     Enable the Cray pointer extension, which provides C-like pointer
     functionality.

`-fopenmp'
     Enable the OpenMP extensions.  This includes OpenMP `!$omp'
     directives in free form and `c$omp', `*$omp' and `!$omp'
     directives in fixed form, `!$' conditional compilation sentinels
     in free form and `c$', `*$' and `!$' sentinels in fixed form, and
     when linking arranges for the OpenMP runtime library to be linked
     in.

`-frange-check'
     Enable range checking on results of simplification of constant
     expressions during compilation.  For example, by default, GNU
     Fortran will give an overflow error at compile time when
     simplifying `a = EXP(1000)'. With `-fno-range-check', no error
     will be given and the variable `a' will be assigned the value
     `+Infinity'.  Similarly, `DATA i/Z'FFFFFFFF'/' will result in an
     integer overflow on most systems, but with `-fno-range-check' the
     value will "wrap around" and `i' will be initialized to -1 instead.

`-std=STD'
     Specify the standard to which the program is expected to conform,
     which may be one of `f95', `f2003', `gnu', or `legacy'.  The
     default value for STD is `gnu', which specifies a superset of the
     Fortran 95 standard that includes all of the extensions supported
     by GNU Fortran, although warnings will be given for obsolete
     extensions not recommended for use in new code.  The `legacy' value
     is equivalent but without the warnings for obsolete extensions,
     and may be useful for old non-standard programs.  The `f95' and
     `f2003' values specify strict conformance to the Fortran 95 and
     Fortran 2003 standards, respectively; errors are given for all
     extensions beyond the relevant language standard, and warnings are
     given for the Fortran 77 features that are permitted but
     obsolescent in later standards.



File: gfortran.info,  Node: Error and Warning Options,  Next: Debugging Options,  Prev: Fortran Dialect Options,  Up: Invoking GNU Fortran

2.3 Options to Request or Suppress Errors and Warnings
======================================================

Errors are diagnostic messages that report that the GNU Fortran compiler
cannot compile the relevant piece of source code.  The compiler will
continue to process the program in an attempt to report further errors
to aid in debugging, but will not produce any compiled output.

   Warnings are diagnostic messages that report constructions which are
not inherently erroneous but which are risky or suggest there is likely
to be a bug in the program.  Unless `-Werror' is specified, they do not
prevent compilation of the program.

   You can request many specific warnings with options beginning `-W',
for example `-Wimplicit' to request warnings on implicit declarations.
Each of these specific warning options also has a negative form
beginning `-Wno-' to turn off warnings; for example, `-Wno-implicit'.
This manual lists only one of the two forms, whichever is not the
default.

   These options control the amount and kinds of errors and warnings
produced by GNU Fortran:

`-fmax-errors-N'
     Limits the maximum number of error messages to N, at which point
     GNU Fortran bails out rather than attempting to continue
     processing the source code.  If N is 0, there is no limit on the
     number of error messages produced.

`-fsyntax-only'
     Check the code for syntax errors, but don't do anything beyond
     that.

`-pedantic'
     Issue warnings for uses of extensions to Fortran 95.  `-pedantic'
     also applies to C-language constructs where they occur in GNU
     Fortran source files, such as use of `\e' in a character constant
     within a directive like `#include'.

     Valid Fortran 95 programs should compile properly with or without
     this option.  However, without this option, certain GNU extensions
     and traditional Fortran features are supported as well.  With this
     option, many of them are rejected.

     Some users try to use `-pedantic' to check programs for
     conformance.  They soon find that it does not do quite what they
     want--it finds some nonstandard practices, but not all.  However,
     improvements to GNU Fortran in this area are welcome.

     This should be used in conjunction with `-std=f95' or `-std=f2003'.

`-pedantic-errors'
     Like `-pedantic', except that errors are produced rather than
     warnings.

`-w'
     Inhibit all warning messages.

`-Wall'
     Enables commonly used warning options pertaining to usage that we
     recommend avoiding and that we believe are easy to avoid.  This
     currently includes `-Waliasing', `-Wampersand', `-Wsurprising',
     `-Wnonstd-intrinsics', `-Wno-tabs', and `-Wline-truncation'.

`-Waliasing'
     Warn about possible aliasing of dummy arguments. Specifically, it
     warns if the same actual argument is associated with a dummy
     argument with `INTENT(IN)' and a dummy argument with `INTENT(OUT)'
     in a call with an explicit interface.

     The following example will trigger the warning.
            interface
              subroutine bar(a,b)
                integer, intent(in) :: a
                integer, intent(out) :: b
              end subroutine
            end interface
            integer :: a

            call bar(a,a)

`-Wampersand'
     Warn about missing ampersand in continued character constants. The
     warning is given with `-Wampersand', `-pedantic', `-std=f95', and
     `-std=f2003'. Note: With no ampersand given in a continued
     character constant, GNU Fortran assumes continuation at the first
     non-comment, non-whitespace character after the ampersand that
     initiated the continuation.

`-Wcharacter-truncation'
     Warn when a character assignment will truncate the assigned string.

`-Wconversion'
     Warn about implicit conversions between different types.

`-Wimplicit-interface'
     Warn if a procedure is called without an explicit interface.  Note
     this only checks that an explicit interface is present.  It does
     not check that the declared interfaces are consistent across
     program units.

`-Wnonstd-intrinsics'
     Warn if the user tries to use an intrinsic that does not belong to
     the standard the user has chosen via the `-std' option.

`-Wsurprising'
     Produce a warning when "suspicious" code constructs are
     encountered.  While technically legal these usually indicate that
     an error has been made.

     This currently produces a warning under the following
     circumstances:

        * An INTEGER SELECT construct has a CASE that can never be
          matched as its lower value is greater than its upper value.

        * A LOGICAL SELECT construct has three CASE statements.

`-Wtabs'
     By default, tabs are accepted as whitespace, but tabs are not
     members of the Fortran Character Set.  `-Wno-tabs' will cause a
     warning to be issued if a tab is encountered. Note, `-Wno-tabs' is
     active for `-pedantic', `-std=f95', `-std=f2003', and `-Wall'.

`-Wunderflow'
     Produce a warning when numerical constant expressions are
     encountered, which yield an UNDERFLOW during compilation.

`-Werror'
     Turns all warnings into errors.

`-W'
     Turns on "extra warnings" and, if optimization is specified via
     `-O', the `-Wuninitialized' option.  (This might change in future
     versions of GNU Fortran.)

   *Note Options to Request or Suppress Errors and Warnings: (gcc)Error
and Warning Options, for information on more options offered by the GBE
shared by `gfortran', `gcc' and other GNU compilers.

   Some of these have no effect when compiling programs written in
Fortran.


File: gfortran.info,  Node: Debugging Options,  Next: Directory Options,  Prev: Error and Warning Options,  Up: Invoking GNU Fortran

2.4 Options for Debugging Your Program or GNU Fortran
=====================================================

GNU Fortran has various special options that are used for debugging
either your program or the GNU Fortran compiler.

`-fdump-parse-tree'
     Output the internal parse tree before starting code generation.
     Only really useful for debugging the GNU Fortran compiler itself.

`-ffpe-trap=LIST'
     Specify a list of IEEE exceptions when a Floating Point Exception
     (FPE) should be raised.  On most systems, this will result in a
     SIGFPE signal being sent and the program being interrupted,
     producing a core file useful for debugging.  LIST is a (possibly
     empty) comma-separated list of the following IEEE exceptions:
     `invalid' (invalid floating point operation, such as
     `SQRT(-1.0)'), `zero' (division by zero), `overflow' (overflow in
     a floating point operation), `underflow' (underflow in a floating
     point operation), `precision' (loss of precision during operation)
     and `denormal' (operation produced a denormal value).

   *Note Options for Debugging Your Program or GCC: (gcc)Debugging
Options, for more information on debugging options.


File: gfortran.info,  Node: Directory Options,  Next: Runtime Options,  Prev: Debugging Options,  Up: Invoking GNU Fortran

2.5 Options for Directory Search
================================

These options affect how GNU Fortran searches for files specified by
the `INCLUDE' directive and where it searches for previously compiled
modules.

   It also affects the search paths used by `cpp' when used to
preprocess Fortran source.

`-IDIR'
     These affect interpretation of the `INCLUDE' directive (as well as
     of the `#include' directive of the `cpp' preprocessor).

     Also note that the general behavior of `-I' and `INCLUDE' is
     pretty much the same as of `-I' with `#include' in the `cpp'
     preprocessor, with regard to looking for `header.gcc' files and
     other such things.

     This path is also used to search for `.mod' files when previously
     compiled modules are required by a `USE' statement.

     *Note Options for Directory Search: (gcc)Directory Options, for
     information on the `-I' option.

`-MDIR'

`-JDIR'
     This option specifies where to put `.mod' files for compiled
     modules.  It is also added to the list of directories to searched
     by an `USE' statement.

     The default is the current directory.

     `-J' is an alias for `-M' to avoid conflicts with existing GCC
     options.


File: gfortran.info,  Node: Runtime Options,  Next: Code Gen Options,  Prev: Directory Options,  Up: Invoking GNU Fortran

2.6 Influencing runtime behavior
================================

These options affect the runtime behavior of programs compiled with GNU
Fortran.
`-fconvert=CONVERSION'
     Specify the representation of data for unformatted files.  Valid
     values for conversion are: `native', the default; `swap', swap
     between big- and little-endian; `big-endian', use big-endian
     representation for unformatted files; `little-endian', use
     little-endian representation for unformatted files.

     _This option has an effect only when used in the main program.
     The `CONVERT' specifier and the GFORTRAN_CONVERT_UNIT environment
     variable override the default specified by `-fconvert'._

`-frecord-marker=LENGTH'
     Specify the length of record markers for unformatted files.  Valid
     values for LENGTH are 4 and 8.  Default is 4.  _This is different
     from previous versions of gfortran_, which specified a default
     record marker length of 8 on most systems.  If you want to read or
     write files compatible with earlier versions of gfortran, use
     `-frecord-marker=8'.

`-fmax-subrecord-length=LENGTH'
     Specify the maximum length for a subrecord.  The maximum permitted
     value for length is 2147483639, which is also the default.  Only
     really useful for use by the gfortran testsuite.


File: gfortran.info,  Node: Code Gen Options,  Next: Environment Variables,  Prev: Runtime Options,  Up: Invoking GNU Fortran

2.7 Options for Code Generation Conventions
===========================================

These machine-independent options control the interface conventions
used in code generation.

   Most of them have both positive and negative forms; the negative form
of `-ffoo' would be `-fno-foo'.  In the table below, only one of the
forms is listed--the one which is not the default.  You can figure out
the other form by either removing `no-' or adding it.

`-fno-automatic'
     Treat each program unit as if the `SAVE' statement was specified
     for every local variable and array referenced in it. Does not
     affect common blocks. (Some Fortran compilers provide this option
     under the name `-static'.)

`-ff2c'
     Generate code designed to be compatible with code generated by
     `g77' and `f2c'.

     The calling conventions used by `g77' (originally implemented in
     `f2c') require functions that return type default `REAL' to
     actually return the C type `double', and functions that return
     type `COMPLEX' to return the values via an extra argument in the
     calling sequence that points to where to store the return value.
     Under the default GNU calling conventions, such functions simply
     return their results as they would in GNU C--default `REAL'
     functions return the C type `float', and `COMPLEX' functions
     return the GNU C type `complex'.  Additionally, this option
     implies the `-fsecond-underscore' option, unless
     `-fno-second-underscore' is explicitly requested.

     This does not affect the generation of code that interfaces with
     the `libgfortran' library.

     _Caution:_ It is not a good idea to mix Fortran code compiled with
     `-ff2c' with code compiled with the default `-fno-f2c' calling
     conventions as, calling `COMPLEX' or default `REAL' functions
     between program parts which were compiled with different calling
     conventions will break at execution time.

     _Caution:_ This will break code which passes intrinsic functions
     of type default `REAL' or `COMPLEX' as actual arguments, as the
     library implementations use the `-fno-f2c' calling conventions.

`-fno-underscoring'
     Do not transform names of entities specified in the Fortran source
     file by appending underscores to them.

     With `-funderscoring' in effect, GNU Fortran appends one
     underscore to external names with no underscores.  This is done to
     ensure compatibility with code produced by many UNIX Fortran
     compilers.

     _Caution_: The default behavior of GNU Fortran is incompatible
     with `f2c' and `g77', please use the `-ff2c' option if you want
     object files compiled with GNU Fortran to be compatible with
     object code created with these tools.

     Use of `-fno-underscoring' is not recommended unless you are
     experimenting with issues such as integration of GNU Fortran into
     existing system environments (vis-a-vis existing libraries, tools,
     and so on).

     For example, with `-funderscoring', and assuming other defaults
     like `-fcase-lower' and that `j()' and `max_count()' are external
     functions while `my_var' and `lvar' are local variables, a
     statement like
          I = J() + MAX_COUNT (MY_VAR, LVAR)
     is implemented as something akin to:
          i = j_() + max_count__(&my_var__, &lvar);

     With `-fno-underscoring', the same statement is implemented as:

          i = j() + max_count(&my_var, &lvar);

     Use of `-fno-underscoring' allows direct specification of
     user-defined names while debugging and when interfacing GNU Fortran
     code with other languages.

     Note that just because the names match does _not_ mean that the
     interface implemented by GNU Fortran for an external name matches
     the interface implemented by some other language for that same
     name.  That is, getting code produced by GNU Fortran to link to
     code produced by some other compiler using this or any other
     method can be only a small part of the overall solution--getting
     the code generated by both compilers to agree on issues other than
     naming can require significant effort, and, unlike naming
     disagreements, linkers normally cannot detect disagreements in
     these other areas.

     Also, note that with `-fno-underscoring', the lack of appended
     underscores introduces the very real possibility that a
     user-defined external name will conflict with a name in a system
     library, which could make finding unresolved-reference bugs quite
     difficult in some cases--they might occur at program run time, and
     show up only as buggy behavior at run time.

     In future versions of GNU Fortran we hope to improve naming and
     linking issues so that debugging always involves using the names
     as they appear in the source, even if the names as seen by the
     linker are mangled to prevent accidental linking between
     procedures with incompatible interfaces.

`-fsecond-underscore'
     By default, GNU Fortran appends an underscore to external names.
     If this option is used GNU Fortran appends two underscores to
     names with underscores and one underscore to external names with
     no underscores.  GNU Fortran also appends two underscores to
     internal names with underscores to avoid naming collisions with
     external names.

     This option has no effect if `-fno-underscoring' is in effect.  It
     is implied by the `-ff2c' option.

     Otherwise, with this option, an external name such as `MAX_COUNT'
     is implemented as a reference to the link-time external symbol
     `max_count__', instead of `max_count_'.  This is required for
     compatibility with `g77' and `f2c', and is implied by use of the
     `-ff2c' option.

`-fbounds-check'
     Enable generation of run-time checks for array subscripts and
     against the declared minimum and maximum values.  It also checks
     array indices for assumed and deferred shape arrays against the
     actual allocated bounds.

     In the future this may also include other forms of checking, e.g.,
     checking substring references.

`-fmax-stack-var-size=N'
     This option specifies the size in bytes of the largest array that
     will be put on the stack.

     This option currently only affects local arrays declared with
     constant bounds, and may not apply to all character variables.
     Future versions of GNU Fortran may improve this behavior.

     The default value for N is 32768.

`-fpack-derived'
     This option tells GNU Fortran to pack derived type members as
     closely as possible.  Code compiled with this option is likely to
     be incompatible with code compiled without this option, and may
     execute slower.

`-frepack-arrays'
     In some circumstances GNU Fortran may pass assumed shape array
     sections via a descriptor describing a noncontiguous area of
     memory.  This option adds code to the function prologue to repack
     the data into a contiguous block at runtime.

     This should result in faster accesses to the array.  However it
     can introduce significant overhead to the function call,
     especially  when the passed data is noncontiguous.

`-fshort-enums'
     This option is provided for interoperability with C code that was
     compiled with the `-fshort-enums' option.  It will make GNU
     Fortran choose the smallest `INTEGER' kind a given enumerator set
     will fit in, and give all its enumerators this kind.


   *Note Options for Code Generation Conventions: (gcc)Code Gen
Options, for information on more options offered by the GBE shared by
`gfortran', `gcc', and other GNU compilers.


File: gfortran.info,  Node: Environment Variables,  Prev: Code Gen Options,  Up: Invoking GNU Fortran

2.8 Environment Variables Affecting `gfortran'
==============================================

The `gfortran' compiler currently does not make use of any environment
variables to control its operation above and beyond those that affect
the operation of `gcc'.

   *Note Environment Variables Affecting GCC: (gcc)Environment
Variables, for information on environment variables.

   *Note Runtime::, for environment variables that affect the run-time
behavior of programs compiled with GNU Fortran.


File: gfortran.info,  Node: Runtime,  Next: Fortran 2003 status,  Prev: Invoking GNU Fortran,  Up: Top

3 Runtime:  Influencing runtime behavior with environment variables
*******************************************************************

The behavior of the `gfortran' can be influenced by environment
variables.

   Malformed environment variables are silently ignored.

* Menu:

* GFORTRAN_STDIN_UNIT:: Unit number for standard input
* GFORTRAN_STDOUT_UNIT:: Unit number for standard output
* GFORTRAN_STDERR_UNIT:: Unit number for standard error
* GFORTRAN_USE_STDERR:: Send library output to standard error
* GFORTRAN_TMPDIR:: Directory for scratch files
* GFORTRAN_UNBUFFERED_ALL:: Don't buffer output
* GFORTRAN_SHOW_LOCUS::  Show location for runtime errors
* GFORTRAN_OPTIONAL_PLUS:: Print leading + where permitted
* GFORTRAN_DEFAULT_RECL:: Default record length for new files
* GFORTRAN_LIST_SEPARATOR::  Separator for list output
* GFORTRAN_CONVERT_UNIT::  Set endianness for unformatted I/O


File: gfortran.info,  Node: GFORTRAN_STDIN_UNIT,  Next: GFORTRAN_STDOUT_UNIT,  Up: Runtime

3.1 `GFORTRAN_STDIN_UNIT'--Unit number for standard input
=========================================================

This environment variable can be used to select the unit number
preconnected to standard input.  This must be a positive integer.  The
default value is 5.


File: gfortran.info,  Node: GFORTRAN_STDOUT_UNIT,  Next: GFORTRAN_STDERR_UNIT,  Prev: GFORTRAN_STDIN_UNIT,  Up: Runtime

3.2 `GFORTRAN_STDOUT_UNIT'--Unit number for standard output
===========================================================

This environment variable can be used to select the unit number
preconnected to standard output.  This must be a positive integer.  The
default value is 6.


File: gfortran.info,  Node: GFORTRAN_STDERR_UNIT,  Next: GFORTRAN_USE_STDERR,  Prev: GFORTRAN_STDOUT_UNIT,  Up: Runtime

3.3 `GFORTRAN_STDERR_UNIT'--Unit number for standard error
==========================================================

This environment variable can be used to select the unit number
preconnected to standard error.  This must be a positive integer.  The
default value is 0.


File: gfortran.info,  Node: GFORTRAN_USE_STDERR,  Next: GFORTRAN_TMPDIR,  Prev: GFORTRAN_STDERR_UNIT,  Up: Runtime

3.4 `GFORTRAN_USE_STDERR'--Send library output to standard error
================================================================

This environment variable controls where library output is sent.  If
the first letter is `y', `Y' or `1', standard error is used. If the
first letter is `n', `N' or `0', standard output is used.


File: gfortran.info,  Node: GFORTRAN_TMPDIR,  Next: GFORTRAN_UNBUFFERED_ALL,  Prev: GFORTRAN_USE_STDERR,  Up: Runtime

3.5 `GFORTRAN_TMPDIR'--Directory for scratch files
==================================================

This environment variable controls where scratch files are created.  If
this environment variable is missing, GNU Fortran searches for the
environment variable `TMP'.  If this is also missing, the default is
`/tmp'.


File: gfortran.info,  Node: GFORTRAN_UNBUFFERED_ALL,  Next: GFORTRAN_SHOW_LOCUS,  Prev: GFORTRAN_TMPDIR,  Up: Runtime

3.6 `GFORTRAN_UNBUFFERED_ALL'--Don't buffer output
==================================================

This environment variable controls whether all output is unbuffered.
If the first letter is `y', `Y' or `1', all output is unbuffered. This
will slow down large writes.  If the first letter is `n', `N'  or `0',
output is buffered.  This is the default.


File: gfortran.info,  Node: GFORTRAN_SHOW_LOCUS,  Next: GFORTRAN_OPTIONAL_PLUS,  Prev: GFORTRAN_UNBUFFERED_ALL,  Up: Runtime

3.7 `GFORTRAN_SHOW_LOCUS'--Show location for runtime errors
===========================================================

If the first letter is `y', `Y' or `1', filename and line numbers for
runtime errors are printed.  If the first letter is `n', `N' or `0',
don't print filename and line numbers for runtime errors. The default
is to print the location.


File: gfortran.info,  Node: GFORTRAN_OPTIONAL_PLUS,  Next: GFORTRAN_DEFAULT_RECL,  Prev: GFORTRAN_SHOW_LOCUS,  Up: Runtime

3.8 `GFORTRAN_OPTIONAL_PLUS'--Print leading + where permitted
=============================================================

If the first letter is `y', `Y' or `1', a plus sign is printed where
permitted by the Fortran standard.  If the first letter is `n', `N' or
`0', a plus sign is not printed in most cases. Default is not to print
plus signs.


File: gfortran.info,  Node: GFORTRAN_DEFAULT_RECL,  Next: GFORTRAN_LIST_SEPARATOR,  Prev: GFORTRAN_OPTIONAL_PLUS,  Up: Runtime

3.9 `GFORTRAN_DEFAULT_RECL'--Default record length for new files
================================================================

This environment variable specifies the default record length, in
bytes, for files which are opened without a `RECL' tag in the `OPEN'
statement.  This must be a positive integer.  The default value is
1073741824 bytes (1 GB).


File: gfortran.info,  Node: GFORTRAN_LIST_SEPARATOR,  Next: GFORTRAN_CONVERT_UNIT,  Prev: GFORTRAN_DEFAULT_RECL,  Up: Runtime

3.10 `GFORTRAN_LIST_SEPARATOR'--Separator for list output
=========================================================

This environment variable specifies the separator when writing
list-directed output.  It may contain any number of spaces and at most
one comma.  If you specify this on the command line, be sure to quote
spaces, as in
     $ GFORTRAN_LIST_SEPARATOR='  ,  ' ./a.out
   when `a.out' is the compiled Fortran program that you want to run.
Default is a single space.


File: gfortran.info,  Node: GFORTRAN_CONVERT_UNIT,  Prev: GFORTRAN_LIST_SEPARATOR,  Up: Runtime

3.11 `GFORTRAN_CONVERT_UNIT'--Set endianness for unformatted I/O
================================================================

By setting the `GFORTRAN_CONVERT_UNIT' variable, it is possible to
change the representation of data for unformatted files.  The syntax
for the `GFORTRAN_CONVERT_UNIT' variable is:
     GFORTRAN_CONVERT_UNIT: mode | mode ';' exception | exception ;
     mode: 'native' | 'swap' | 'big_endian' | 'little_endian' ;
     exception: mode ':' unit_list | unit_list ;
     unit_list: unit_spec | unit_list unit_spec ;
     unit_spec: INTEGER | INTEGER '-' INTEGER ;
   The variable consists of an optional default mode, followed by a
list of optional exceptions, which are separated by semicolons from the
preceding default and each other.  Each exception consists of a format
and a comma-separated list of units.  Valid values for the modes are
the same as for the `CONVERT' specifier:

     `NATIVE' Use the native format.  This is the default.

     `SWAP' Swap between little- and big-endian.

     `LITTLE_ENDIAN' Use the little-endian format         for
     unformatted files.

     `BIG_ENDIAN' Use the big-endian format for unformatted files.
   A missing mode for an exception is taken to mean `BIG_ENDIAN'.
Examples of values for `GFORTRAN_CONVERT_UNIT' are:
     `'big_endian''  Do all unformatted I/O in big_endian mode.

     `'little_endian;native:10-20,25''  Do all unformatted I/O in
     little_endian mode, except for units 10 to 20 and 25, which are in
     native format.

     `'10-20''  Units 10 to 20 are big-endian, the rest is native.

   Setting the environment variables should be done on the command line
or via the `export' command for `sh'-compatible shells and via `setenv'
for `csh'-compatible shells.

   Example for `sh':
     $ gfortran foo.f90
     $ GFORTRAN_CONVERT_UNIT='big_endian;native:10-20' ./a.out

   Example code for `csh':
     % gfortran foo.f90
     % setenv GFORTRAN_CONVERT_UNIT 'big_endian;native:10-20'
     % ./a.out

   Using anything but the native representation for unformatted data
carries a significant speed overhead.  If speed in this area matters to
you, it is best if you use this only for data that needs to be portable.

   *Note CONVERT specifier::, for an alternative way to specify the
data representation for unformatted files.  *Note Runtime Options::, for
setting a default data representation for the whole program.  The
`CONVERT' specifier overrides the `-fconvert' compile options.

   _Note that the values specified via the GFORTRAN_CONVERT_UNIT
environment variable will override the CONVERT specifier in the open
statement_.  This is to give control over data formats to users who do
not have the source code of their program available.


File: gfortran.info,  Node: Fortran 2003 status,  Next: Extensions,  Prev: Runtime,  Up: Top

4 Fortran 2003 Status
*********************

Although GNU Fortran focuses on implementing the Fortran 95 standard
for the time being, a few Fortran 2003 features are currently available.

   * Intrinsics `command_argument_count', `get_command',
     `get_command_argument', `get_environment_variable', and
     `move_alloc'.

   * Array constructors using square brackets. That is, `[...]' rather
     than `(/.../)'.

   * `FLUSH' statement.

   * `IOMSG=' specifier for I/O statements.

   * Support for the declaration of enumeration constants via the
     `ENUM' and `ENUMERATOR' statements.  Interoperability with `gcc'
     is guaranteed also for the case where the `-fshort-enums' command
     line option is given.

   * TR 15581:
        * `ALLOCATABLE' dummy arguments.

        * `ALLOCATABLE' function results

        * `ALLOCATABLE' components of derived types

   * The `OPEN' statement supports the `ACCESS='STREAM'' specifier,
     allowing I/O without any record structure.



File: gfortran.info,  Node: Extensions,  Next: Intrinsic Procedures,  Prev: Fortran 2003 status,  Up: Top

5 Extensions
************

GNU Fortran implements a number of extensions over standard Fortran.
This chapter contains information on their syntax and meaning.  There
are currently two categories of GNU Fortran extensions, those that
provide functionality beyond that provided by any standard, and those
that are supported by GNU Fortran purely for backward compatibility
with legacy compilers.  By default, `-std=gnu' allows the compiler to
accept both types of extensions, but to warn about the use of the
latter.  Specifying either `-std=f95' or `-std=f2003' disables both
types of extensions, and `-std=legacy' allows both without warning.

* Menu:

* Old-style kind specifications::
* Old-style variable initialization::
* Extensions to namelist::
* X format descriptor without count field::
* Commas in FORMAT specifications::
* Missing period in FORMAT specifications::
* I/O item lists::
* BOZ literal constants::
* Real array indices::
* Unary operators::
* Implicitly convert LOGICAL and INTEGER values::
* Hollerith constants support::
* Cray pointers::
* CONVERT specifier::
* OpenMP::


File: gfortran.info,  Node: Old-style kind specifications,  Next: Old-style variable initialization,  Up: Extensions

5.1 Old-style kind specifications
=================================

GNU Fortran allows old-style kind specifications in declarations. These
look like:
           TYPESPEC*size x,y,z
   where `TYPESPEC' is a basic type (`INTEGER', `REAL', etc.), and
where `size' is a byte count corresponding to the storage size of a
valid kind for that type.  (For `COMPLEX' variables, `size' is the
total size of the real and imaginary parts.)  The statement then
declares `x', `y' and `z' to be of type `TYPESPEC' with the appropriate
kind.  This is equivalent to the standard-conforming declaration
           TYPESPEC(k) x,y,z
   where `k' is equal to `size' for most types, but is equal to
`size/2' for the `COMPLEX' type.


File: gfortran.info,  Node: Old-style variable initialization,  Next: Extensions to namelist,  Prev: Old-style kind specifications,  Up: Extensions

5.2 Old-style variable initialization
=====================================

GNU Fortran allows old-style initialization of variables of the form:
           INTEGER i/1/,j/2/
           REAL x(2,2) /3*0.,1./
   The syntax for the initializers is as for the `DATA' statement, but
unlike in a `DATA' statement, an initializer only applies to the
variable immediately preceding the initialization.  In other words,
something like `INTEGER I,J/2,3/' is not valid.  This style of
initialization is only allowed in declarations without double colons
(`::'); the double colons were introduced in Fortran 90, which also
introduced a standard syntax for initializing variables in type
declarations.

   Examples of standard-conforming code equivalent to the above example
are:
     ! Fortran 90
           INTEGER :: i = 1, j = 2
           REAL :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))
     ! Fortran 77
           INTEGER i, j
           REAL x(2,2)
           DATA i/1/, j/2/, x/3*0.,1./

   Note that variables which are explicitly initialized in declarations
or in `DATA' statements automatically acquire the `SAVE' attribute.


File: gfortran.info,  Node: Extensions to namelist,  Next: X format descriptor without count field,  Prev: Old-style variable initialization,  Up: Extensions

5.3 Extensions to namelist
==========================

GNU Fortran fully supports the Fortran 95 standard for namelist I/O
including array qualifiers, substrings and fully qualified derived
types.  The output from a namelist write is compatible with namelist
read.  The output has all names in upper case and indentation to column
1 after the namelist name.  Two extensions are permitted:

   Old-style use of `$' instead of `&'
     $MYNML
      X(:)%Y(2) = 1.0 2.0 3.0
      CH(1:4) = "abcd"
     $END

   It should be noted that the default terminator is `/' rather than
`&END'.

   Querying of the namelist when inputting from stdin. After at least
one space, entering `?' sends to stdout the namelist name and the names
of the variables in the namelist:
      ?

     &mynml
      x
      x%y
      ch
     &end

   Entering `=?' outputs the namelist to stdout, as if `WRITE(*,NML =
mynml)' had been called:
     =?

     &MYNML
      X(1)%Y=  0.000000    ,  1.000000    ,  0.000000    ,
      X(2)%Y=  0.000000    ,  2.000000    ,  0.000000    ,
      X(3)%Y=  0.000000    ,  3.000000    ,  0.000000    ,
      CH=abcd,  /

   To aid this dialog, when input is from stdin, errors send their
messages to stderr and execution continues, even if `IOSTAT' is set.

   `PRINT' namelist is permitted.  This causes an error if `-std=f95'
is used.
     PROGRAM test_print
       REAL, dimension (4)  ::  x = (/1.0, 2.0, 3.0, 4.0/)
       NAMELIST /mynml/ x
       PRINT mynml
     END PROGRAM test_print

   Expanded namelist reads are permitted.  This causes an error if
`-std=f95' is used.  In the following example, the first element of the
array will be given the value 0.00 and the two succeeding elements will
be given the values 1.00 and 2.00.
     &MYNML
       X(1,1) = 0.00 , 1.00 , 2.00
     /


File: gfortran.info,  Node: X format descriptor without count field,  Next: Commas in FORMAT specifications,  Prev: Extensions to namelist,  Up: Extensions

5.4 `X' format descriptor without count field
=============================================

To support legacy codes, GNU Fortran permits the count field of the `X'
edit descriptor in `FORMAT' statements to be omitted.  When omitted,
the count is implicitly assumed to be one.

            PRINT 10, 2, 3
     10     FORMAT (I1, X, I1)


File: gfortran.info,  Node: Commas in FORMAT specifications,  Next: Missing period in FORMAT specifications,  Prev: X format descriptor without count field,  Up: Extensions

5.5 Commas in `FORMAT' specifications
=====================================

To support legacy codes, GNU Fortran allows the comma separator to be
omitted immediately before and after character string edit descriptors
in `FORMAT' statements.

            PRINT 10, 2, 3
     10     FORMAT ('FOO='I1' BAR='I2)


File: gfortran.info,  Node: Missing period in FORMAT specifications,  Next: I/O item lists,  Prev: Commas in FORMAT specifications,  Up: Extensions

5.6 Missing period in `FORMAT' specifications
=============================================

To support legacy codes, GNU Fortran allows missing periods in format
specifications if and only if `-std=legacy' is given on the command
line.  This is considered non-conforming code and is discouraged.

            REAL :: value
            READ(*,10) value
     10     FORMAT ('F4')


File: gfortran.info,  Node: I/O item lists,  Next: BOZ literal constants,  Prev: Missing period in FORMAT specifications,  Up: Extensions

5.7 I/O item lists
==================

To support legacy codes, GNU Fortran allows the input item list of the
`READ' statement, and the output item lists of the `WRITE' and `PRINT'
statements, to start with a comma.


File: gfortran.info,  Node: BOZ literal constants,  Next: Real array indices,  Prev: I/O item lists,  Up: Extensions

5.8 BOZ literal constants
=========================

As an extension, GNU Fortran allows hexadecimal BOZ literal constants to
be specified using the X prefix, in addition to the standard Z prefix.
BOZ literal constants can also be specified by adding a suffix to the
string. For example, `Z'ABC'' and `'ABC'Z' are equivalent.

   The Fortran standard restricts the appearance of a BOZ literal
constant to the `DATA' statement, and it is expected to be assigned to
an `INTEGER' variable.  GNU Fortran permits a BOZ literal to appear in
any initialization expression as well as assignment statements.

   Attempts to use a BOZ literal constant to do a bitwise
initialization of a variable can lead to confusion.  A BOZ literal
constant is converted to an `INTEGER' value with the kind type with the
largest decimal representation, and this value is then converted
numerically to the type and kind of the variable in question.  Thus,
one should not expect a bitwise copy of the BOZ literal constant to be
assigned to a `REAL' variable.

   Similarly, initializing an `INTEGER' variable with a statement such
as `DATA i/Z'FFFFFFFF'/' will produce an integer overflow rather than
the desired result of -1 when `i' is a 32-bit integer on a system that
supports 64-bit integers.  The `-fno-range-check' option can be used as
a workaround for legacy code that initializes integers in this manner.


File: gfortran.info,  Node: Real array indices,  Next: Unary operators,  Prev: BOZ literal constants,  Up: Extensions

5.9 Real array indices
======================

As an extension, GNU Fortran allows the use of `REAL' expressions or
variables as array indices.


File: gfortran.info,  Node: Unary operators,  Next: Implicitly convert LOGICAL and INTEGER values,  Prev: Real array indices,  Up: Extensions

5.10 Unary operators
====================

As an extension, GNU Fortran allows unary plus and unary minus operators
to appear as the second operand of binary arithmetic operators without
the need for parenthesis.

            X = Y * -Z


File: gfortran.info,  Node: Implicitly convert LOGICAL and INTEGER values,  Next: Hollerith constants support,  Prev: Unary operators,  Up: Extensions

5.11 Implicitly convert `LOGICAL' and `INTEGER' values
======================================================

As an extension for backwards compatibility with other compilers, GNU
Fortran allows the implicit conversion of `LOGICAL' values to `INTEGER'
values and vice versa.  When converting from a `LOGICAL' to an
`INTEGER', `.FALSE.' is interpreted as zero, and `.TRUE.' is
interpreted as one.  When converting from `INTEGER' to `LOGICAL', the
value zero is interpreted as `.FALSE.' and any nonzero value is
interpreted as `.TRUE.'.

            INTEGER :: i = 1
            IF (i) PRINT *, 'True'


File: gfortran.info,  Node: Hollerith constants support,  Next: Cray pointers,  Prev: Implicitly convert LOGICAL and INTEGER values,  Up: Extensions

5.12 Hollerith constants support
================================

GNU Fortran supports Hollerith constants in assignments, function
arguments, and `DATA' and `ASSIGN' statements.  A Hollerith constant is
written as a string of characters preceded by an integer constant
indicating the character count, and the letter `H' or `h', and stored
in bytewise fashion in a numeric (`INTEGER', `REAL', or `complex') or
`LOGICAL' variable.  The constant will be padded or truncated to fit
the size of the variable in which it is stored.

   Examples of valid uses of Hollerith constants:
           complex*16 x(2)
           data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/
           x(1) = 16HABCDEFGHIJKLMNOP
           call foo (4h abc)

   Invalid Hollerith constants examples:
           integer*4 a
           a = 8H12345678 ! Valid, but the Hollerith constant will be truncated.
           a = 0H         ! At least one character is needed.

   In general, Hollerith constants were used to provide a rudimentary
facility for handling character strings in early Fortran compilers,
prior to the introduction of `CHARACTER' variables in Fortran 77; in
those cases, the standard-compliant equivalent is to convert the
program to use proper character strings.  On occasion, there may be a
case where the intent is specifically to initialize a numeric variable
with a given byte sequence.  In these cases, the same result can be
obtained by using the `TRANSFER' statement, as in this example.
           INTEGER(KIND=4) :: a
           a = TRANSFER ("abcd", a)     ! equivalent to: a = 4Habcd


File: gfortran.info,  Node: Cray pointers,  Next: CONVERT specifier,  Prev: Hollerith constants support,  Up: Extensions

5.13 Cray pointers
==================

Cray pointers are part of a non-standard extension that provides a
C-like pointer in Fortran.  This is accomplished through a pair of
variables: an integer "pointer" that holds a memory address, and a
"pointee" that is used to dereference the pointer.

   Pointer/pointee pairs are declared in statements of the form:
             pointer ( <pointer> , <pointee> )
   or,
             pointer ( <pointer1> , <pointee1> ), ( <pointer2> , <pointee2> ), ...
   The pointer is an integer that is intended to hold a memory address.
The pointee may be an array or scalar.  A pointee can be an assumed
size array--that is, the last dimension may be left unspecified by
using a `*' in place of a value--but a pointee cannot be an assumed
shape array.  No space is allocated for the pointee.

   The pointee may have its type declared before or after the pointer
statement, and its array specification (if any) may be declared before,
during, or after the pointer statement.  The pointer may be declared as
an integer prior to the pointer statement.  However, some machines have
default integer sizes that are different than the size of a pointer,
and so the following code is not portable:
             integer ipt
             pointer (ipt, iarr)
   If a pointer is declared with a kind that is too small, the compiler
will issue a warning; the resulting binary will probably not work
correctly, because the memory addresses stored in the pointers may be
truncated.  It is safer to omit the first line of the above example; if
explicit declaration of ipt's type is omitted, then the compiler will
ensure that ipt is an integer variable large enough to hold a pointer.

   Pointer arithmetic is valid with Cray pointers, but it is not the
same as C pointer arithmetic.  Cray pointers are just ordinary
integers, so the user is responsible for determining how many bytes to
add to a pointer in order to increment it.  Consider the following
example:
             real target(10)
             real pointee(10)
             pointer (ipt, pointee)
             ipt = loc (target)
             ipt = ipt + 1
   The last statement does not set `ipt' to the address of `target(1)',
as it would in C pointer arithmetic.  Adding `1' to `ipt' just adds one
byte to the address stored in `ipt'.

   Any expression involving the pointee will be translated to use the
value stored in the pointer as the base address.

   To get the address of elements, this extension provides an intrinsic
function `LOC()'.  The `LOC()' function is equivalent to the `&'
operator in C, except the address is cast to an integer type:
             real ar(10)
             pointer(ipt, arpte(10))
             real arpte
             ipt = loc(ar)  ! Makes arpte is an alias for ar
             arpte(1) = 1.0 ! Sets ar(1) to 1.0
   The pointer can also be set by a call to the `MALLOC' intrinsic (see
*Note MALLOC::).

   Cray pointees often are used to alias an existing variable.  For
example:
             integer target(10)
             integer iarr(10)
             pointer (ipt, iarr)
             ipt = loc(target)
   As long as `ipt' remains unchanged, `iarr' is now an alias for
`target'. The optimizer, however, will not detect this aliasing, so it
is unsafe to use `iarr' and `target' simultaneously.  Using a pointee
in any way that violates the Fortran aliasing rules or assumptions is
illegal. It is the user's responsibility to avoid doing this; the
compiler works under the assumption that no such aliasing occurs.

   Cray pointers will work correctly when there is no aliasing (i.e.,
when they are used to access a dynamically allocated block of memory),
and also in any routine where a pointee is used, but any variable with
which it shares storage is not used.  Code that violates these rules
may not run as the user intends.  This is not a bug in the optimizer;
any code that violates the aliasing rules is illegal.  (Note that this
is not unique to GNU Fortran; any Fortran compiler that supports Cray
pointers will "incorrectly" optimize code with illegal aliasing.)

   There are a number of restrictions on the attributes that can be
applied to Cray pointers and pointees.  Pointees may not have the
`ALLOCATABLE', `INTENT', `OPTIONAL', `DUMMY', `TARGET', `INTRINSIC', or
`POINTER' attributes. Pointers may not have the `DIMENSION', `POINTER',
`TARGET', `ALLOCATABLE', `EXTERNAL', or `INTRINSIC' attributes.
Pointees may not occur in more than one pointer statement.  A pointee
cannot be a pointer.  Pointees cannot occur in equivalence, common, or
data statements.

   A Cray pointer may also point to a function or a subroutine.  For
example, the following excerpt is valid:
       implicit none
       external sub
       pointer (subptr,subpte)
       external subpte
       subptr = loc(sub)
       call subpte()
       [...]
       subroutine sub
       [...]
       end subroutine sub

   A pointer may be modified during the course of a program, and this
will change the location to which the pointee refers.  However, when
pointees are passed as arguments, they are treated as ordinary
variables in the invoked function.  Subsequent changes to the pointer
will not change the base address of the array that was passed.


File: gfortran.info,  Node: CONVERT specifier,  Next: OpenMP,  Prev: Cray pointers,  Up: Extensions

5.14 CONVERT specifier
======================

GNU Fortran allows the conversion of unformatted data between little-
and big-endian representation to facilitate moving of data between
different systems.  The conversion can be indicated with the `CONVERT'
specifier on the `OPEN' statement.  *Note GFORTRAN_CONVERT_UNIT::, for
an alternative way of specifying the data format via an environment
variable.

   Valid values for `CONVERT' are:
     `CONVERT='NATIVE'' Use the native format.  This is the default.

     `CONVERT='SWAP'' Swap between little- and big-endian.

     `CONVERT='LITTLE_ENDIAN'' Use the little-endian representation
        for unformatted files.

     `CONVERT='BIG_ENDIAN'' Use the big-endian representation for
      unformatted files.

   Using the option could look like this:
       open(file='big.dat',form='unformatted',access='sequential', &
            convert='big_endian')

   The value of the conversion can be queried by using
`INQUIRE(CONVERT=ch)'.  The values returned are `'BIG_ENDIAN'' and
`'LITTLE_ENDIAN''.

   `CONVERT' works between big- and little-endian for `INTEGER' values
of all supported kinds and for `REAL' on IEEE systems of kinds 4 and 8.
Conversion between different "extended double" types on different
architectures such as m68k and x86_64, which GNU Fortran supports as
`REAL(KIND=10)' and `REAL(KIND=16)', will probably not work.

   _Note that the values specified via the GFORTRAN_CONVERT_UNIT
environment variable will override the CONVERT specifier in the open
statement_.  This is to give control over data formats to users who do
not have the source code of their program available.

   Using anything but the native representation for unformatted data
carries a significant speed overhead.  If speed in this area matters to
you, it is best if you use this only for data that needs to be portable.


File: gfortran.info,  Node: OpenMP,  Prev: CONVERT specifier,  Up: Extensions

5.15 OpenMP
===========

GNU Fortran attempts to be OpenMP Application Program Interface v2.5
compatible when invoked with the `-fopenmp' option.  GNU Fortran then
generates parallelized code according to the OpenMP directives used in
the source.  The OpenMP Fortran runtime library routines are provided
both in a form of a Fortran 90 module named `omp_lib' and in a form of
a Fortran `include' file named `omp_lib.h'.

   For details refer to the actual OpenMP Application Program Interface
v2.5 (http://www.openmp.org/drupal/mp-documents/spec25.pdf)
specification.


File: gfortran.info,  Node: Intrinsic Procedures,  Next: Contributing,  Prev: Extensions,  Up: Top

6 Intrinsic Procedures
**********************

* Menu:

* Introduction:         Introduction to Intrinsics
* `ABORT':         ABORT,     Abort the program
* `ABS':           ABS,       Absolute value
* `ACCESS':        ACCESS,    Checks file access modes
* `ACHAR':         ACHAR,     Character in ASCII collating sequence
* `ACOS':          ACOS,      Arccosine function
* `ACOSH':         ACOSH,     Hyperbolic arccosine function
* `ADJUSTL':       ADJUSTL,   Left adjust a string
* `ADJUSTR':       ADJUSTR,   Right adjust a string
* `AIMAG':         AIMAG,     Imaginary part of complex number
* `AINT':          AINT,      Truncate to a whole number
* `ALARM':         ALARM,     Set an alarm clock
* `ALL':           ALL,       Determine if all values are true
* `ALLOCATED':     ALLOCATED, Status of allocatable entity
* `AND':           AND,       Bitwise logical AND
* `ANINT':         ANINT,     Nearest whole number
* `ANY':           ANY,       Determine if any values are true
* `ASIN':          ASIN,      Arcsine function
* `ASINH':         ASINH,     Hyperbolic arcsine function
* `ASSOCIATED':    ASSOCIATED, Status of a pointer or pointer/target pair
* `ATAN':          ATAN,      Arctangent function
* `ATAN2':         ATAN2,     Arctangent function
* `ATANH':         ATANH,     Hyperbolic arctangent function
* `BESJ0':         BESJ0,     Bessel function of the first kind of order 0
* `BESJ1':         BESJ1,     Bessel function of the first kind of order 1
* `BESJN':         BESJN,     Bessel function of the first kind
* `BESY0':         BESY0,     Bessel function of the second kind of order 0
* `BESY1':         BESY1,     Bessel function of the second kind of order 1
* `BESYN':         BESYN,     Bessel function of the second kind
* `BIT_SIZE':      BIT_SIZE,  Bit size inquiry function
* `BTEST':         BTEST,     Bit test function
* `CEILING':       CEILING,   Integer ceiling function
* `CHAR':          CHAR,      Integer-to-character conversion function
* `CHDIR':         CHDIR,     Change working directory
* `CHMOD':         CHMOD,     Change access permissions of files
* `CMPLX':         CMPLX,     Complex conversion function
* `COMMAND_ARGUMENT_COUNT': COMMAND_ARGUMENT_COUNT, Get number of command line arguments
* `COMPLEX':       COMPLEX,   Complex conversion function
* `CONJG':         CONJG,     Complex conjugate function
* `COS':           COS,       Cosine function
* `COSH':          COSH,      Hyperbolic cosine function
* `COUNT':         COUNT,     Count occurrences of TRUE in an array
* `CPU_TIME':      CPU_TIME,  CPU time subroutine
* `CSHIFT':        CSHIFT,    Circular shift elements of an array
* `CTIME':         CTIME,     Subroutine (or function) to convert a time into a string
* `DATE_AND_TIME': DATE_AND_TIME, Date and time subroutine
* `DBLE':          DBLE,      Double precision conversion function
* `DCMPLX':        DCMPLX,    Double complex conversion function
* `DFLOAT':        DFLOAT,    Double precision conversion function
* `DIGITS':        DIGITS,    Significant digits function
* `DIM':           DIM,       Positive difference
* `DOT_PRODUCT':   DOT_PRODUCT, Dot product function
* `DPROD':         DPROD,     Double product function
* `DREAL':         DREAL,     Double real part function
* `DTIME':         DTIME,     Execution time subroutine (or function)
* `EOSHIFT':       EOSHIFT,   End-off shift elements of an array
* `EPSILON':       EPSILON,   Epsilon function
* `ERF':           ERF,       Error function
* `ERFC':          ERFC,      Complementary error function
* `ETIME':         ETIME,     Execution time subroutine (or function)
* `EXIT':          EXIT,      Exit the program with status.
* `EXP':           EXP,       Exponential function
* `EXPONENT':      EXPONENT,  Exponent function
* `FDATE':         FDATE,     Subroutine (or function) to get the current time as a string
* `FGET':          FGET,      Read a single character in stream mode from stdin
* `FGETC':         FGETC,     Read a single character in stream mode
* `FLOAT':         FLOAT,     Convert integer to default real
* `FLOOR':         FLOOR,     Integer floor function
* `FLUSH':         FLUSH,     Flush I/O unit(s)
* `FNUM':          FNUM,      File number function
* `FPUT':          FPUT,      Write a single character in stream mode to stdout
* `FPUTC':         FPUTC,     Write a single character in stream mode
* `FRACTION':      FRACTION,  Fractional part of the model representation
* `FREE':          FREE,      Memory de-allocation subroutine
* `FSEEK':         FSEEK,     Low level file positioning subroutine
* `FSTAT':         FSTAT,     Get file status
* `FTELL':         FTELL,     Current stream position
* `GERROR':        GERROR,    Get last system error message
* `GETARG':        GETARG,    Get command line arguments
* `GET_COMMAND':   GET_COMMAND, Get the entire command line
* `GET_COMMAND_ARGUMENT': GET_COMMAND_ARGUMENT, Get command line arguments
* `GETCWD':        GETCWD,    Get current working directory
* `GETENV':        GETENV,    Get an environmental variable
* `GET_ENVIRONMENT_VARIABLE': GET_ENVIRONMENT_VARIABLE, Get an environmental variable
* `GETGID':        GETGID,    Group ID function
* `GETLOG':        GETLOG,    Get login name
* `GETPID':        GETPID,    Process ID function
* `GETUID':        GETUID,    User ID function
* `GMTIME':        GMTIME,    Convert time to GMT info
* `HOSTNM':        HOSTNM,    Get system host name
* `HUGE':          HUGE,      Largest number of a kind
* `IACHAR':        IACHAR,    Code in ASCII collating sequence
* `IAND':          IAND,      Bitwise logical and
* `IARGC':         IARGC,     Get the number of command line arguments
* `IBCLR':         IBCLR,     Clear bit
* `IBITS':         IBITS,     Bit extraction
* `IBSET':         IBSET,     Set bit
* `ICHAR':         ICHAR,     Character-to-integer conversion function
* `IDATE':         IDATE,     Current local time (day/month/year)
* `IEOR':          IEOR,      Bitwise logical exclusive or
* `IERRNO':        IERRNO,    Function to get the last system error number
* `INDEX':         INDEX,     Position of a substring within a string
* `INT':           INT,       Convert to integer type
* `INT2':          INT2,      Convert to 16-bit integer type
* `INT8':          INT8,      Convert to 64-bit integer type
* `IOR':           IOR,       Bitwise logical or
* `IRAND':         IRAND,     Integer pseudo-random number
* `ISATTY':        ISATTY,    Whether a unit is a terminal device
* `ISHFT':         ISHFT,     Shift bits
* `ISHFTC':        ISHFTC,    Shift bits circularly
* `ITIME':         ITIME,     Current local time (hour/minutes/seconds)
* `KILL':          KILL,      Send a signal to a process
* `KIND':          KIND,      Kind of an entity
* `LBOUND':        LBOUND,    Lower dimension bounds of an array
* `LEN':           LEN,       Length of a character entity
* `LEN_TRIM':      LEN_TRIM,  Length of a character entity without trailing blank characters
* `LGE':           LGE,       Lexical greater than or equal
* `LGT':           LGT,       Lexical greater than
* `LINK':          LINK,      Create a hard link
* `LLE':           LLE,       Lexical less than or equal
* `LLT':           LLT,       Lexical less than
* `LNBLNK':        LNBLNK,    Index of the last non-blank character in a string
* `LOC':           LOC,       Returns the address of a variable
* `LOG':           LOG,       Logarithm function
* `LOG10':         LOG10,     Base 10 logarithm function
* `LOGICAL':       LOGICAL,   Convert to logical type
* `LONG':          LONG,      Convert to integer type
* `LSHIFT':        LSHIFT,    Left shift bits
* `LSTAT':         LSTAT,     Get file status
* `LTIME':         LTIME,     Convert time to local time info
* `MALLOC':        MALLOC,    Dynamic memory allocation function
* `MATMUL':        MATMUL,    matrix multiplication
* `MAX':           MAX,       Maximum value of an argument list
* `MAXEXPONENT':   MAXEXPONENT, Maximum exponent of a real kind
* `MAXLOC':        MAXLOC,    Location of the maximum value within an array
* `MAXVAL':        MAXVAL,    Maximum value of an array
* `MCLOCK':        MCLOCK,    Time function
* `MCLOCK8':       MCLOCK8,   Time function (64-bit)
* `MERGE':         MERGE,     Merge arrays
* `MIN':           MIN,       Minimum value of an argument list
* `MINEXPONENT':   MINEXPONENT, Minimum exponent of a real kind
* `MINLOC':        MINLOC,    Location of the minimum value within an array
* `MINVAL':        MINVAL,    Minimum value of an array
* `MOD':           MOD,       Remainder function
* `MODULO':        MODULO,    Modulo function
* `MOVE_ALLOC':    MOVE_ALLOC, Move allocation from one object to another
* `MVBITS':        MVBITS,    Move bits from one integer to another
* `NEAREST':       NEAREST,   Nearest representable number
* `NEW_LINE':      NEW_LINE,  New line character
* `NINT':          NINT,      Nearest whole number
* `NOT':           NOT,       Logical negation
* `NULL':          NULL,      Function that returns an disassociated pointer
* `OR':            OR,        Bitwise logical OR
* `PACK':          PACK,      Pack an array into an array of rank one
* `PERROR':        PERROR,    Print system error message
* `PRECISION':     PRECISION, Decimal precision of a real kind
* `PRESENT':       PRESENT,   Determine whether an optional dummy argument is specified
* `PRODUCT':       PRODUCT,   Product of array elements
* `RADIX':         RADIX,     Base of a data model
* `RANDOM_NUMBER': RANDOM_NUMBER, Pseudo-random number
* `RANDOM_SEED':   RANDOM_SEED, Initialize a pseudo-random number sequence
* `RAND':          RAND,      Real pseudo-random number
* `RANGE':         RANGE,     Decimal exponent range of a real kind
* `RAN':           RAN,       Real pseudo-random number
* `REAL':          REAL,      Convert to real type
* `RENAME':        RENAME,    Rename a file
* `REPEAT':        REPEAT,    Repeated string concatenation
* `RESHAPE':       RESHAPE,   Function to reshape an array
* `RRSPACING':     RRSPACING, Reciprocal of the relative spacing
* `RSHIFT':        RSHIFT,    Right shift bits
* `SCALE':         SCALE,     Scale a real value
* `SCAN':          SCAN,      Scan a string for the presence of a set of characters
* `SECNDS':        SECNDS,    Time function
* `SECOND':        SECOND,    CPU time function
* `SELECTED_INT_KIND': SELECTED_INT_KIND,  Choose integer kind
* `SELECTED_REAL_KIND': SELECTED_REAL_KIND,  Choose real kind
* `SET_EXPONENT':  SET_EXPONENT, Set the exponent of the model
* `SHAPE':         SHAPE,     Determine the shape of an array
* `SIGN':          SIGN,      Sign copying function
* `SIGNAL':        SIGNAL,    Signal handling subroutine (or function)
* `SIN':           SIN,       Sine function
* `SINH':          SINH,      Hyperbolic sine function
* `SIZE':          SIZE,      Function to determine the size of an array
* `SLEEP':         SLEEP,     Sleep for the specified number of seconds
* `SNGL':          SNGL,      Convert double precision real to default real
* `SPACING':       SPACING,   Smallest distance between two numbers of a given type
* `SPREAD':        SPREAD,    Add a dimension to an array
* `SQRT':          SQRT,      Square-root function
* `SRAND':         SRAND,     Reinitialize the random number generator
* `STAT':          STAT,      Get file status
* `SUM':           SUM,       Sum of array elements
* `SYMLNK':        SYMLNK,    Create a symbolic link
* `SYSTEM':        SYSTEM,    Execute a shell command
* `SYSTEM_CLOCK':  SYSTEM_CLOCK, Time function
* `TAN':           TAN,       Tangent function
* `TANH':          TANH,      Hyperbolic tangent function
* `TIME':          TIME,      Time function
* `TIME8':         TIME8,     Time function (64-bit)
* `TINY':          TINY,      Smallest positive number of a real kind
* `TRANSFER':      TRANSFER,  Transfer bit patterns
* `TRANSPOSE':     TRANSPOSE, Transpose an array of rank two
* `TRIM':          TRIM,      Remove trailing blank characters of a string
* `TTYNAM':        TTYNAM,    Get the name of a terminal device.
* `UBOUND':        UBOUND,    Upper dimension bounds of an array
* `UMASK':         UMASK,     Set the file creation mask
* `UNLINK':        UNLINK,    Remove a file from the file system
* `UNPACK':        UNPACK,    Unpack an array of rank one into an array
* `VERIFY':        VERIFY,    Scan a string for the absence of a set of characters
* `XOR':           XOR,       Bitwise logical exclusive or


File: gfortran.info,  Node: Introduction to Intrinsics,  Next: ABORT,  Up: Intrinsic Procedures

6.1 Introduction to intrinsic procedures
========================================

The intrinsic procedures provided by GNU Fortran include all of the
intrinsic procedures required by the Fortran 95 standard, a set of
intrinsic procedures for backwards compatibility with G77, and a small
selection of intrinsic procedures from the Fortran 2003 standard.  Any
conflict between a description here and a description in either the
Fortran 95 standard or the Fortran 2003 standard is unintentional, and
the standard(s) should be considered authoritative.

   The enumeration of the `KIND' type parameter is processor defined in
the Fortran 95 standard.  GNU Fortran defines the default integer type
and default real type by `INTEGER(KIND=4)' and `REAL(KIND=4)',
respectively.  The standard mandates that both data types shall have
another kind, which have more precision.  On typical target
architectures supported by `gfortran', this kind type parameter is
`KIND=8'.  Hence, `REAL(KIND=8)' and `DOUBLE PRECISION' are equivalent.
In the description of generic intrinsic procedures, the kind type
parameter will be specified by `KIND=*', and in the description of
specific names for an intrinsic procedure the kind type parameter will
be explicitly given (e.g., `REAL(KIND=4)' or `REAL(KIND=8)').  Finally,
for brevity the optional `KIND=' syntax will be omitted.

   Many of the intrinsic procedures take one or more optional arguments.
This document follows the convention used in the Fortran 95 standard,
and denotes such arguments by square brackets.

   GNU Fortran offers the `-std=f95' and `-std=gnu' options, which can
be used to restrict the set of intrinsic procedures to a given
standard.  By default, `gfortran' sets the `-std=gnu' option, and so
all intrinsic procedures described here are accepted.  There is one
caveat.  For a select group of intrinsic procedures, `g77' implemented
both a function and a subroutine.  Both classes have been implemented
in `gfortran' for backwards compatibility with `g77'.  It is noted here
that these functions and subroutines cannot be intermixed in a given
subprogram.  In the descriptions that follow, the applicable standard
for each intrinsic procedure is noted.


File: gfortran.info,  Node: ABORT,  Next: ABS,  Prev: Introduction to Intrinsics,  Up: Intrinsic Procedures

6.2 `ABORT' -- Abort the program
================================

_Description_:
     `ABORT' causes immediate termination of the program.  On operating
     systems that support a core dump, `ABORT' will produce a core dump,
     which is suitable for debugging purposes.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL ABORT'

_Return value_:
     Does not return.

_Example_:
          program test_abort
            integer :: i = 1, j = 2
            if (i /= j) call abort
          end program test_abort

_See also_:
     *Note EXIT::, *Note KILL::



File: gfortran.info,  Node: ABS,  Next: ACCESS,  Prev: ABORT,  Up: Intrinsic Procedures

6.3 `ABS' -- Absolute value
===========================

_Description_:
     `ABS(X)' computes the absolute value of `X'.

_Standard_:
     F77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ABS(X)'

_Arguments_:
     X          The type of the argument shall be an
                `INTEGER(*)', `REAL(*)', or `COMPLEX(*)'.

_Return value_:
     The return value is of the same type and kind as the argument
     except the return value is `REAL(*)' for a `COMPLEX(*)' argument.

_Example_:
          program test_abs
            integer :: i = -1
            real :: x = -1.e0
            complex :: z = (-1.e0,0.e0)
            i = abs(i)
            x = abs(x)
            x = abs(z)
          end program test_abs

_Specific names_:
     Name          Argument      Return type   Standard
     `CABS(Z)'     `COMPLEX(4)   `REAL(4)'     F77 and later
                   Z'                          
     `DABS(X)'     `REAL(8)      `REAL(8)'     F77 and later
                   X'                          
     `IABS(I)'     `INTEGER(4)   `INTEGER(4)'  F77 and later
                   I'                          
     `ZABS(Z)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   Z'                          
     `CDABS(Z)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   Z'                          


File: gfortran.info,  Node: ACCESS,  Next: ACHAR,  Prev: ABS,  Up: Intrinsic Procedures

6.4 `ACCESS' -- Checks file access modes
========================================

_Description_:
     `ACCESS(NAME, MODE)' checks whether the file NAME exists, is
     readable, writable or executable. Except for the executable check,
     `ACCESS' can be replaced by Fortran 95's `INQUIRE'.

_Standard_:
     GNU extension

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = ACCESS(NAME, MODE)'

_Arguments_:
     NAME       Scalar `CHARACTER' with the file name.
                Tailing blank are ignored unless the character
                `achar(0)' is present, then all characters up
                to and excluding `achar(0)' are used as file
                name.
     MODE       Scalar `CHARACTER' with the file access mode,
                may be any concatenation of `"r"' (readable),
                `"w"' (writable) and `"x"' (executable), or `"
                "' to check for existence.

_Return value_:
     Returns a scalar `INTEGER', which is `0' if the file is accessible
     in the given mode; otherwise or if an invalid argument has been
     given for `MODE' the value `1' is returned.

_Example_:
          program access_test
            implicit none
            character(len=*), parameter :: file  = 'test.dat'
            character(len=*), parameter :: file2 = 'test.dat  '//achar(0)
            if(access(file,' ') == 0) print *, trim(file),' is exists'
            if(access(file,'r') == 0) print *, trim(file),' is readable'
            if(access(file,'w') == 0) print *, trim(file),' is writable'
            if(access(file,'x') == 0) print *, trim(file),' is executable'
            if(access(file2,'rwx') == 0) &
              print *, trim(file2),' is readable, writable and executable'
          end program access_test

_Specific names_:

_See also_:


File: gfortran.info,  Node: ACHAR,  Next: ACOS,  Prev: ACCESS,  Up: Intrinsic Procedures

6.5 `ACHAR' -- Character in ASCII collating sequence
====================================================

_Description_:
     `ACHAR(I)' returns the character located at position `I' in the
     ASCII collating sequence.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ACHAR(I)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `CHARACTER' with a length of one.  The
     kind type parameter is the same as  `KIND('A')'.

_Example_:
          program test_achar
            character c
            c = achar(32)
          end program test_achar

_Note_:
     See *Note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *Note CHAR::, *Note IACHAR::, *Note ICHAR::



File: gfortran.info,  Node: ACOS,  Next: ACOSH,  Prev: ACHAR,  Up: Intrinsic Procedures

6.6 `ACOS' -- Arccosine function
================================

_Description_:
     `ACOS(X)' computes the arccosine of X (inverse of `COS(X)').

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ACOS(X)'

_Arguments_:
     X          The type shall be `REAL(*)' with a magnitude
                that is less than one.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  0
     \leq \acos(x) \leq \pi. The kind type parameter is the same as X.

_Example_:
          program test_acos
            real(8) :: x = 0.866_8
            x = acos(x)
          end program test_acos

_Specific names_:
     Name          Argument      Return type   Standard
     `DACOS(X)'    `REAL(8) X'   `REAL(8)'     F77 and later

_See also_:
     Inverse function: *Note COS::



File: gfortran.info,  Node: ACOSH,  Next: ADJUSTL,  Prev: ACOS,  Up: Intrinsic Procedures

6.7 `ACOSH' -- Hyperbolic arccosine function
============================================

_Description_:
     `ACOSH(X)' computes the hyperbolic arccosine of X (inverse of
     `COSH(X)').

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ACOSH(X)'

_Arguments_:
     X          The type shall be `REAL(*)' with a magnitude
                that is greater or equal to one.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range 0
     \leq \acosh (x) \leq \infty.

_Example_:
          PROGRAM test_acosh
            REAL(8), DIMENSION(3) :: x = (/ 1.0, 2.0, 3.0 /)
            WRITE (*,*) ACOSH(x)
          END PROGRAM

_Specific names_:
     Name          Argument      Return type   Standard
     `DACOSH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension

_See also_:
     Inverse function: *Note COSH::


File: gfortran.info,  Node: ADJUSTL,  Next: ADJUSTR,  Prev: ACOSH,  Up: Intrinsic Procedures

6.8 `ADJUSTL' -- Left adjust a string
=====================================

_Description_:
     `ADJUSTL(STR)' will left adjust a string by removing leading
     spaces.  Spaces are inserted at the end of the string as needed.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ADJUSTL(STR)'

_Arguments_:
     STR        The type shall be `CHARACTER'.

_Return value_:
     The return value is of type `CHARACTER' where leading spaces are
     removed and the same number of spaces are inserted on the end of
     STR.

_Example_:
          program test_adjustl
            character(len=20) :: str = '   gfortran'
            str = adjustl(str)
            print *, str
          end program test_adjustl

_See also_:
     *Note ADJUSTR::, *Note TRIM::


File: gfortran.info,  Node: ADJUSTR,  Next: AIMAG,  Prev: ADJUSTL,  Up: Intrinsic Procedures

6.9 `ADJUSTR' -- Right adjust a string
======================================

_Description_:
     `ADJUSTR(STR)' will right adjust a string by removing trailing
     spaces.  Spaces are inserted at the start of the string as needed.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ADJUSTR(STR)'

_Arguments_:
     STR        The type shall be `CHARACTER'.

_Return value_:
     The return value is of type `CHARACTER' where trailing spaces are
     removed and the same number of spaces are inserted at the start of
     STR.

_Example_:
          program test_adjustr
            character(len=20) :: str = 'gfortran'
            str = adjustr(str)
            print *, str
          end program test_adjustr

_See also_:
     *Note ADJUSTL::, *Note TRIM::


File: gfortran.info,  Node: AIMAG,  Next: AINT,  Prev: ADJUSTR,  Up: Intrinsic Procedures

6.10 `AIMAG' -- Imaginary part of complex number
================================================

_Description_:
     `AIMAG(Z)' yields the imaginary part of complex argument `Z'.  The
     `IMAG(Z)' and `IMAGPART(Z)' intrinsic functions are provided for
     compatibility with `g77', and their use in new code is strongly
     discouraged.

_Standard_:
     F77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `RESULT = AIMAG(Z)'

_Arguments_:
     Z          The type of the argument shall be `COMPLEX(*)'.

_Return value_:
     The return value is of type real with the kind type parameter of
     the argument.

_Example_:
          program test_aimag
            complex(4) z4
            complex(8) z8
            z4 = cmplx(1.e0_4, 0.e0_4)
            z8 = cmplx(0.e0_8, 1.e0_8)
            print *, aimag(z4), dimag(z8)
          end program test_aimag

_Specific names_:
     Name          Argument      Return type   Standard
     `DIMAG(Z)'    `COMPLEX(8)   `REAL(8)'     GNU extension
                   Z'                          
     `IMAG(Z)'     `COMPLEX(*)   `REAL(*)'     GNU extension
                   Z'                          
     `IMAGPART(Z)' `COMPLEX(*)   `REAL(*)'     GNU extension
                   Z'                          


File: gfortran.info,  Node: AINT,  Next: ALARM,  Prev: AIMAG,  Up: Intrinsic Procedures

6.11 `AINT' -- Truncate to a whole number
=========================================

_Description_:
     `AINT(X [, KIND])' truncates its argument to a whole number.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = AINT(X [, KIND])'

_Arguments_:
     X          The type of the argument shall be `REAL(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     The return value is of type real with the kind type parameter of
     the argument if the optional KIND is absent; otherwise, the kind
     type parameter will be given by KIND.  If the magnitude of X is
     less than one, then `AINT(X)' returns zero.  If the magnitude is
     equal to or greater than one, then it returns the largest whole
     number that does not exceed its magnitude.  The sign is the same
     as the sign of X.

_Example_:
          program test_aint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, aint(x4), dint(x8)
            x8 = aint(x4,8)
          end program test_aint

_Specific names_:
     Name          Argument      Return type   Standard
     `DINT(X)'     `REAL(8) X'   `REAL(8)'     F77 and later


File: gfortran.info,  Node: ALARM,  Next: ALL,  Prev: AINT,  Up: Intrinsic Procedures

6.12 `ALARM' -- Execute a routine after a given delay
=====================================================

_Description_:
     `ALARM(SECONDS, HANDLER [, STATUS])' causes external subroutine
     HANDLER to be executed after a delay of SECONDS by using
     `alarm(2)' to set up a signal and `signal(2)' to catch it. If
     STATUS is supplied, it will be returned with the number of seconds
     remaining until any previously scheduled alarm was due to be
     delivered, or zero if there was no previously scheduled alarm.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL ALARM(SECONDS, HANDLER [, STATUS])'

_Arguments_:
     SECONDS    The type of the argument shall be a scalar
                `INTEGER'. It is `INTENT(IN)'.
     HANDLER    Signal handler (`INTEGER FUNCTION' or
                `SUBROUTINE') or dummy/global `INTEGER'
                scalar. The scalar values may be either
                `SIG_IGN=1' to ignore the alarm generated or
                `SIG_DFL=0' to set the default action. It is
                `INTENT(IN)'.
     STATUS     (Optional) STATUS shall be a scalar variable
                of the default `INTEGER' kind. It is
                `INTENT(OUT)'.

_Example_:
          program test_alarm
            external handler_print
            integer i
            call alarm (3, handler_print, i)
            print *, i
            call sleep(10)
          end program test_alarm
     This will cause the external routine HANDLER_PRINT to be called
     after 3 seconds.


File: gfortran.info,  Node: ALL,  Next: ALLOCATED,  Prev: ALARM,  Up: Intrinsic Procedures

6.13 `ALL' -- All values in MASK along DIM are true
===================================================

_Description_:
     `ALL(MASK [, DIM])' determines if all the values are true in MASK
     in the array along dimension DIM.

_Standard_:
     F95 and later

_Class_:
     transformational function

_Syntax_:
     `RESULT = ALL(MASK [, DIM])'

_Arguments_:
     MASK       The type of the argument shall be `LOGICAL(*)'
                and it shall not be scalar.
     DIM        (Optional) DIM shall be a scalar integer with
                a value that lies between one and the rank of
                MASK.

_Return value_:
     `ALL(MASK)' returns a scalar value of type `LOGICAL(*)' where the
     kind type parameter is the same as the kind type parameter of
     MASK.  If DIM is present, then `ALL(MASK, DIM)' returns an array
     with the rank of MASK minus 1.  The shape is determined from the
     shape of MASK where the DIM dimension is elided.

    (A)
          `ALL(MASK)' is true if all elements of MASK are true.  It
          also is true if MASK has zero size; otherwise, it is false.

    (B)
          If the rank of MASK is one, then `ALL(MASK,DIM)' is equivalent
          to `ALL(MASK)'.  If the rank is greater than one, then
          `ALL(MASK,DIM)' is determined by applying `ALL' to the array
          sections.

_Example_:
          program test_all
            logical l
            l = all((/.true., .true., .true./))
            print *, l
            call section
            contains
              subroutine section
                integer a(2,3), b(2,3)
                a = 1
                b = 1
                b(2,2) = 2
                print *, all(a .eq. b, 1)
                print *, all(a .eq. b, 2)
              end subroutine section
          end program test_all


File: gfortran.info,  Node: ALLOCATED,  Next: AND,  Prev: ALL,  Up: Intrinsic Procedures

6.14 `ALLOCATED' -- Status of an allocatable entity
===================================================

_Description_:
     `ALLOCATED(X)' checks the status of whether X is allocated.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = ALLOCATED(X)'

_Arguments_:
     X          The argument shall be an `ALLOCATABLE' array.

_Return value_:
     The return value is a scalar `LOGICAL' with the default logical
     kind type parameter.  If X is allocated, `ALLOCATED(X)' is
     `.TRUE.'; otherwise, it returns the `.TRUE.'

_Example_:
          program test_allocated
            integer :: i = 4
            real(4), allocatable :: x(:)
            if (allocated(x) .eqv. .false.) allocate(x(i))
          end program test_allocated


File: gfortran.info,  Node: AND,  Next: ANINT,  Prev: ALLOCATED,  Up: Intrinsic Procedures

6.15 `AND' -- Bitwise logical AND
=================================

_Description_:
     Bitwise logical `AND'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *Note IAND:: intrinsic defined by the Fortran
     standard.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = AND(I, J)'

_Arguments_:
     I          The type shall be either `INTEGER(*)' or
                `LOGICAL'.
     J          The type shall be either `INTEGER(*)' or
                `LOGICAL'.

_Return value_:
     The return type is either `INTEGER(*)' or `LOGICAL' after
     cross-promotion of the arguments.

_Example_:
          PROGRAM test_and
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) AND(T, T), AND(T, F), AND(F, T), AND(F, F)
            WRITE (*,*) AND(a, b)
          END PROGRAM

_See also_:
     F95 elemental function: *Note IAND::


File: gfortran.info,  Node: ANINT,  Next: ANY,  Prev: AND,  Up: Intrinsic Procedures

6.16 `ANINT' -- Nearest whole number
====================================

_Description_:
     `ANINT(X [, KIND])' rounds its argument to the nearest whole
     number.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ANINT(X [, KIND])'

_Arguments_:
     X          The type of the argument shall be `REAL(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     The return value is of type real with the kind type parameter of
     the argument if the optional KIND is absent; otherwise, the kind
     type parameter will be given by KIND.  If X is greater than zero,
     then `ANINT(X)' returns `AINT(X+0.5)'.  If X is less than or equal
     to zero, then it returns `AINT(X-0.5)'.

_Example_:
          program test_anint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, anint(x4), dnint(x8)
            x8 = anint(x4,8)
          end program test_anint

_Specific names_:
     Name          Argument      Return type   Standard
     `DNINT(X)'    `REAL(8) X'   `REAL(8)'     F77 and later


File: gfortran.info,  Node: ANY,  Next: ASIN,  Prev: ANINT,  Up: Intrinsic Procedures

6.17 `ANY' -- Any value in MASK along DIM is true
=================================================

_Description_:
     `ANY(MASK [, DIM])' determines if any of the values in the logical
     array MASK along dimension DIM are `.TRUE.'.

_Standard_:
     F95 and later

_Class_:
     transformational function

_Syntax_:
     `RESULT = ANY(MASK [, DIM])'

_Arguments_:
     MASK       The type of the argument shall be `LOGICAL(*)'
                and it shall not be scalar.
     DIM        (Optional) DIM shall be a scalar integer with
                a value that lies between one and the rank of
                MASK.

_Return value_:
     `ANY(MASK)' returns a scalar value of type `LOGICAL(*)' where the
     kind type parameter is the same as the kind type parameter of
     MASK.  If DIM is present, then `ANY(MASK, DIM)' returns an array
     with the rank of MASK minus 1.  The shape is determined from the
     shape of MASK where the DIM dimension is elided.

    (A)
          `ANY(MASK)' is true if any element of MASK is true;
          otherwise, it is false.  It also is false if MASK has zero
          size.

    (B)
          If the rank of MASK is one, then `ANY(MASK,DIM)' is equivalent
          to `ANY(MASK)'.  If the rank is greater than one, then
          `ANY(MASK,DIM)' is determined by applying `ANY' to the array
          sections.

_Example_:
          program test_any
            logical l
            l = any((/.true., .true., .true./))
            print *, l
            call section
            contains
              subroutine section
                integer a(2,3), b(2,3)
                a = 1
                b = 1
                b(2,2) = 2
                print *, any(a .eq. b, 1)
                print *, any(a .eq. b, 2)
              end subroutine section
          end program test_any


File: gfortran.info,  Node: ASIN,  Next: ASINH,  Prev: ANY,  Up: Intrinsic Procedures

6.18 `ASIN' -- Arcsine function
===============================

_Description_:
     `ASIN(X)' computes the arcsine of its X (inverse of `SIN(X)').

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ASIN(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and a magnitude
                that is less than one.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range
     -\pi / 2 \leq \asin (x) \leq \pi / 2.  The kind type parameter is
     the same as X.

_Example_:
          program test_asin
            real(8) :: x = 0.866_8
            x = asin(x)
          end program test_asin

_Specific names_:
     Name          Argument      Return type   Standard
     `DASIN(X)'    `REAL(8) X'   `REAL(8)'     F77 and later

_See also_:
     Inverse function: *Note SIN::



File: gfortran.info,  Node: ASINH,  Next: ASSOCIATED,  Prev: ASIN,  Up: Intrinsic Procedures

6.19 `ASINH' -- Hyperbolic arcsine function
===========================================

_Description_:
     `ASINH(X)' computes the hyperbolic arcsine of X (inverse of
     `SINH(X)').

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ASINH(X)'

_Arguments_:
     X          The type shall be `REAL(*)', with X a real
                number.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range
     -\infty \leq \asinh (x) \leq \infty.

_Example_:
          PROGRAM test_asinh
            REAL(8), DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)
            WRITE (*,*) ASINH(x)
          END PROGRAM

_Specific names_:
     Name          Argument      Return type   Standard
     `DASINH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension.

_See also_:
     Inverse function: *Note SINH::


File: gfortran.info,  Node: ASSOCIATED,  Next: ATAN,  Prev: ASINH,  Up: Intrinsic Procedures

6.20 `ASSOCIATED' -- Status of a pointer or pointer/target pair
===============================================================

_Description_:
     `ASSOCIATED(PTR [, TGT])' determines the status of the pointer PTR
     or if PTR is associated with the target TGT.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = ASSOCIATED(PTR [, TGT])'

_Arguments_:
     PTR        PTR shall have the `POINTER' attribute and it
                can be of any type.
     TGT        (Optional) TGT shall be a `POINTER' or a
                `TARGET'.  It must have the same type, kind
                type parameter, and array rank as PTR.
     The status of neither PTR nor TGT can be undefined.

_Return value_:
     `ASSOCIATED(PTR)' returns a scalar value of type `LOGICAL(4)'.
     There are several cases:
    (A) If the optional TGT is not present, then `ASSOCIATED(PTR)'
          is true if PTR is associated with a target; otherwise, it
          returns false.

    (B) If TGT is present and a scalar target, the result is true if
          TGT is not a 0 sized storage sequence and the target
          associated with PTR occupies the same storage units.  If PTR
          is disassociated, then the result is false.

    (C) If TGT is present and an array target, the result is true if
          TGT and PTR have the same shape, are not 0 sized arrays, are
          arrays whose elements are not 0 sized storage sequences, and
          TGT and PTR occupy the same storage units in array element
          order.  As in case(B), the result is false, if PTR is
          disassociated.

    (D) If TGT is present and an scalar pointer, the result is true if
          target associated with PTR and the target associated with TGT
          are not 0 sized storage sequences and occupy the same storage
          units.  The result is false, if either TGT or PTR is
          disassociated.

    (E) If TGT is present and an array pointer, the result is true if
          target associated with PTR and the target associated with TGT
          have the same shape, are not 0 sized arrays, are arrays whose
          elements are not 0 sized storage sequences, and TGT and PTR
          occupy the same storage units in array element order.  The
          result is false, if either TGT or PTR is disassociated.

_Example_:
          program test_associated
             implicit none
             real, target  :: tgt(2) = (/1., 2./)
             real, pointer :: ptr(:)
             ptr => tgt
             if (associated(ptr)     .eqv. .false.) call abort
             if (associated(ptr,tgt) .eqv. .false.) call abort
          end program test_associated

_See also_:
     *Note NULL::


File: gfortran.info,  Node: ATAN,  Next: ATAN2,  Prev: ASSOCIATED,  Up: Intrinsic Procedures

6.21 `ATAN' -- Arctangent function
==================================

_Description_:
     `ATAN(X)' computes the arctangent of X.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ATAN(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  -
     \pi / 2 \leq \atan (x) \leq \pi / 2.

_Example_:
          program test_atan
            real(8) :: x = 2.866_8
            x = atan(x)
          end program test_atan

_Specific names_:
     Name          Argument      Return type   Standard
     `DATAN(X)'    `REAL(8) X'   `REAL(8)'     F77 and later

_See also_:
     Inverse function: *Note TAN::



File: gfortran.info,  Node: ATAN2,  Next: ATANH,  Prev: ATAN,  Up: Intrinsic Procedures

6.22 `ATAN2' -- Arctangent function
===================================

_Description_:
     `ATAN2(Y,X)' computes the arctangent of the complex number X + i Y.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ATAN2(Y,X)'

_Arguments_:
     Y          The type shall be `REAL(*)'.
     X          The type and kind type parameter shall be the
                same as Y.  If Y is zero, then X must be
                nonzero.

_Return value_:
     The return value has the same type and kind type parameter as Y.
     It is the principal value of the complex number X + i Y.  If X is
     nonzero, then it lies in the range -\pi \le \atan (x) \leq \pi.
     The sign is positive if Y is positive.  If Y is zero, then the
     return value is zero if X is positive and \pi if X is negative.
     Finally, if X is zero, then the magnitude of the result is \pi/2.

_Example_:
          program test_atan2
            real(4) :: x = 1.e0_4, y = 0.5e0_4
            x = atan2(y,x)
          end program test_atan2

_Specific names_:
     Name          Argument      Return type   Standard
     `DATAN2(X)'   `REAL(8) X'   `REAL(8)'     F77 and later


File: gfortran.info,  Node: ATANH,  Next: BESJ0,  Prev: ATAN2,  Up: Intrinsic Procedures

6.23 `ATANH' -- Hyperbolic arctangent function
==============================================

_Description_:
     `ATANH(X)' computes the hyperbolic arctangent of X (inverse of
     `TANH(X)').

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ATANH(X)'

_Arguments_:
     X          The type shall be `REAL(*)' with a magnitude
                that is less than or equal to one.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range
     -\infty \leq \atanh(x) \leq \infty.

_Example_:
          PROGRAM test_atanh
            REAL, DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)
            WRITE (*,*) ATANH(x)
          END PROGRAM

_Specific names_:
     Name          Argument      Return type   Standard
     `DATANH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension

_See also_:
     Inverse function: *Note TANH::


File: gfortran.info,  Node: BESJ0,  Next: BESJ1,  Prev: ATANH,  Up: Intrinsic Procedures

6.24 `BESJ0' -- Bessel function of the first kind of order 0
============================================================

_Description_:
     `BESJ0(X)' computes the Bessel function of the first kind of order
     0 of X.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESJ0(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be
                scalar.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  -
     0.4027... \leq Bessel (0,x) \leq 1.

_Example_:
          program test_besj0
            real(8) :: x = 0.0_8
            x = besj0(x)
          end program test_besj0

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESJ0(X)'   `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: BESJ1,  Next: BESJN,  Prev: BESJ0,  Up: Intrinsic Procedures

6.25 `BESJ1' -- Bessel function of the first kind of order 1
============================================================

_Description_:
     `BESJ1(X)' computes the Bessel function of the first kind of order
     1 of X.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESJ1(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be
                scalar.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  -
     0.5818... \leq Bessel (0,x) \leq 0.5818 .

_Example_:
          program test_besj1
            real(8) :: x = 1.0_8
            x = besj1(x)
          end program test_besj1

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESJ1(X)'   `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: BESJN,  Next: BESY0,  Prev: BESJ1,  Up: Intrinsic Procedures

6.26 `BESJN' -- Bessel function of the first kind
=================================================

_Description_:
     `BESJN(N, X)' computes the Bessel function of the first kind of
     order N of X.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESJN(N, X)'

_Arguments_:
     N          The type shall be `INTEGER(*)', and it shall
                be scalar.
     X          The type shall be `REAL(*)', and it shall be
                scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)'.

_Example_:
          program test_besjn
            real(8) :: x = 1.0_8
            x = besjn(5,x)
          end program test_besjn

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESJN(X)'   `INTEGER(*)   `REAL(8)'     GNU extension
                   N'                          
                   `REAL(8) X'                 


File: gfortran.info,  Node: BESY0,  Next: BESY1,  Prev: BESJN,  Up: Intrinsic Procedures

6.27 `BESY0' -- Bessel function of the second kind of order 0
=============================================================

_Description_:
     `BESY0(X)' computes the Bessel function of the second kind of
     order 0 of X.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESY0(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be
                scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)'.

_Example_:
          program test_besy0
            real(8) :: x = 0.0_8
            x = besy0(x)
          end program test_besy0

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESY0(X)'   `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: BESY1,  Next: BESYN,  Prev: BESY0,  Up: Intrinsic Procedures

6.28 `BESY1' -- Bessel function of the second kind of order 1
=============================================================

_Description_:
     `BESY1(X)' computes the Bessel function of the second kind of
     order 1 of X.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESY1(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be
                scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)'.

_Example_:
          program test_besy1
            real(8) :: x = 1.0_8
            x = besy1(x)
          end program test_besy1

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESY1(X)'   `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: BESYN,  Next: BIT_SIZE,  Prev: BESY1,  Up: Intrinsic Procedures

6.29 `BESYN' -- Bessel function of the second kind
==================================================

_Description_:
     `BESYN(N, X)' computes the Bessel function of the second kind of
     order N of X.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESYN(N, X)'

_Arguments_:
     N          The type shall be `INTEGER(*)', and it shall
                be scalar.
     X          The type shall be `REAL(*)', and it shall be
                scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)'.

_Example_:
          program test_besyn
            real(8) :: x = 1.0_8
            x = besyn(5,x)
          end program test_besyn

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESYN(N,X)' `INTEGER(*)   `REAL(8)'     GNU extension
                   N'                          
                   `REAL(8)                    
                   X'                          


File: gfortran.info,  Node: BIT_SIZE,  Next: BTEST,  Prev: BESYN,  Up: Intrinsic Procedures

6.30 `BIT_SIZE' -- Bit size inquiry function
============================================

_Description_:
     `BIT_SIZE(I)' returns the number of bits (integer precision plus
     sign bit) represented by the type of I.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = BIT_SIZE(I)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)'

_Example_:
          program test_bit_size
              integer :: i = 123
              integer :: size
              size = bit_size(i)
              print *, size
          end program test_bit_size


File: gfortran.info,  Node: BTEST,  Next: CEILING,  Prev: BIT_SIZE,  Up: Intrinsic Procedures

6.31 `BTEST' -- Bit test function
=================================

_Description_:
     `BTEST(I,POS)' returns logical `.TRUE.' if the bit at POS in I is
     set.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BTEST(I, POS)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     POS        The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `LOGICAL'

_Example_:
          program test_btest
              integer :: i = 32768 + 1024 + 64
              integer :: pos
              logical :: bool
              do pos=0,16
                  bool = btest(i, pos)
                  print *, pos, bool
              end do
          end program test_btest


File: gfortran.info,  Node: CEILING,  Next: CHAR,  Prev: BTEST,  Up: Intrinsic Procedures

6.32 `CEILING' -- Integer ceiling function
==========================================

_Description_:
     `CEILING(X)' returns the least integer greater than or equal to X.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = CEILING(X [, KIND])'

_Arguments_:
     X          The type shall be `REAL(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     The return value is of type `INTEGER(KIND)'

_Example_:
          program test_ceiling
              real :: x = 63.29
              real :: y = -63.59
              print *, ceiling(x) ! returns 64
              print *, ceiling(y) ! returns -63
          end program test_ceiling

_See also_:
     *Note FLOOR::, *Note NINT::



File: gfortran.info,  Node: CHAR,  Next: CHDIR,  Prev: CEILING,  Up: Intrinsic Procedures

6.33 `CHAR' -- Character conversion function
============================================

_Description_:
     `CHAR(I [, KIND])' returns the character represented by the
     integer I.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = CHAR(I [, KIND])'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     The return value is of type `CHARACTER(1)'

_Example_:
          program test_char
              integer :: i = 74
              character(1) :: c
              c = char(i)
              print *, i, c ! returns 'J'
          end program test_char

_Note_:
     See *Note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *Note ACHAR::, *Note IACHAR::, *Note ICHAR::



File: gfortran.info,  Node: CHDIR,  Next: CHMOD,  Prev: CHAR,  Up: Intrinsic Procedures

6.34 `CHDIR' -- Change working directory
========================================

_Description_:
     Change current working directory to a specified path.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL CHDIR(NAME [, STATUS])'
     `STATUS = CHDIR(NAME)'

_Arguments_:
     NAME       The type shall be `CHARACTER(*)' and shall
                                   specify a valid path
                within the file system.
     STATUS     (Optional) `INTEGER' status flag of the default
                                       kind.  Returns 0 on
                success, and a system specific
                       and non-zero error code otherwise.

_Example_:
          PROGRAM test_chdir
            CHARACTER(len=255) :: path
            CALL getcwd(path)
            WRITE(*,*) TRIM(path)
            CALL chdir("/tmp")
            CALL getcwd(path)
            WRITE(*,*) TRIM(path)
          END PROGRAM

_See also_:
     *Note GETCWD::


File: gfortran.info,  Node: CHMOD,  Next: CMPLX,  Prev: CHDIR,  Up: Intrinsic Procedures

6.35 `CHMOD' -- Change access permissions of files
==================================================

_Description_:
     `CHMOD' changes the permissions of a file. This function invokes
     `/bin/chmod' and might therefore not work on all platforms.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL CHMOD(NAME, MODE[, STATUS])'
     `STATUS = CHMOD(NAME, MODE)'

_Arguments_:
     NAME       Scalar `CHARACTER' with the file name.
                Trailing blanks are ignored unless the
                character `achar(0)' is present, then all
                characters up to and excluding `achar(0)' are
                used as the file name.
     MODE       Scalar `CHARACTER' giving the file permission.
                MODE uses the same syntax as the MODE argument
                of `/bin/chmod'.
     STATUS     (optional) scalar `INTEGER', which is `0' on
                success and non-zero otherwise.

_Return value_:
     In either syntax, STATUS is set to `0' on success and non-zero
     otherwise.

_Example_:
     `CHMOD' as subroutine
          program chmod_test
            implicit none
            integer :: status
            call chmod('test.dat','u+x',status)
            print *, 'Status: ', status
          end program chmod_test
     `CHMOD' as non-elemental function:
          program chmod_test
            implicit none
            integer :: status
            status = chmod('test.dat','u+x')
            print *, 'Status: ', status
          end program chmod_test



File: gfortran.info,  Node: CMPLX,  Next: COMMAND_ARGUMENT_COUNT,  Prev: CHMOD,  Up: Intrinsic Procedures

6.36 `CMPLX' -- Complex conversion function
===========================================

_Description_:
     `CMPLX(X [, Y [, KIND]])' returns a complex number where X is
     converted to the real component.  If Y is present it is converted
     to the imaginary component.  If Y is not present then the
     imaginary component is set to 0.0.  If X is complex then Y must
     not be present.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = CMPLX(X [, Y [, KIND]])'

_Arguments_:
     X          The type may be `INTEGER(*)', `REAL(*)',
                            or `COMPLEX(*)'.
     Y          (Optional; only allowed if X is not
                       `COMPLEX(*)'.)  May be `INTEGER(*)'
                  or `REAL(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     The return value is of `COMPLEX' type, with a kind equal to KIND
     if it is specified.  If KIND is not specified, the result is of
     the default `COMPLEX' kind, regardless of the kinds of X and Y.

_Example_:
          program test_cmplx
              integer :: i = 42
              real :: x = 3.14
              complex :: z
              z = cmplx(i, x)
              print *, z, cmplx(x)
          end program test_cmplx

_See also_:
     *Note COMPLEX::


File: gfortran.info,  Node: COMMAND_ARGUMENT_COUNT,  Next: COMPLEX,  Prev: CMPLX,  Up: Intrinsic Procedures

6.37 `COMMAND_ARGUMENT_COUNT' -- Get number of command line arguments
=====================================================================

_Description_:
     `COMMAND_ARGUMENT_COUNT()' returns the number of arguments passed
     on the command line when the containing program was invoked.

_Standard_:
     F2003

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = COMMAND_ARGUMENT_COUNT()'

_Arguments_:
     None       

_Return value_:
     The return value is of type `INTEGER(4)'

_Example_:
          program test_command_argument_count
              integer :: count
              count = command_argument_count()
              print *, count
          end program test_command_argument_count

_See also_:
     *Note GET_COMMAND::, *Note GET_COMMAND_ARGUMENT::


File: gfortran.info,  Node: COMPLEX,  Next: CONJG,  Prev: COMMAND_ARGUMENT_COUNT,  Up: Intrinsic Procedures

6.38 `COMPLEX' -- Complex conversion function
=============================================

_Description_:
     `COMPLEX(X, Y)' returns a complex number where X is converted to
     the real component and Y is converted to the imaginary component.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = COMPLEX(X, Y)'

_Arguments_:
     X          The type may be `INTEGER(*)' or `REAL(*)'.
     Y          The type may be `INTEGER(*)' or `REAL(*)'.

_Return value_:
     If X and Y are both of `INTEGER' type, then the return value is of
     default `COMPLEX' type.

     If X and Y are of `REAL' type, or one is of `REAL' type and one is
     of `INTEGER' type, then the return value is of `COMPLEX' type with
     a kind equal to that of the `REAL' argument with the highest
     precision.

_Example_:
          program test_complex
              integer :: i = 42
              real :: x = 3.14
              print *, complex(i, x)
          end program test_complex

_See also_:
     *Note CMPLX::


File: gfortran.info,  Node: CONJG,  Next: COS,  Prev: COMPLEX,  Up: Intrinsic Procedures

6.39 `CONJG' -- Complex conjugate function
==========================================

_Description_:
     `CONJG(Z)' returns the conjugate of Z.  If Z is `(x, y)' then the
     result is `(x, -y)'

_Standard_:
     F77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `Z = CONJG(Z)'

_Arguments_:
     Z          The type shall be `COMPLEX(*)'.

_Return value_:
     The return value is of type `COMPLEX(*)'.

_Example_:
          program test_conjg
              complex :: z = (2.0, 3.0)
              complex(8) :: dz = (2.71_8, -3.14_8)
              z= conjg(z)
              print *, z
              dz = dconjg(dz)
              print *, dz
          end program test_conjg

_Specific names_:
     Name          Argument      Return type   Standard
     `DCONJG(Z)'   `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   Z'                          


File: gfortran.info,  Node: COS,  Next: COSH,  Prev: CONJG,  Up: Intrinsic Procedures

6.40 `COS' -- Cosine function
=============================

_Description_:
     `COS(X)' computes the cosine of X.

_Standard_:
     F77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `RESULT = COS(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value is of type `REAL(*)' and it lies in the range  -1
     \leq \cos (x) \leq 1.  The kind type parameter is the same as X.

_Example_:
          program test_cos
            real :: x = 0.0
            x = cos(x)
          end program test_cos

_Specific names_:
     Name          Argument      Return type   Standard
     `DCOS(X)'     `REAL(8) X'   `REAL(8)'     F77 and later
     `CCOS(X)'     `COMPLEX(4)   `COMPLEX(4)'  F77 and later
                   X'                          
     `ZCOS(X)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          
     `CDCOS(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          

_See also_:
     Inverse function: *Note ACOS::



File: gfortran.info,  Node: COSH,  Next: COUNT,  Prev: COS,  Up: Intrinsic Procedures

6.41 `COSH' -- Hyperbolic cosine function
=========================================

_Description_:
     `COSH(X)' computes the hyperbolic cosine of X.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `X = COSH(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)' and it is positive ( \cosh
     (x) \geq 0 .

_Example_:
          program test_cosh
            real(8) :: x = 1.0_8
            x = cosh(x)
          end program test_cosh

_Specific names_:
     Name          Argument      Return type   Standard
     `DCOSH(X)'    `REAL(8) X'   `REAL(8)'     F77 and later

_See also_:
     Inverse function: *Note ACOSH::



File: gfortran.info,  Node: COUNT,  Next: CPU_TIME,  Prev: COSH,  Up: Intrinsic Procedures

6.42 `COUNT' -- Count function
==============================

_Description_:
     `COUNT(MASK [, DIM])' counts the number of `.TRUE.' elements of
     MASK along the dimension of DIM.  If DIM is omitted it is taken to
     be `1'.  DIM is a scaler of type `INTEGER' in the range of 1 /leq
     DIM /leq n) where n is the rank of MASK.

_Standard_:
     F95 and later

_Class_:
     transformational function

_Syntax_:
     `RESULT = COUNT(MASK [, DIM])'

_Arguments_:
     MASK       The type shall be `LOGICAL'.
     DIM        The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER' with rank equal to that of
     MASK.

_Example_:
          program test_count
              integer, dimension(2,3) :: a, b
              logical, dimension(2,3) :: mask
              a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))
              b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print *
              print '(3i3)', b(1,:)
              print '(3i3)', b(2,:)
              print *
              mask = a.ne.b
              print '(3l3)', mask(1,:)
              print '(3l3)', mask(2,:)
              print *
              print '(3i3)', count(mask)
              print *
              print '(3i3)', count(mask, 1)
              print *
              print '(3i3)', count(mask, 2)
          end program test_count


File: gfortran.info,  Node: CPU_TIME,  Next: CSHIFT,  Prev: COUNT,  Up: Intrinsic Procedures

6.43 `CPU_TIME' -- CPU elapsed time in seconds
==============================================

_Description_:
     Returns a `REAL(*)' value representing the elapsed CPU time in
     seconds.  This is useful for testing segments of code to determine
     execution time.

_Standard_:
     F95 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL CPU_TIME(TIME)'

_Arguments_:
     TIME       The type shall be `REAL(*)' with `INTENT(OUT)'.

_Return value_:
     None

_Example_:
          program test_cpu_time
              real :: start, finish
              call cpu_time(start)
                  ! put code to test here
              call cpu_time(finish)
              print '("Time = ",f6.3," seconds.")',finish-start
          end program test_cpu_time

_See also_:
     *Note SYSTEM_CLOCK::, *Note DATE_AND_TIME::


File: gfortran.info,  Node: CSHIFT,  Next: CTIME,  Prev: CPU_TIME,  Up: Intrinsic Procedures

6.44 `CSHIFT' -- Circular shift elements of an array
====================================================

_Description_:
     `CSHIFT(ARRAY, SHIFT [, DIM])' performs a circular shift on
     elements of ARRAY along the dimension of DIM.  If DIM is omitted
     it is taken to be `1'.  DIM is a scaler of type `INTEGER' in the
     range of 1 /leq DIM /leq n) where n is the rank of ARRAY.  If the
     rank of ARRAY is one, then all elements of ARRAY are shifted by
     SHIFT places.  If rank is greater than one, then all complete rank
     one sections of ARRAY along the given dimension are shifted.
     Elements shifted out one end of each rank one section are shifted
     back in the other end.

_Standard_:
     F95 and later

_Class_:
     transformational function

_Syntax_:
     `RESULT = CSHIFT(A, SHIFT [, DIM])'

_Arguments_:
     ARRAY      May be any type, not scaler.
     SHIFT      The type shall be `INTEGER'.
     DIM        The type shall be `INTEGER'.

_Return value_:
     Returns an array of same type and rank as the ARRAY argument.

_Example_:
          program test_cshift
              integer, dimension(3,3) :: a
              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
              a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)
              print *
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
          end program test_cshift


File: gfortran.info,  Node: CTIME,  Next: DATE_AND_TIME,  Prev: CSHIFT,  Up: Intrinsic Procedures

6.45 `CTIME' -- Convert a time into a string
============================================

_Description_:
     `CTIME' converts a system time value, such as returned by
     `TIME8()', to a string of the form `Sat Aug 19 18:13:14 1995'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL CTIME(TIME, RESULT)'.
     `RESULT = CTIME(TIME)', (not recommended).

_Arguments_:
     TIME       The type shall be of type `INTEGER(KIND=8)'.
     RESULT     The type shall be of type `CHARACTER'.

_Return value_:
     The converted date and time as a string.

_Example_:
          program test_ctime
              integer(8) :: i
              character(len=30) :: date
              i = time8()

              ! Do something, main part of the program

              call ctime(i,date)
              print *, 'Program was started on ', date
          end program test_ctime

_See Also_:
     *Note GMTIME::, *Note LTIME::, *Note TIME::, *Note TIME8::


File: gfortran.info,  Node: DATE_AND_TIME,  Next: DBLE,  Prev: CTIME,  Up: Intrinsic Procedures

6.46 `DATE_AND_TIME' -- Date and time subroutine
================================================

_Description_:
     `DATE_AND_TIME(DATE, TIME, ZONE, VALUES)' gets the corresponding
     date and time information from the real-time system clock.  DATE is
     `INTENT(OUT)' and has form ccyymmdd.  TIME is `INTENT(OUT)' and
     has form hhmmss.sss.  ZONE is `INTENT(OUT)' and has form (+-)hhmm,
     representing the difference with respect to Coordinated Universal
     Time (UTC).  Unavailable time and date parameters return blanks.

     VALUES is `INTENT(OUT)' and provides the following:

                `VALUE(1)':          The year
                `VALUE(2)':          The month
                `VALUE(3)':          The day of the month
                `VALUE(4)':          Time difference with UTC
                                     in minutes
                `VALUE(5)':          The hour of the day
                `VALUE(6)':          The minutes of the hour
                `VALUE(7)':          The seconds of the minute
                `VALUE(8)':          The milliseconds of the
                                     second

_Standard_:
     F95 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL DATE_AND_TIME([DATE, TIME, ZONE, VALUES])'

_Arguments_:
     DATE       (Optional) The type shall be `CHARACTER(8)' or
                larger.
     TIME       (Optional) The type shall be `CHARACTER(10)'
                or larger.
     ZONE       (Optional) The type shall be `CHARACTER(5)' or
                larger.
     VALUES     (Optional) The type shall be `INTEGER(8)'.

_Return value_:
     None

_Example_:
          program test_time_and_date
              character(8)  :: date
              character(10) :: time
              character(5)  :: zone
              integer,dimension(8) :: values
              ! using keyword arguments
              call date_and_time(date,time,zone,values)
              call date_and_time(DATE=date,ZONE=zone)
              call date_and_time(TIME=time)
              call date_and_time(VALUES=values)
              print '(a,2x,a,2x,a)', date, time, zone
              print '(8i5))', values
          end program test_time_and_date

_See also_:
     *Note CPU_TIME::, *Note SYSTEM_CLOCK::


File: gfortran.info,  Node: DBLE,  Next: DCMPLX,  Prev: DATE_AND_TIME,  Up: Intrinsic Procedures

6.47 `DBLE' -- Double conversion function
=========================================

_Description_:
     `DBLE(X)' Converts X to double precision real type.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DBLE(X)'

_Arguments_:
     X          The type shall be `INTEGER(*)', `REAL(*)',
                              or `COMPLEX(*)'.

_Return value_:
     The return value is of type double precision real.

_Example_:
          program test_dble
              real    :: x = 2.18
              integer :: i = 5
              complex :: z = (2.3,1.14)
              print *, dble(x), dble(i), dble(z)
          end program test_dble

_See also_:
     *Note DFLOAT::, *Note FLOAT::, *Note REAL::


File: gfortran.info,  Node: DCMPLX,  Next: DFLOAT,  Prev: DBLE,  Up: Intrinsic Procedures

6.48 `DCMPLX' -- Double complex conversion function
===================================================

_Description_:
     `DCMPLX(X [,Y])' returns a double complex number where X is
     converted to the real component.  If Y is present it is converted
     to the imaginary component.  If Y is not present then the
     imaginary component is set to 0.0.  If X is complex then Y must
     not be present.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DCMPLX(X [, Y])'

_Arguments_:
     X          The type may be `INTEGER(*)', `REAL(*)',
                            or `COMPLEX(*)'.
     Y          (Optional if X is not `COMPLEX(*)'.) May be
                               `INTEGER(*)' or `REAL(*)'.

_Return value_:
     The return value is of type `COMPLEX(8)'

_Example_:
          program test_dcmplx
              integer :: i = 42
              real :: x = 3.14
              complex :: z
              z = cmplx(i, x)
              print *, dcmplx(i)
              print *, dcmplx(x)
              print *, dcmplx(z)
              print *, dcmplx(x,i)
          end program test_dcmplx


File: gfortran.info,  Node: DFLOAT,  Next: DIGITS,  Prev: DCMPLX,  Up: Intrinsic Procedures

6.49 `DFLOAT' -- Double conversion function
===========================================

_Description_:
     `DFLOAT(X)' Converts X to double precision real type.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DFLOAT(X)'

_Arguments_:
     X          The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type double precision real.

_Example_:
          program test_dfloat
              integer :: i = 5
              print *, dfloat(i)
          end program test_dfloat

_See also_:
     *Note DBLE::, *Note FLOAT::, *Note REAL::


File: gfortran.info,  Node: DIGITS,  Next: DIM,  Prev: DFLOAT,  Up: Intrinsic Procedures

6.50 `DIGITS' -- Significant digits function
============================================

_Description_:
     `DIGITS(X)' returns the number of significant digits of the
     internal model representation of X.  For example, on a system
     using a 32-bit floating point representation, a default real
     number would likely return 24.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = DIGITS(X)'

_Arguments_:
     X          The type may be `INTEGER(*)' or `REAL(*)'.

_Return value_:
     The return value is of type `INTEGER'.

_Example_:
          program test_digits
              integer :: i = 12345
              real :: x = 3.143
              real(8) :: y = 2.33
              print *, digits(i)
              print *, digits(x)
              print *, digits(y)
          end program test_digits


File: gfortran.info,  Node: DIM,  Next: DOT_PRODUCT,  Prev: DIGITS,  Up: Intrinsic Procedures

6.51 `DIM' -- Positive difference
=================================

_Description_:
     `DIM(X,Y)' returns the difference `X-Y' if the result is positive;
     otherwise returns zero.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DIM(X, Y)'

_Arguments_:
     X          The type shall be `INTEGER(*)' or `REAL(*)'
     Y          The type shall be the same type and kind as X.

_Return value_:
     The return value is of type `INTEGER(*)' or `REAL(*)'.

_Example_:
          program test_dim
              integer :: i
              real(8) :: x
              i = dim(4, 15)
              x = dim(4.345_8, 2.111_8)
              print *, i
              print *, x
          end program test_dim

_Specific names_:
     Name          Argument      Return type   Standard
     `IDIM(X,Y)'   `INTEGER(4)   `INTEGER(4)'  F77 and later
                   X,Y'                        
     `DDIM(X,Y)'   `REAL(8)      `REAL(8)'     F77 and later
                   X,Y'                        


File: gfortran.info,  Node: DOT_PRODUCT,  Next: DPROD,  Prev: DIM,  Up: Intrinsic Procedures

6.52 `DOT_PRODUCT' -- Dot product function
==========================================

_Description_:
     `DOT_PRODUCT(X,Y)' computes the dot product multiplication of two
     vectors X and Y.  The two vectors may be either numeric or logical
     and must be arrays of rank one and of equal size. If the vectors
     are `INTEGER(*)' or `REAL(*)', the result is `SUM(X*Y)'. If the
     vectors are `COMPLEX(*)', the result is `SUM(CONJG(X)*Y)'. If the
     vectors are `LOGICAL', the result is `ANY(X.AND.Y)'.

_Standard_:
     F95 and later

_Class_:
     transformational function

_Syntax_:
     `RESULT = DOT_PRODUCT(X, Y)'

_Arguments_:
     X          The type shall be numeric or `LOGICAL', rank 1.
     Y          The type shall be numeric or `LOGICAL', rank 1.

_Return value_:
     If the arguments are numeric, the return value is a scaler of
     numeric type, `INTEGER(*)', `REAL(*)', or `COMPLEX(*)'.  If the
     arguments are `LOGICAL', the return value is `.TRUE.' or `.FALSE.'.

_Example_:
          program test_dot_prod
              integer, dimension(3) :: a, b
              a = (/ 1, 2, 3 /)
              b = (/ 4, 5, 6 /)
              print '(3i3)', a
              print *
              print '(3i3)', b
              print *
              print *, dot_product(a,b)
          end program test_dot_prod


File: gfortran.info,  Node: DPROD,  Next: DREAL,  Prev: DOT_PRODUCT,  Up: Intrinsic Procedures

6.53 `DPROD' -- Double product function
=======================================

_Description_:
     `DPROD(X,Y)' returns the product `X*Y'.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DPROD(X, Y)'

_Arguments_:
     X          The type shall be `REAL'.
     Y          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL(8)'.

_Example_:
          program test_dprod
              real :: x = 5.2
              real :: y = 2.3
              real(8) :: d
              d = dprod(x,y)
              print *, d
          end program test_dprod


File: gfortran.info,  Node: DREAL,  Next: DTIME,  Prev: DPROD,  Up: Intrinsic Procedures

6.54 `DREAL' -- Double real part function
=========================================

_Description_:
     `DREAL(Z)' returns the real part of complex variable Z.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DREAL(Z)'

_Arguments_:
     Z          The type shall be `COMPLEX(8)'.

_Return value_:
     The return value is of type `REAL(8)'.

_Example_:
          program test_dreal
              complex(8) :: z = (1.3_8,7.2_8)
              print *, dreal(z)
          end program test_dreal

_See also_:
     *Note AIMAG::



File: gfortran.info,  Node: DTIME,  Next: EOSHIFT,  Prev: DREAL,  Up: Intrinsic Procedures

6.55 `DTIME' -- Execution time subroutine (or function)
=======================================================

_Description_:
     `DTIME(TARRAY, RESULT)' initially returns the number of seconds of
     runtime since the start of the process's execution in RESULT.
     TARRAY returns the user and system components of this time in
     `TARRAY(1)' and `TARRAY(2)' respectively. RESULT is equal to
     `TARRAY(1) + TARRAY(2)'.

     Subsequent invocations of `DTIME' return values accumulated since
     the previous invocation.

     On some systems, the underlying timings are represented using
     types with sufficiently small limits that overflows (wrap around)
     are possible, such as 32-bit types. Therefore, the values returned
     by this intrinsic might be, or become, negative, or numerically
     less than previous values, during a single run of the compiled
     program.

     If `DTIME' is invoked as a function, it can not be invoked as a
     subroutine, and vice versa.

     TARRAY and RESULT are `INTENT(OUT)' and provide the following:

                `TARRAY(1)':         User time in seconds.
                `TARRAY(2)':         System time in seconds.
                `RESULT':            Run time since start in
                                     seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL DTIME(TARRAY, RESULT)'.
     `RESULT = DTIME(TARRAY)', (not recommended).

_Arguments_:
     TARRAY     The type shall be `REAL, DIMENSION(2)'.
     RESULT     The type shall be `REAL'.

_Return value_:
     Elapsed time in seconds since the start of program execution.

_Example_:
          program test_dtime
              integer(8) :: i, j
              real, dimension(2) :: tarray
              real :: result
              call dtime(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
              do i=1,100000000    ! Just a delay
                  j = i * i - i
              end do
              call dtime(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
          end program test_dtime


File: gfortran.info,  Node: EOSHIFT,  Next: EPSILON,  Prev: DTIME,  Up: Intrinsic Procedures

6.56 `EOSHIFT' -- End-off shift elements of an array
====================================================

_Description_:
     `EOSHIFT(ARRAY, SHIFT[,BOUNDARY, DIM])' performs an end-off shift
     on elements of ARRAY along the dimension of DIM.  If DIM is
     omitted it is taken to be `1'.  DIM is a scaler of type `INTEGER'
     in the range of 1 /leq DIM /leq n) where n is the rank of ARRAY.
     If the rank of ARRAY is one, then all elements of ARRAY are
     shifted by SHIFT places.  If rank is greater than one, then all
     complete rank one sections of ARRAY along the given dimension are
     shifted.  Elements shifted out one end of each rank one section
     are dropped.  If BOUNDARY is present then the corresponding value
     of from BOUNDARY is copied back in the other end.  If BOUNDARY is
     not present then the following are copied in depending on the type
     of ARRAY.

     _Array     _Boundary Value_
     Type_      
     Numeric    0 of the type and kind of ARRAY.
     Logical    `.FALSE.'.
     Character(LEN)LEN blanks.

_Standard_:
     F95 and later

_Class_:
     transformational function

_Syntax_:
     `RESULT = EOSHIFT(A, SHIFT [, BOUNDARY, DIM])'

_Arguments_:
     ARRAY      May be any type, not scaler.
     SHIFT      The type shall be `INTEGER'.
     BOUNDARY   Same type as ARRAY.
     DIM        The type shall be `INTEGER'.

_Return value_:
     Returns an array of same type and rank as the ARRAY argument.

_Example_:
          program test_eoshift
              integer, dimension(3,3) :: a
              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
              a = EOSHIFT(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)
              print *
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
          end program test_eoshift


File: gfortran.info,  Node: EPSILON,  Next: ERF,  Prev: EOSHIFT,  Up: Intrinsic Procedures

6.57 `EPSILON' -- Epsilon function
==================================

_Description_:
     `EPSILON(X)' returns a nearly negligible number relative to `1'.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = EPSILON(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of same type as the argument.

_Example_:
          program test_epsilon
              real :: x = 3.143
              real(8) :: y = 2.33
              print *, EPSILON(x)
              print *, EPSILON(y)
          end program test_epsilon


File: gfortran.info,  Node: ERF,  Next: ERFC,  Prev: EPSILON,  Up: Intrinsic Procedures

6.58 `ERF' -- Error function
============================

_Description_:
     `ERF(X)' computes the error function of X.

_Standard_:
     GNU Extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ERF(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be
                scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)' and it is positive
     ( - 1 \leq erf (x) \leq 1 .

_Example_:
          program test_erf
            real(8) :: x = 0.17_8
            x = erf(x)
          end program test_erf

_Specific names_:
     Name          Argument      Return type   Standard
     `DERF(X)'     `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: ERFC,  Next: ETIME,  Prev: ERF,  Up: Intrinsic Procedures

6.59 `ERFC' -- Error function
=============================

_Description_:
     `ERFC(X)' computes the complementary error function of X.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ERFC(X)'

_Arguments_:
     X          The type shall be `REAL(*)', and it shall be
                scalar.

_Return value_:
     The return value is a scalar of type `REAL(*)' and it is positive
     ( 0 \leq erfc (x) \leq 2 .

_Example_:
          program test_erfc
            real(8) :: x = 0.17_8
            x = erfc(x)
          end program test_erfc

_Specific names_:
     Name          Argument      Return type   Standard
     `DERFC(X)'    `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: ETIME,  Next: EXIT,  Prev: ERFC,  Up: Intrinsic Procedures

6.60 `ETIME' -- Execution time subroutine (or function)
=======================================================

_Description_:
     `ETIME(TARRAY, RESULT)' returns the number of seconds of runtime
     since the start of the process's execution in RESULT.  TARRAY
     returns the user and system components of this time in `TARRAY(1)'
     and `TARRAY(2)' respectively. RESULT is equal to `TARRAY(1) +
     TARRAY(2)'.

     On some systems, the underlying timings are represented using
     types with sufficiently small limits that overflows (wrap around)
     are possible, such as 32-bit types. Therefore, the values returned
     by this intrinsic might be, or become, negative, or numerically
     less than previous values, during a single run of the compiled
     program.

     If `ETIME' is invoked as a function, it can not be invoked as a
     subroutine, and vice versa.

     TARRAY and RESULT are `INTENT(OUT)' and provide the following:

                `TARRAY(1)':         User time in seconds.
                `TARRAY(2)':         System time in seconds.
                `RESULT':            Run time since start in seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL ETIME(TARRAY, RESULT)'.
     `RESULT = ETIME(TARRAY)', (not recommended).

_Arguments_:
     TARRAY     The type shall be `REAL, DIMENSION(2)'.
     RESULT     The type shall be `REAL'.

_Return value_:
     Elapsed time in seconds since the start of program execution.

_Example_:
          program test_etime
              integer(8) :: i, j
              real, dimension(2) :: tarray
              real :: result
              call ETIME(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
              do i=1,100000000    ! Just a delay
                  j = i * i - i
              end do
              call ETIME(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
          end program test_etime

_See also_:
     *Note CPU_TIME::



File: gfortran.info,  Node: EXIT,  Next: EXP,  Prev: ETIME,  Up: Intrinsic Procedures

6.61 `EXIT' -- Exit the program with status.
============================================

_Description_:
     `EXIT' causes immediate termination of the program with status.
     If status is omitted it returns the canonical _success_ for the
     system.  All Fortran I/O units are closed.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL EXIT([STATUS])'

_Arguments_:
     STATUS     Shall be an `INTEGER' of the default kind.

_Return value_:
     `STATUS' is passed to the parent process on exit.

_Example_:
          program test_exit
            integer :: STATUS = 0
            print *, 'This program is going to exit.'
            call EXIT(STATUS)
          end program test_exit

_See also_:
     *Note ABORT::, *Note KILL::


File: gfortran.info,  Node: EXP,  Next: EXPONENT,  Prev: EXIT,  Up: Intrinsic Procedures

6.62 `EXP' -- Exponential function
==================================

_Description_:
     `EXP(X)' computes the base e exponential of X.

_Standard_:
     F77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `RESULT = EXP(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          program test_exp
            real :: x = 1.0
            x = exp(x)
          end program test_exp

_Specific names_:
     Name          Argument      Return type   Standard
     `DEXP(X)'     `REAL(8) X'   `REAL(8)'     F77 and later
     `CEXP(X)'     `COMPLEX(4)   `COMPLEX(4)'  F77 and later
                   X'                          
     `ZEXP(X)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          
     `CDEXP(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          


File: gfortran.info,  Node: EXPONENT,  Next: FDATE,  Prev: EXP,  Up: Intrinsic Procedures

6.63 `EXPONENT' -- Exponent function
====================================

_Description_:
     `EXPONENT(X)' returns the value of the exponent part of X. If X is
     zero the value returned is zero.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = EXPONENT(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type default `INTEGER'.

_Example_:
          program test_exponent
            real :: x = 1.0
            integer :: i
            i = exponent(x)
            print *, i
            print *, exponent(0.0)
          end program test_exponent


File: gfortran.info,  Node: FDATE,  Next: FGET,  Prev: EXPONENT,  Up: Intrinsic Procedures

6.64 `FDATE' -- Get the current time as a string
================================================

_Description_:
     `FDATE(DATE)' returns the current date (using the same format as
     `CTIME') in DATE. It is equivalent to `CALL CTIME(DATE, TIME())'.

     If `FDATE' is invoked as a function, it can not be invoked as a
     subroutine, and vice versa.

     DATE is an `INTENT(OUT)' `CHARACTER' variable.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL FDATE(DATE)'.
     `DATE = FDATE()', (not recommended).

_Arguments_:
     DATE       The type shall be of type `CHARACTER'.

_Return value_:
     The current date as a string.

_Example_:
          program test_fdate
              integer(8) :: i, j
              character(len=30) :: date
              call fdate(date)
              print *, 'Program started on ', date
              do i = 1, 100000000 ! Just a delay
                  j = i * i - i
              end do
              call fdate(date)
              print *, 'Program ended on ', date
          end program test_fdate


File: gfortran.info,  Node: FLOAT,  Next: FLOOR,  Prev: FGETC,  Up: Intrinsic Procedures

6.65 `FLOAT' -- Convert integer to default real
===============================================

_Description_:
     `FLOAT(I)' converts the integer I to a default real value.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = FLOAT(I)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type default `REAL'.

_Example_:
          program test_float
              integer :: i = 1
              if (float(i) /= 1.) call abort
          end program test_float

_See also_:
     *Note DBLE::, *Note DFLOAT::, *Note REAL::


File: gfortran.info,  Node: FGET,  Next: FGETC,  Prev: FDATE,  Up: Intrinsic Procedures

6.66 `FGET' -- Read a single character in stream mode from stdin
================================================================

_Description_:
     Read a single character in stream mode from stdin by bypassing
     normal formatted output. Stream I/O should not be mixed with
     normal record-oriented (formatted or unformatted) I/O on the same
     unit; the results are unpredictable.

     This intrinsic routine is provided for backwards compatibility with
     `g77'.  GNU Fortran provides the Fortran 2003 Stream facility.
     Programmers should consider the use of new stream IO feature in
     new code for future portability. See also *Note Fortran 2003
     status::.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL FGET(C [, STATUS])'

_Arguments_:
     C          The type shall be `CHARACTER'.
     STATUS     (Optional) status flag of type `INTEGER'.
                                   Returns 0 on success, -1
                on end-of-file, and a
                system specific positive error code otherwise.

_Example_:
          PROGRAM test_fget
            INTEGER, PARAMETER :: strlen = 100
            INTEGER :: status, i = 1
            CHARACTER(len=strlen) :: str = ""

            WRITE (*,*) 'Enter text:'
            DO
              CALL fget(str(i:i), status)
              if (status /= 0 .OR. i > strlen) exit
              i = i + 1
            END DO
            WRITE (*,*) TRIM(str)
          END PROGRAM

_See also_:
     *Note FGETC::, *Note FPUT::, *Note FPUTC::


File: gfortran.info,  Node: FGETC,  Next: FLOAT,  Prev: FGET,  Up: Intrinsic Procedures

6.67 `FGETC' -- Read a single character in stream mode
======================================================

_Description_:
     Read a single character in stream mode by bypassing normal
     formatted output.  Stream I/O should not be mixed with normal
     record-oriented (formatted or unformatted) I/O on the same unit;
     the results are unpredictable.

     This intrinsic routine is provided for backwards compatibility with
     `g77'.  GNU Fortran provides the Fortran 2003 Stream facility.
     Programmers should consider the use of new stream IO feature in
     new code for future portability. See also *Note Fortran 2003
     status::.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL FGETC(UNIT, C [, STATUS])'

_Arguments_:
     UNIT       The type shall be `INTEGER'.
     C          The type shall be `CHARACTER'.
     STATUS     (Optional) status flag of type `INTEGER'.
                Returns 0 on success,
                -1 on end-of-file and a system specific
                positive error code otherwise.

_Example_:
          PROGRAM test_fgetc
            INTEGER :: fd = 42, status
            CHARACTER :: c

            OPEN(UNIT=fd, FILE="/etc/passwd", ACTION="READ", STATUS = "OLD")
            DO
              CALL fgetc(fd, c, status)
              IF (status /= 0) EXIT
              call fput(c)
            END DO
            CLOSE(UNIT=fd)
          END PROGRAM

_See also_:
     *Note FGET::, *Note FPUT::, *Note FPUTC::


File: gfortran.info,  Node: FLOOR,  Next: FLUSH,  Prev: FLOAT,  Up: Intrinsic Procedures

6.68 `FLOOR' -- Integer floor function
======================================

_Description_:
     `FLOOR(X)' returns the greatest integer less than or equal to X.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = FLOOR(X [, KIND])'

_Arguments_:
     X          The type shall be `REAL(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     The return value is of type `INTEGER(KIND)'

_Example_:
          program test_floor
              real :: x = 63.29
              real :: y = -63.59
              print *, floor(x) ! returns 63
              print *, floor(y) ! returns -64
          end program test_floor

_See also_:
     *Note CEILING::, *Note NINT::



File: gfortran.info,  Node: FLUSH,  Next: FNUM,  Prev: FLOOR,  Up: Intrinsic Procedures

6.69 `FLUSH' -- Flush I/O unit(s)
=================================

_Description_:
     Flushes Fortran unit(s) currently open for output. Without the
     optional argument, all units are flushed, otherwise just the unit
     specified.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL FLUSH(UNIT)'

_Arguments_:
     UNIT       (Optional) The type shall be `INTEGER'.

_Note_:
     Beginning with the Fortran 2003 standard, there is a `FLUSH'
     statement that should be preferred over the `FLUSH' intrinsic.



File: gfortran.info,  Node: FNUM,  Next: FPUT,  Prev: FLUSH,  Up: Intrinsic Procedures

6.70 `FNUM' -- File number function
===================================

_Description_:
     `FNUM(UNIT)' returns the POSIX file descriptor number
     corresponding to the open Fortran I/O unit `UNIT'.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = FNUM(UNIT)'

_Arguments_:
     UNIT       The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER'

_Example_:
          program test_fnum
            integer :: i
            open (unit=10, status = "scratch")
            i = fnum(10)
            print *, i
            close (10)
          end program test_fnum


File: gfortran.info,  Node: FPUT,  Next: FPUTC,  Prev: FNUM,  Up: Intrinsic Procedures

6.71 `FPUT' -- Write a single character in stream mode to stdout
================================================================

_Description_:
     Write a single character in stream mode to stdout by bypassing
     normal formatted output. Stream I/O should not be mixed with
     normal record-oriented (formatted or unformatted) I/O on the same
     unit; the results are unpredictable.

     This intrinsic routine is provided for backwards compatibility with
     `g77'.  GNU Fortran provides the Fortran 2003 Stream facility.
     Programmers should consider the use of new stream IO feature in
     new code for future portability. See also *Note Fortran 2003
     status::.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL FPUT(C [, STATUS])'

_Arguments_:
     C          The type shall be `CHARACTER'.
     STATUS     (Optional) status flag of type `INTEGER'.
                Returns 0 on success,
                -1 on end-of-file and a system specific
                positive error code otherwise.

_Example_:
          PROGRAM test_fput
            CHARACTER(len=10) :: str = "gfortran"
            INTEGER :: i
            DO i = 1, len_trim(str)
              CALL fput(str(i:i))
            END DO
          END PROGRAM

_See also_:
     *Note FPUTC::, *Note FGET::, *Note FGETC::


File: gfortran.info,  Node: FPUTC,  Next: FRACTION,  Prev: FPUT,  Up: Intrinsic Procedures

6.72 `FPUTC' -- Write a single character in stream mode
=======================================================

_Description_:
     Write a single character in stream mode by bypassing normal
     formatted output. Stream I/O should not be mixed with normal
     record-oriented (formatted or unformatted) I/O on the same unit;
     the results are unpredictable.

     This intrinsic routine is provided for backwards compatibility with
     `g77'.  GNU Fortran provides the Fortran 2003 Stream facility.
     Programmers should consider the use of new stream IO feature in
     new code for future portability. See also *Note Fortran 2003
     status::.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL FPUTC(UNIT, C [, STATUS])'

_Arguments_:
     UNIT       The type shall be `INTEGER'.
     C          The type shall be `CHARACTER'.
     STATUS     (Optional) status flag of type `INTEGER'.
                Returns 0 on success,
                -1 on end-of-file and a system specific
                positive error code otherwise.

_Example_:
          PROGRAM test_fputc
            CHARACTER(len=10) :: str = "gfortran"
            INTEGER :: fd = 42, i

            OPEN(UNIT = fd, FILE = "out", ACTION = "WRITE", STATUS="NEW")
            DO i = 1, len_trim(str)
              CALL fputc(fd, str(i:i))
            END DO
            CLOSE(fd)
          END PROGRAM

_See also_:
     *Note FPUT::, *Note FGET::, *Note FGETC::


File: gfortran.info,  Node: FRACTION,  Next: FREE,  Prev: FPUTC,  Up: Intrinsic Procedures

6.73 `FRACTION' -- Fractional part of the model representation
==============================================================

_Description_:
     `FRACTION(X)' returns the fractional part of the model
     representation of `X'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `Y = FRACTION(X)'

_Arguments_:
     X          The type of the argument shall be a `REAL'.

_Return value_:
     The return value is of the same type and kind as the argument.
     The fractional part of the model representation of `X' is returned;
     it is `X * RADIX(X)**(-EXPONENT(X))'.

_Example_:
          program test_fraction
            real :: x
            x = 178.1387e-4
            print *, fraction(x), x * radix(x)**(-exponent(x))
          end program test_fraction



File: gfortran.info,  Node: FREE,  Next: FSEEK,  Prev: FRACTION,  Up: Intrinsic Procedures

6.74 `FREE' -- Frees memory
===========================

_Description_:
     Frees memory previously allocated by `MALLOC()'. The `FREE'
     intrinsic is an extension intended to be used with Cray pointers,
     and is provided in GNU Fortran to allow user to compile legacy
     code. For new code using Fortran 95 pointers, the memory
     de-allocation intrinsic is `DEALLOCATE'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL FREE(PTR)'

_Arguments_:
     PTR        The type shall be `INTEGER'. It represents the
                location of the memory that should be
                de-allocated.

_Return value_:
     None

_Example_:
     See `MALLOC' for an example.

_See also_:
     *Note MALLOC::


File: gfortran.info,  Node: FSEEK,  Next: FSTAT,  Prev: FREE,  Up: Intrinsic Procedures

6.75 `FSEEK' -- Low level file positioning subroutine
=====================================================

Not yet implemented in GNU Fortran.

_Description_:

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:

_Arguments_:

_Return value_:

_Example_:

_Specific names_:

_See also_:
     g77 features lacking in gfortran
     (http://gcc.gnu.org/bugzilla/show_bug.cgi?id=19292)



File: gfortran.info,  Node: FSTAT,  Next: FTELL,  Prev: FSEEK,  Up: Intrinsic Procedures

6.76 `FSTAT' -- Get file status
===============================

_Description_:
     `FSTAT' is identical to *Note STAT::, except that information
     about an already opened file is obtained.

     The elements in `BUFF' are the same as described by *Note STAT::.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL FSTAT(UNIT, BUFF [, STATUS])'

_Arguments_:
     UNIT       An open I/O unit number of type `INTEGER'.
     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
     STATUS     (Optional) status flag of type `INTEGER(4)'.
                Returns 0                         on success
                and a system specific error code otherwise.

_Example_:
     See *Note STAT:: for an example.

_See also_:
     To stat a link: *Note LSTAT::, to stat a file: *Note STAT::


File: gfortran.info,  Node: FTELL,  Next: GERROR,  Prev: FSTAT,  Up: Intrinsic Procedures

6.77 `FTELL' -- Current stream position
=======================================

_Description_:
     Retrieves the current position within an open file.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL FTELL(UNIT, OFFSET)'
     `OFFSET = FTELL(UNIT)'

_Arguments_:
     OFFSET     Shall of type `INTEGER'.
     UNIT       Shall of type `INTEGER'.

_Return value_:
     In either syntax, OFFSET is set to the current offset of unit
     number UNIT, or to -1 if the unit is not currently open.

_Example_:
          PROGRAM test_ftell
            INTEGER :: i
            OPEN(10, FILE="temp.dat")
            CALL ftell(10,i)
            WRITE(*,*) i
          END PROGRAM

_See also_:
     *Note FSEEK::


File: gfortran.info,  Node: GERROR,  Next: GETARG,  Prev: FTELL,  Up: Intrinsic Procedures

6.78 `GERROR' -- Get last system error message
==============================================

_Description_:
     Returns the system error message corresponding to the last system
     error.  This resembles the functionality of `strerror(3)' in C.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GERROR(RESULT)'

_Arguments_:
     RESULT     Shall of type `CHARACTER(*)'.

_Example_:
          PROGRAM test_gerror
            CHARACTER(len=100) :: msg
            CALL gerror(msg)
            WRITE(*,*) msg
          END PROGRAM

_See also_:
     *Note IERRNO::, *Note PERROR::


File: gfortran.info,  Node: GETARG,  Next: GET_COMMAND,  Prev: GERROR,  Up: Intrinsic Procedures

6.79 `GETARG' -- Get command line arguments
===========================================

_Description_:
     Retrieve the Nth argument that was passed on the command line when
     the containing program was invoked.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *Note GET_COMMAND_ARGUMENT:: intrinsic defined by the
     Fortran 2003 standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GETARG(N, ARG)'

_Arguments_:
     N          Shall be of type `INTEGER(4)', N \geq 0
     ARG        Shall be of type `CHARACTER(*)'.

_Return value_:
     After `GETARG' returns, the ARG argument holds the Nth command
     line argument. If ARG can not hold the argument, it is truncated
     to fit the length of ARG. If there are less than N arguments
     specified at the command line, ARG will be filled with blanks.  If
     N = 0, ARG is set to the name of the program (on systems that
     support this feature).

_Example_:
          PROGRAM test_getarg
            INTEGER :: i
            CHARACTER(len=32) :: arg

            DO i = 1, iargc()
              CALL getarg(i, arg)
              WRITE (*,*) arg
            END DO
          END PROGRAM

_See also_:
     GNU Fortran 77 compatibility function: *Note IARGC::

     F2003 functions and subroutines: *Note GET_COMMAND::, *Note
     GET_COMMAND_ARGUMENT::, *Note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GET_COMMAND,  Next: GET_COMMAND_ARGUMENT,  Prev: GETARG,  Up: Intrinsic Procedures

6.80 `GET_COMMAND' -- Get the entire command line
=================================================

_Description_:
     Retrieve the entire command line that was used to invoke the
     program.

_Standard_:
     F2003

_Class_:
     Subroutine

_Syntax_:
     `CALL GET_COMMAND(CMD)'

_Arguments_:
     CMD        Shall be of type `CHARACTER(*)'.

_Return value_:
     Stores the entire command line that was used to invoke the program
     in ARG.  If ARG is not large enough, the command will be truncated.

_Example_:
          PROGRAM test_get_command
            CHARACTER(len=255) :: cmd
            CALL get_command(cmd)
            WRITE (*,*) TRIM(cmd)
          END PROGRAM

_See also_:
     *Note GET_COMMAND_ARGUMENT::, *Note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GET_COMMAND_ARGUMENT,  Next: GETCWD,  Prev: GET_COMMAND,  Up: Intrinsic Procedures

6.81 `GET_COMMAND_ARGUMENT' -- Get command line arguments
=========================================================

_Description_:
     Retrieve the Nth argument that was passed on the command line when
     the containing program was invoked.

_Standard_:
     F2003

_Class_:
     Subroutine

_Syntax_:
     `CALL GET_COMMAND_ARGUMENT(N, ARG)'

_Arguments_:
     N          Shall be of type `INTEGER(4)', N \geq 0
     ARG        Shall be of type `CHARACTER(*)'.

_Return value_:
     After `GET_COMMAND_ARGUMENT' returns, the ARG argument holds the
     Nth command line argument. If ARG can not hold the argument, it is
     truncated to fit the length of ARG. If there are less than N
     arguments specified at the command line, ARG will be filled with
     blanks.  If N = 0, ARG is set to the name of the program (on
     systems that support this feature).

_Example_:
          PROGRAM test_get_command_argument
            INTEGER :: i
            CHARACTER(len=32) :: arg

            i = 0
            DO
              CALL get_command_argument(i, arg)
              IF (LEN_TRIM(arg) == 0) EXIT

              WRITE (*,*) TRIM(arg)
              i = i+1
            END DO
          END PROGRAM

_See also_:
     *Note GET_COMMAND::, *Note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GETCWD,  Next: GETENV,  Prev: GET_COMMAND_ARGUMENT,  Up: Intrinsic Procedures

6.82 `GETCWD' -- Get current working directory
==============================================

_Description_:
     Get current working directory.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine.

_Syntax_:
     `CALL GETCWD(CWD [, STATUS])'

_Arguments_:
     CWD        The type shall be `CHARACTER(*)'.
     STATUS     (Optional) status flag. Returns 0 on success,
                                      a system specific and
                non-zero error code otherwise.

_Example_:
          PROGRAM test_getcwd
            CHARACTER(len=255) :: cwd
            CALL getcwd(cwd)
            WRITE(*,*) TRIM(cwd)
          END PROGRAM

_See also_:
     *Note CHDIR::


File: gfortran.info,  Node: GETENV,  Next: GET_ENVIRONMENT_VARIABLE,  Prev: GETCWD,  Up: Intrinsic Procedures

6.83 `GETENV' -- Get an environmental variable
==============================================

_Description_:
     Get the VALUE of the environmental variable ENVVAR.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *Note GET_ENVIRONMENT_VARIABLE:: intrinsic defined by the
     Fortran 2003 standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GETENV(ENVVAR, VALUE)'

_Arguments_:
     ENVVAR     Shall be of type `CHARACTER(*)'.
     VALUE      Shall be of type `CHARACTER(*)'.

_Return value_:
     Stores the value of ENVVAR in VALUE. If VALUE is not large enough
     to hold the data, it is truncated. If ENVVAR is not set, VALUE
     will be filled with blanks.

_Example_:
          PROGRAM test_getenv
            CHARACTER(len=255) :: homedir
            CALL getenv("HOME", homedir)
            WRITE (*,*) TRIM(homedir)
          END PROGRAM

_See also_:
     *Note GET_ENVIRONMENT_VARIABLE::


File: gfortran.info,  Node: GET_ENVIRONMENT_VARIABLE,  Next: GETGID,  Prev: GETENV,  Up: Intrinsic Procedures

6.84 `GET_ENVIRONMENT_VARIABLE' -- Get an environmental variable
================================================================

_Description_:
     Get the VALUE of the environmental variable ENVVAR.

_Standard_:
     F2003

_Class_:
     Subroutine

_Syntax_:
     `CALL GET_ENVIRONMENT_VARIABLE(ENVVAR, VALUE)'

_Arguments_:
     ENVVAR     Shall be of type `CHARACTER(*)'.
     VALUE      Shall be of type `CHARACTER(*)'.

_Return value_:
     Stores the value of ENVVAR in VALUE. If VALUE is not large enough
     to hold the data, it is truncated. If ENVVAR is not set, VALUE
     will be filled with blanks.

_Example_:
          PROGRAM test_getenv
            CHARACTER(len=255) :: homedir
            CALL get_environment_variable("HOME", homedir)
            WRITE (*,*) TRIM(homedir)
          END PROGRAM


File: gfortran.info,  Node: GETGID,  Next: GETLOG,  Prev: GET_ENVIRONMENT_VARIABLE,  Up: Intrinsic Procedures

6.85 `GETGID' -- Group ID function
==================================

_Description_:
     Returns the numerical group ID of the current process.

_Standard_:
     GNU extension

_Class_:
     function

_Syntax_:
     `RESULT = GETGID()'

_Return value_:
     The return value of `GETGID' is an `INTEGER' of the default kind.

_Example_:
     See `GETPID' for an example.

_See also_:
     *Note GETPID::, *Note GETUID::


File: gfortran.info,  Node: GETLOG,  Next: GETPID,  Prev: GETGID,  Up: Intrinsic Procedures

6.86 `GETLOG' -- Get login name
===============================

_Description_:
     Gets the username under which the program is running.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GETLOG(LOGIN)'

_Arguments_:
     LOGIN      Shall be of type `CHARACTER(*)'.

_Return value_:
     Stores the current user name in LOGIN.  (On systems where the
     `getlogin(3)' function is not implemented, this will return a
     blank string.)

_Example_:
          PROGRAM TEST_GETLOG
            CHARACTER(32) :: login
            CALL GETLOG(login)
            WRITE(*,*) login
          END PROGRAM

_See also_:
     *Note GETUID::


File: gfortran.info,  Node: GETPID,  Next: GETUID,  Prev: GETLOG,  Up: Intrinsic Procedures

6.87 `GETPID' -- Process ID function
====================================

_Description_:
     Returns the numerical process identifier of the current process.

_Standard_:
     GNU extension

_Class_:
     function

_Syntax_:
     `RESULT = GETPID()'

_Return value_:
     The return value of `GETPID' is an `INTEGER' of the default kind.

_Example_:
          program info
            print *, "The current process ID is ", getpid()
            print *, "Your numerical user ID is ", getuid()
            print *, "Your numerical group ID is ", getgid()
          end program info

_See also_:
     *Note GETGID::, *Note GETUID::


File: gfortran.info,  Node: GETUID,  Next: GMTIME,  Prev: GETPID,  Up: Intrinsic Procedures

6.88 `GETUID' -- User ID function
=================================

_Description_:
     Returns the numerical user ID of the current process.

_Standard_:
     GNU extension

_Class_:
     function

_Syntax_:
     `RESULT = GETUID()'

_Return value_:
     The return value of `GETUID' is an `INTEGER' of the default kind.

_Example_:
     See `GETPID' for an example.

_See also_:
     *Note GETPID::, *Note GETLOG::


File: gfortran.info,  Node: GMTIME,  Next: HOSTNM,  Prev: GETUID,  Up: Intrinsic Procedures

6.89 `GMTIME' -- Convert time to GMT info
=========================================

_Description_:
     Given a system time value STIME (as provided by the `TIME8()'
     intrinsic), fills TARRAY with values extracted from it appropriate
     to the UTC time zone (Universal Coordinated Time, also known in
     some countries as GMT, Greenwich Mean Time), using `gmtime(3)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GMTIME(STIME, TARRAY)'

_Arguments_:
     STIME      An `INTEGER(*)' scalar expression
                          corresponding to a system time, with
                `INTENT(IN)'.
     TARRAY     A default `INTEGER' array with 9 elements,
                                   with `INTENT(OUT)'.

_Return value_:
     The elements of TARRAY are assigned as follows:
       1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
               seconds

       2. Minutes after the hour, range 0-59

       3. Hours past midnight, range 0-23

       4. Day of month, range 0-31

       5. Number of months since January, range 0-12

       6. Years since 1900

       7. Number of days since Sunday, range 0-6

       8. Days since January 1

       9. Daylight savings indicator: positive if daylight savings is in
               effect, zero if not, and negative if the information is
          not       available.

_See also_:
     *Note CTIME::, *Note LTIME::, *Note TIME::, *Note TIME8::



File: gfortran.info,  Node: HOSTNM,  Next: HUGE,  Prev: GMTIME,  Up: Intrinsic Procedures

6.90 `HOSTNM' -- Get system host name
=====================================

_Description_:
     Retrieves the host name of the system on which the program is
     running.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL HOSTNM(NAME[, STATUS])'
     `STATUS = HOSTNM(NAME)'

_Arguments_:
     NAME       Shall of type `CHARACTER(*)'.
     STATUS     (Optional) status flag of type `INTEGER'.
                                    Returns 0 on success, or
                a system specific error
                 code otherwise.

_Return value_:
     In either syntax, NAME is set to the current hostname if it can be
     obtained, or to a blank string otherwise.



File: gfortran.info,  Node: HUGE,  Next: IACHAR,  Prev: HOSTNM,  Up: Intrinsic Procedures

6.91 `HUGE' -- Largest number of a kind
=======================================

_Description_:
     `HUGE(X)' returns the largest number that is not an infinity in
     the model of the type of `X'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = HUGE(X)'

_Arguments_:
     X          Shall be of type `REAL' or `INTEGER'.

_Return value_:
     The return value is of the same type and kind as X

_Example_:
          program test_huge_tiny
            print *, huge(0), huge(0.0), huge(0.0d0)
            print *, tiny(0.0), tiny(0.0d0)
          end program test_huge_tiny


File: gfortran.info,  Node: IACHAR,  Next: IAND,  Prev: HUGE,  Up: Intrinsic Procedures

6.92 `IACHAR' -- Code in ASCII collating sequence
=================================================

_Description_:
     `IACHAR(C)' returns the code for the ASCII character in the first
     character position of `C'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IACHAR(C)'

_Arguments_:
     C          Shall be a scalar `CHARACTER', with
                `INTENT(IN)'

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          program test_iachar
            integer i
            i = iachar(' ')
          end program test_iachar

_Note_:
     See *Note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *Note ACHAR::, *Note CHAR::, *Note ICHAR::



File: gfortran.info,  Node: IAND,  Next: IARGC,  Prev: IACHAR,  Up: Intrinsic Procedures

6.93 `IAND' -- Bitwise logical and
==================================

_Description_:
     Bitwise logical `AND'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IAND(I, J)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     J          The type shall be `INTEGER(*)', of the same
                kind as I.  (As a GNU extension, different
                kinds are also permitted.)

_Return value_:
     The return type is `INTEGER(*)', of the same kind as the
     arguments.  (If the argument kinds differ, it is of the same kind
     as the larger argument.)

_Example_:
          PROGRAM test_iand
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /
            WRITE (*,*) IAND(a, b)
          END PROGRAM

_See also_:
     *Note IOR::, *Note IEOR::, *Note IBITS::, *Note IBSET::, *Note
     IBCLR::, *Note NOT::



File: gfortran.info,  Node: IARGC,  Next: IBCLR,  Prev: IAND,  Up: Intrinsic Procedures

6.94 `IARGC' -- Get the number of command line arguments
========================================================

_Description_:
     `IARGC()' returns the number of arguments passed on the command
     line when the containing program was invoked.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *Note COMMAND_ARGUMENT_COUNT:: intrinsic defined by the
     Fortran 2003 standard.

_Standard_:
     GNU extension

_Class_:
     Non-elemental Function

_Syntax_:
     `RESULT = IARGC()'

_Arguments_:
     None.

_Return value_:
     The number of command line arguments, type `INTEGER(4)'.

_Example_:
     See *Note GETARG::

_See also_:
     GNU Fortran 77 compatibility subroutine: *Note GETARG::

     F2003 functions and subroutines: *Note GET_COMMAND::, *Note
     GET_COMMAND_ARGUMENT::, *Note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: IBCLR,  Next: IBITS,  Prev: IARGC,  Up: Intrinsic Procedures

6.95 `IBCLR' -- Clear bit
=========================

_Description_:
     `IBCLR' returns the value of I with the bit at position POS set to
     zero.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IBCLR(I, POS)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     POS        The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)' and of the same kind as I.

_See also_:
     *Note IBITS::, *Note IBSET::, *Note IAND::, *Note IOR::, *Note
     IEOR::, *Note MVBITS::



File: gfortran.info,  Node: IBITS,  Next: IBSET,  Prev: IBCLR,  Up: Intrinsic Procedures

6.96 `IBITS' -- Bit extraction
==============================

_Description_:
     `IBITS' extracts a field of length LEN from I, starting from bit
     position POS and extending left for LEN bits.  The result is
     right-justified and the remaining bits are zeroed.  The value of
     `POS+LEN' must be less than or equal to the value `BIT_SIZE(I)'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IBITS(I, POS, LEN)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     POS        The type shall be `INTEGER(*)'.
     LEN        The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)' and of the same kind as I.

_See also_:
     *Note BIT_SIZE::, *Note IBCLR::, *Note IBSET::, *Note IAND::,
     *Note IOR::, *Note IEOR::


File: gfortran.info,  Node: IBSET,  Next: ICHAR,  Prev: IBITS,  Up: Intrinsic Procedures

6.97 `IBSET' -- Set bit
=======================

_Description_:
     `IBSET' returns the value of I with the bit at position POS set to
     one.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IBSET(I, POS)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     POS        The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)' and of the same kind as I.

_See also_:
     *Note IBCLR::, *Note IBITS::, *Note IAND::, *Note IOR::, *Note
     IEOR::, *Note MVBITS::



File: gfortran.info,  Node: ICHAR,  Next: IDATE,  Prev: IBSET,  Up: Intrinsic Procedures

6.98 `ICHAR' -- Character-to-integer conversion function
========================================================

_Description_:
     `ICHAR(C)' returns the code for the character in the first
     character position of `C' in the system's native character set.
     The correspondence between characters and their codes is not
     necessarily the same across different GNU Fortran implementations.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ICHAR(C)'

_Arguments_:
     C          Shall be a scalar `CHARACTER', with
                `INTENT(IN)'

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          program test_ichar
            integer i
            i = ichar(' ')
          end program test_ichar

_Note_:
     No intrinsic exists to convert between a numeric value and a
     formatted character string representation - for instance, given the
     `CHARACTER' value `'154'', obtaining an `INTEGER' or `REAL' value
     with the value 154, or vice versa. Instead, this functionality is
     provided by internal-file I/O, as in the following example:
          program read_val
            integer value
            character(len=10) string, string2
            string = '154'

            ! Convert a string to a numeric value
            read (string,'(I10)') value
            print *, value

            ! Convert a value to a formatted string
            write (string2,'(I10)') value
            print *, string2
          end program read_val

_See also_:
     *Note ACHAR::, *Note CHAR::, *Note IACHAR::



File: gfortran.info,  Node: IDATE,  Next: IEOR,  Prev: ICHAR,  Up: Intrinsic Procedures

6.99 `IDATE' -- Get current local time subroutine (day/month/year)
==================================================================

_Description_:
     `IDATE(TARRAY)' Fills TARRAY with the numerical values at the
     current local time. The day (in the range 1-31), month (in the
     range 1-12), and year appear in elements 1, 2, and 3 of TARRAY,
     respectively.  The year has four significant digits.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL IDATE(TARRAY)'

_Arguments_:
     TARRAY     The type shall be `INTEGER, DIMENSION(3)' and
                the kind shall be the default integer kind.

_Return value_:
     Does not return.

_Example_:
          program test_idate
            integer, dimension(3) :: tarray
            call idate(tarray)
            print *, tarray(1)
            print *, tarray(2)
            print *, tarray(3)
          end program test_idate


File: gfortran.info,  Node: IEOR,  Next: IERRNO,  Prev: IDATE,  Up: Intrinsic Procedures

6.100 `IEOR' -- Bitwise logical exclusive or
============================================

_Description_:
     `IEOR' returns the bitwise boolean exclusive-OR of I and J.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IEOR(I, J)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     J          The type shall be `INTEGER(*)', of the same
                kind as I.  (As a GNU extension, different
                kinds are also permitted.)

_Return value_:
     The return type is `INTEGER(*)', of the same kind as the
     arguments.  (If the argument kinds differ, it is of the same kind
     as the larger argument.)

_See also_:
     *Note IOR::, *Note IAND::, *Note IBITS::, *Note IBSET::, *Note
     IBCLR::, *Note NOT::


File: gfortran.info,  Node: IERRNO,  Next: INDEX,  Prev: IEOR,  Up: Intrinsic Procedures

6.101 `IERRNO' -- Get the last system error number
==================================================

_Description_:
     Returns the last system error number, as given by the C `errno()'
     function.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = IERRNO()'

_Arguments_:
     None.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_See also_:
     *Note PERROR::


File: gfortran.info,  Node: INDEX,  Next: INT,  Prev: IERRNO,  Up: Intrinsic Procedures

6.102 `INDEX' -- Position of a substring within a string
========================================================

_Description_:
     Returns the position of the start of the first occurrence of string
     SUBSTRING as a substring in STRING, counting from one.  If
     SUBSTRING is not present in STRING, zero is returned.  If the BACK
     argument is present and true, the return value is the start of the
     last occurrence rather than the first.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = INDEX(STRING, SUBSTRING [, BACK])'

_Arguments_:
     STRING     Shall be a scalar `CHARACTER(*)', with
                `INTENT(IN)'
     SUBSTRING  Shall be a scalar `CHARACTER(*)', with
                `INTENT(IN)'
     BACK       (Optional) Shall be a scalar `LOGICAL(*)', with
                `INTENT(IN)'

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_See also_:
     *Note SCAN::, *Note VERIFY::


File: gfortran.info,  Node: INT,  Next: INT2,  Prev: INDEX,  Up: Intrinsic Procedures

6.103 `INT' -- Convert to integer type
======================================

_Description_:
     Convert to integer type

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = INT(A [, KIND))'

_Arguments_:
     A          Shall be of type `INTEGER(*)',
                     `REAL(*)', or `COMPLEX(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     These functions return a `INTEGER(*)' variable or array under the
     following rules:

    (A)
          If A is of type `INTEGER(*)', `INT(A) = A'

    (B)
          If A is of type `REAL(*)' and |A| < 1, `INT(A)' equals `0'.
          If |A| \geq 1, then `INT(A)' equals the largest integer that
          does not exceed the range of A and whose sign is the same as
          the sign of A.

    (C)
          If A is of type `COMPLEX(*)', rule B is applied to the real
          part of A.

_Example_:
          program test_int
            integer :: i = 42
            complex :: z = (-3.7, 1.0)
            print *, int(i)
            print *, int(z), int(z,8)
          end program

_Specific names_:
     Name          Argument      Return type   Standard
     `IFIX(A)'     `REAL(4) A'   `INTEGER'     F77 and later
     `IDINT(A)'    `REAL(8) A'   `INTEGER'     F77 and later



File: gfortran.info,  Node: INT2,  Next: INT8,  Prev: INT,  Up: Intrinsic Procedures

6.104 `INT2' -- Convert to 16-bit integer type
==============================================

_Description_:
     Convert to a `KIND=2' integer type. This is equivalent to the
     standard `INT' intrinsic with an optional argument of `KIND=2',
     and is only included for backwards compatibility.

     The `SHORT' intrinsic is equivalent to `INT2'.

_Standard_:
     GNU extension.

_Class_:
     Elemental function

_Syntax_:
     `RESULT = INT2(A)'

_Arguments_:
     A          Shall be of type `INTEGER(*)',
                     `REAL(*)', or `COMPLEX(*)'.

_Return value_:
     The return value is a `INTEGER(2)' variable.

_See also_:
     *Note INT::, *Note INT8::, *Note LONG::


File: gfortran.info,  Node: INT8,  Next: IOR,  Prev: INT2,  Up: Intrinsic Procedures

6.105 `INT8' -- Convert to 64-bit integer type
==============================================

_Description_:
     Convert to a `KIND=8' integer type. This is equivalent to the
     standard `INT' intrinsic with an optional argument of `KIND=8',
     and is only included for backwards compatibility.

_Standard_:
     GNU extension.

_Class_:
     Elemental function

_Syntax_:
     `RESULT = INT8(A)'

_Arguments_:
     A          Shall be of type `INTEGER(*)',
                     `REAL(*)', or `COMPLEX(*)'.

_Return value_:
     The return value is a `INTEGER(8)' variable.

_See also_:
     *Note INT::, *Note INT2::, *Note LONG::


File: gfortran.info,  Node: IOR,  Next: IRAND,  Prev: INT8,  Up: Intrinsic Procedures

6.106 `IOR' -- Bitwise logical or
=================================

_Description_:
     `IEOR' returns the bitwise boolean OR of I and J.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IEOR(I, J)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     J          The type shall be `INTEGER(*)', of the same
                kind as I.  (As a GNU extension, different
                kinds are also permitted.)

_Return value_:
     The return type is `INTEGER(*)', of the same kind as the
     arguments.  (If the argument kinds differ, it is of the same kind
     as the larger argument.)

_See also_:
     *Note IEOR::, *Note IAND::, *Note IBITS::, *Note IBSET::, *Note
     IBCLR::, *Note NOT::


File: gfortran.info,  Node: IRAND,  Next: ISATTY,  Prev: IOR,  Up: Intrinsic Procedures

6.107 `IRAND' -- Integer pseudo-random number
=============================================

_Description_:
     `IRAND(FLAG)' returns a pseudo-random number from a uniform
     distribution between 0 and a system-dependent limit (which is in
     most cases 2147483647). If FLAG is 0, the next number in the
     current sequence is returned; if FLAG is 1, the generator is
     restarted by `CALL SRAND(0)'; if FLAG has any other value, it is
     used as a new seed with `SRAND'.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = IRAND(FLAG)'

_Arguments_:
     FLAG       Shall be a scalar `INTEGER' of kind 4.

_Return value_:
     The return value is of `INTEGER(kind=4)' type.

_Example_:
          program test_irand
            integer,parameter :: seed = 86456

            call srand(seed)
            print *, irand(), irand(), irand(), irand()
            print *, irand(seed), irand(), irand(), irand()
          end program test_irand



File: gfortran.info,  Node: ISATTY,  Next: ISHFT,  Prev: IRAND,  Up: Intrinsic Procedures

6.108 `ISATTY' -- Whether a unit is a terminal device.
======================================================

_Description_:
     Determine whether a unit is connected to a terminal device.

_Standard_:
     GNU extension.

_Class_:
     Non-elemental function.

_Syntax_:
     `RESULT = ISATTY(UNIT)'

_Arguments_:
     UNIT       Shall be a scalar `INTEGER(*)'.

_Return value_:
     Returns `.TRUE.' if the UNIT is connected to a terminal device,
     `.FALSE.' otherwise.

_Example_:
          PROGRAM test_isatty
            INTEGER(kind=1) :: unit
            DO unit = 1, 10
              write(*,*) isatty(unit=unit)
            END DO
          END PROGRAM

_See also_:
     *Note TTYNAM::


File: gfortran.info,  Node: ISHFT,  Next: ISHFTC,  Prev: ISATTY,  Up: Intrinsic Procedures

6.109 `ISHFT' -- Shift bits
===========================

_Description_:
     `ISHFT' returns a value corresponding to I with all of the bits
     shifted SHIFT places.  A value of SHIFT greater than zero
     corresponds to a left shift, a value of zero corresponds to no
     shift, and a value less than zero corresponds to a right shift.
     If the absolute value of SHIFT is greater than `BIT_SIZE(I)', the
     value is undefined.  Bits shifted out from the left end or right
     end are lost; zeros are shifted in from the opposite end.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ISHFT(I, SHIFT)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     SHIFT      The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)' and of the same kind as I.

_See also_:
     *Note ISHFTC::


File: gfortran.info,  Node: ISHFTC,  Next: ITIME,  Prev: ISHFT,  Up: Intrinsic Procedures

6.110 `ISHFTC' -- Shift bits circularly
=======================================

_Description_:
     `ISHFTC' returns a value corresponding to I with the rightmost
     SIZE bits shifted circularly SHIFT places; that is, bits shifted
     out one end are shifted into the opposite end.  A value of SHIFT
     greater than zero corresponds to a left shift, a value of zero
     corresponds to no shift, and a value less than zero corresponds to
     a right shift.  The absolute value of SHIFT must be less than
     SIZE.  If the SIZE argument is omitted, it is taken to be
     equivalent to `BIT_SIZE(I)'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ISHFTC(I, SHIFT [, SIZE])'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     SHIFT      The type shall be `INTEGER(*)'.
     SIZE       (Optional) The type shall be `INTEGER(*)'; the
                value must be greater than zero and less than
                or equal to `BIT_SIZE(I)'.

_Return value_:
     The return value is of type `INTEGER(*)' and of the same kind as I.

_See also_:
     *Note ISHFT::


File: gfortran.info,  Node: ITIME,  Next: KILL,  Prev: ISHFTC,  Up: Intrinsic Procedures

6.111 `ITIME' -- Get current local time subroutine (hour/minutes/seconds)
=========================================================================

_Description_:
     `IDATE(TARRAY)' Fills TARRAY with the numerical values at the
     current local time. The hour (in the range 1-24), minute (in the
     range 1-60), and seconds (in the range 1-60) appear in elements 1,
     2, and 3 of TARRAY, respectively.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL ITIME(TARRAY)'

_Arguments_:
     TARRAY     The type shall be `INTEGER, DIMENSION(3)' and
                the kind shall be the default integer kind.

_Return value_:
     Does not return.

_Example_:
          program test_itime
            integer, dimension(3) :: tarray
            call itime(tarray)
            print *, tarray(1)
            print *, tarray(2)
            print *, tarray(3)
          end program test_itime


File: gfortran.info,  Node: KILL,  Next: KIND,  Prev: ITIME,  Up: Intrinsic Procedures

6.112 `KILL' -- Send a signal to a process
==========================================

_Description_:

_Standard_:
     Sends the signal specified by SIGNAL to the process PID.  See
     `kill(2)'.

_Class_:
     Subroutine

_Syntax_:
     `CALL KILL(PID, SIGNAL [, STATUS])'

_Arguments_:
     PID        Shall be a scalar `INTEGER', with `INTENT(IN)'
     SIGNAL     Shall be a scalar `INTEGER', with `INTENT(IN)'
     STATUS     (Optional) status flag of type `INTEGER(4)' or
                                       `INTEGER(8)'. Returns
                0 on success, or a
                system-specific error code otherwise.

_See also_:
     *Note ABORT::, *Note EXIT::


File: gfortran.info,  Node: KIND,  Next: LBOUND,  Prev: KILL,  Up: Intrinsic Procedures

6.113 `KIND' -- Kind of an entity
=================================

_Description_:
     `KIND(X)' returns the kind value of the entity X.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `K = KIND(X)'

_Arguments_:
     X          Shall be of type `LOGICAL', `INTEGER', `REAL',
                `COMPLEX' or `CHARACTER'.

_Return value_:
     The return value is a scalar of type `INTEGER' and of the default
     integer kind.

_Example_:
          program test_kind
            integer,parameter :: kc = kind(' ')
            integer,parameter :: kl = kind(.true.)

            print *, "The default character kind is ", kc
            print *, "The default logical kind is ", kl
          end program test_kind



File: gfortran.info,  Node: LBOUND,  Next: LEN,  Prev: KIND,  Up: Intrinsic Procedures

6.114 `LBOUND' -- Lower dimension bounds of an array
====================================================

_Description_:
     Returns the lower bounds of an array, or a single lower bound
     along the DIM dimension.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = LBOUND(ARRAY [, DIM])'

_Arguments_:
     ARRAY      Shall be an array, of any type.
     DIM        (Optional) Shall be a scalar `INTEGER(*)'.

_Return value_:
     If DIM is absent, the result is an array of the lower bounds of
     ARRAY.  If DIM is present, the result is a scalar corresponding to
     the lower bound of the array along that dimension.  If ARRAY is an
     expression rather than a whole array or array structure component,
     or if it has a zero extent along the relevant dimension, the lower
     bound is taken to be 1.

_See also_:
     *Note UBOUND::


File: gfortran.info,  Node: LEN,  Next: LEN_TRIM,  Prev: LBOUND,  Up: Intrinsic Procedures

6.115 `LEN' -- Length of a character entity
===========================================

_Description_:
     Returns the length of a character string.  If STRING is an array,
     the length of an element of STRING is returned.  Note that STRING
     need not be defined when this intrinsic is invoked, since only the
     length, not the content, of STRING is needed.

_Standard_:
     F77 and later

_Class_:
     Inquiry function

_Syntax_:
     `L = LEN(STRING)'

_Arguments_:
     STRING     Shall be a scalar or array of type
                `CHARACTER(*)', with `INTENT(IN)'

_Return value_:
     The return value is an `INTEGER' of the default kind.

_See also_:
     *Note LEN_TRIM::, *Note ADJUSTL::, *Note ADJUSTR::


File: gfortran.info,  Node: LEN_TRIM,  Next: LGE,  Prev: LEN,  Up: Intrinsic Procedures

6.116 `LEN_TRIM' -- Length of a character entity without trailing blank characters
==================================================================================

_Description_:
     Returns the length of a character string, ignoring any trailing
     blanks.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LEN_TRIM(STRING)'

_Arguments_:
     STRING     Shall be a scalar of type `CHARACTER(*)', with
                `INTENT(IN)'

_Return value_:
     The return value is an `INTEGER' of the default kind.

_See also_:
     *Note LEN::, *Note ADJUSTL::, *Note ADJUSTR::


File: gfortran.info,  Node: LGE,  Next: LGT,  Prev: LEN_TRIM,  Up: Intrinsic Procedures

6.117 `LGE' -- Lexical greater than or equal
============================================

_Description_:
     Determines whether one string is lexically greater than or equal to
     another string, where the two strings are interpreted as containing
     ASCII character codes.  If the String A and String B are not the
     same length, the shorter is compared as if spaces were appended to
     it to form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
     and `LLT' differ from the corresponding intrinsic operators
     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
     processor's character ordering (which is not ASCII on some
     targets), whereas the former always use the ASCII ordering.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LGE(STRING_A, STRING_B)'

_Arguments_:
     STRING_A   Shall be of default `CHARACTER' type.
     STRING_B   Shall be of default `CHARACTER' type.

_Return value_:
     Returns `.TRUE.' if `STRING_A >= STRING_B', and `.FALSE.'
     otherwise, based on the ASCII ordering.

_See also_:
     *Note LGT::, *Note LLE::, *Note LLT::


File: gfortran.info,  Node: LGT,  Next: LINK,  Prev: LGE,  Up: Intrinsic Procedures

6.118 `LGT' -- Lexical greater than
===================================

_Description_:
     Determines whether one string is lexically greater than another
     string, where the two strings are interpreted as containing ASCII
     character codes.  If the String A and String B are not the same
     length, the shorter is compared as if spaces were appended to it
     to form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
     and `LLT' differ from the corresponding intrinsic operators
     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
     processor's character ordering (which is not ASCII on some
     targets), whereas the former always use the ASCII ordering.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LGT(STRING_A, STRING_B)'

_Arguments_:
     STRING_A   Shall be of default `CHARACTER' type.
     STRING_B   Shall be of default `CHARACTER' type.

_Return value_:
     Returns `.TRUE.' if `STRING_A > STRING_B', and `.FALSE.'
     otherwise, based on the ASCII ordering.

_See also_:
     *Note LGE::, *Note LLE::, *Note LLT::


File: gfortran.info,  Node: LINK,  Next: LLE,  Prev: LGT,  Up: Intrinsic Procedures

6.119 `LINK' -- Create a hard link
==================================

_Description_:
     Makes a (hard) link from file PATH1 to PATH2. A null character
     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see `link(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL LINK(PATH1, PATH2 [, STATUS])'
     `STATUS = LINK(PATH1, PATH2)'

_Arguments_:
     PATH1      Shall be of default `CHARACTER' type.
     PATH2      Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:
     *Note SYMLNK::, *Note UNLINK::


File: gfortran.info,  Node: LLE,  Next: LLT,  Prev: LINK,  Up: Intrinsic Procedures

6.120 `LLE' -- Lexical less than or equal
=========================================

_Description_:
     Determines whether one string is lexically less than or equal to
     another string, where the two strings are interpreted as
     containing ASCII character codes.  If the String A and String B
     are not the same length, the shorter is compared as if spaces were
     appended to it to form a value that has the same length as the
     longer.

     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
     and `LLT' differ from the corresponding intrinsic operators
     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
     processor's character ordering (which is not ASCII on some
     targets), whereas the former always use the ASCII ordering.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LLE(STRING_A, STRING_B)'

_Arguments_:
     STRING_A   Shall be of default `CHARACTER' type.
     STRING_B   Shall be of default `CHARACTER' type.

_Return value_:
     Returns `.TRUE.' if `STRING_A <= STRING_B', and `.FALSE.'
     otherwise, based on the ASCII ordering.

_See also_:
     *Note LGE::, *Note LGT::, *Note LLT::


File: gfortran.info,  Node: LLT,  Next: LNBLNK,  Prev: LLE,  Up: Intrinsic Procedures

6.121 `LLT' -- Lexical less than
================================

_Description_:
     Determines whether one string is lexically less than another
     string, where the two strings are interpreted as containing ASCII
     character codes.  If the String A and String B are not the same
     length, the shorter is compared as if spaces were appended to it
     to form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
     and `LLT' differ from the corresponding intrinsic operators
     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
     processor's character ordering (which is not ASCII on some
     targets), whereas the former always use the ASCII ordering.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LLT(STRING_A, STRING_B)'

_Arguments_:
     STRING_A   Shall be of default `CHARACTER' type.
     STRING_B   Shall be of default `CHARACTER' type.

_Return value_:
     Returns `.TRUE.' if `STRING_A < STRING_B', and `.FALSE.'
     otherwise, based on the ASCII ordering.

_See also_:
     *Note LGE::, *Note LGT::, *Note LLE::


File: gfortran.info,  Node: LNBLNK,  Next: LOC,  Prev: LLT,  Up: Intrinsic Procedures

6.122 `LNBLNK' -- Index of the last non-blank character in a string
===================================================================

_Description_:
     Returns the length of a character string, ignoring any trailing
     blanks.  This is identical to the standard `LEN_TRIM' intrinsic,
     and is only included for backwards compatibility.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LNBLNK(STRING)'

_Arguments_:
     STRING     Shall be a scalar of type `CHARACTER(*)', with
                `INTENT(IN)'

_Return value_:
     The return value is of `INTEGER(kind=4)' type.

_See also_:
     *Note INDEX::, *Note LEN_TRIM::


File: gfortran.info,  Node: LOC,  Next: LOG,  Prev: LNBLNK,  Up: Intrinsic Procedures

6.123 `LOC' -- Returns the address of a variable
================================================

_Description_:
     `LOC(X)' returns the address of X as an integer.

_Standard_:
     GNU extension

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = LOC(X)'

_Arguments_:
     X          Variable of any type.

_Return value_:
     The return value is of type `INTEGER', with a `KIND' corresponding
     to the size (in bytes) of a memory address on the target machine.

_Example_:
          program test_loc
            integer :: i
            real :: r
            i = loc(r)
            print *, i
          end program test_loc


File: gfortran.info,  Node: LOG,  Next: LOG10,  Prev: LOC,  Up: Intrinsic Procedures

6.124 `LOG' -- Logarithm function
=================================

_Description_:
     `LOG(X)' computes the logarithm of X.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LOG(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value is of type `REAL(*)' or `COMPLEX(*)'.  The kind
     type parameter is the same as X.

_Example_:
          program test_log
            real(8) :: x = 1.0_8
            complex :: z = (1.0, 2.0)
            x = log(x)
            z = log(z)
          end program test_log

_Specific names_:
     Name          Argument      Return type   Standard
     `ALOG(X)'     `REAL(4) X'   `REAL(4)'     f95, gnu
     `DLOG(X)'     `REAL(8) X'   `REAL(8)'     f95, gnu
     `CLOG(X)'     `COMPLEX(4)   `COMPLEX(4)'  f95, gnu
                   X'                          
     `ZLOG(X)'     `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
                   X'                          
     `CDLOG(X)'    `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
                   X'                          


File: gfortran.info,  Node: LOG10,  Next: LOGICAL,  Prev: LOG,  Up: Intrinsic Procedures

6.125 `LOG10' -- Base 10 logarithm function
===========================================

_Description_:
     `LOG10(X)' computes the base 10 logarithm of X.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LOG10(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)' or `COMPLEX(*)'.  The kind
     type parameter is the same as X.

_Example_:
          program test_log10
            real(8) :: x = 10.0_8
            x = log10(x)
          end program test_log10

_Specific names_:
     Name          Argument      Return type   Standard
     `ALOG10(X)'   `REAL(4) X'   `REAL(4)'     F95 and later
     `DLOG10(X)'   `REAL(8) X'   `REAL(8)'     F95 and later


File: gfortran.info,  Node: LOGICAL,  Next: LONG,  Prev: LOG10,  Up: Intrinsic Procedures

6.126 `LOGICAL' -- Convert to logical type
==========================================

_Description_:
     Converts one kind of `LOGICAL' variable to another.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LOGICAL(L [, KIND])'

_Arguments_:
     L          The type shall be `LOGICAL(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     The return value is a `LOGICAL' value equal to L, with a kind
     corresponding to KIND, or of the default logical kind if KIND is
     not given.

_See also_:
     *Note INT::, *Note REAL::, *Note CMPLX::


File: gfortran.info,  Node: LONG,  Next: LSHIFT,  Prev: LOGICAL,  Up: Intrinsic Procedures

6.127 `LONG' -- Convert to integer type
=======================================

_Description_:
     Convert to a `KIND=4' integer type, which is the same size as a C
     `long' integer.  This is equivalent to the standard `INT'
     intrinsic with an optional argument of `KIND=4', and is only
     included for backwards compatibility.

_Standard_:
     GNU extension.

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LONG(A)'

_Arguments_:
     A          Shall be of type `INTEGER(*)',
                     `REAL(*)', or `COMPLEX(*)'.

_Return value_:
     The return value is a `INTEGER(4)' variable.

_See also_:
     *Note INT::, *Note INT2::, *Note INT8::


File: gfortran.info,  Node: LSHIFT,  Next: LSTAT,  Prev: LONG,  Up: Intrinsic Procedures

6.128 `LSHIFT' -- Left shift bits
=================================

_Description_:
     `LSHIFT' returns a value corresponding to I with all of the bits
     shifted left by SHIFT places.  If the absolute value of SHIFT is
     greater than `BIT_SIZE(I)', the value is undefined.  Bits shifted
     out from the left end are lost; zeros are shifted in from the
     opposite end.

     This function has been superseded by the `ISHFT' intrinsic, which
     is standard in Fortran 95 and later.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LSHIFT(I, SHIFT)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     SHIFT      The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)' and of the same kind as I.

_See also_:
     *Note ISHFT::, *Note ISHFTC::, *Note RSHIFT::



File: gfortran.info,  Node: LSTAT,  Next: LTIME,  Prev: LSHIFT,  Up: Intrinsic Procedures

6.129 `LSTAT' -- Get file status
================================

_Description_:
     `LSTAT' is identical to *Note STAT::, except that if path is a
     symbolic link, then the link itself is statted, not the file that
     it refers to.

     The elements in `BUFF' are the same as described by *Note STAT::.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL LSTAT(FILE, BUFF [, STATUS])'

_Arguments_:
     FILE       The type shall be `CHARACTER(*)', a valid path
                within the file system.
     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
     STATUS     (Optional) status flag of type `INTEGER(4)'.
                Returns 0                         on success
                and a system specific error code otherwise.

_Example_:
     See *Note STAT:: for an example.

_See also_:
     To stat an open file: *Note FSTAT::, to stat a file: *Note STAT::


File: gfortran.info,  Node: LTIME,  Next: MALLOC,  Prev: LSTAT,  Up: Intrinsic Procedures

6.130 `LTIME' -- Convert time to local time info
================================================

_Description_:
     Given a system time value STIME (as provided by the `TIME8()'
     intrinsic), fills TARRAY with values extracted from it appropriate
     to the local time zone using `localtime(3)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL LTIME(STIME, TARRAY)'

_Arguments_:
     STIME      An `INTEGER(*)' scalar expression
                          corresponding to a system time, with
                `INTENT(IN)'.
     TARRAY     A default `INTEGER' array with 9 elements,
                                   with `INTENT(OUT)'.

_Return value_:
     The elements of TARRAY are assigned as follows:
       1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
               seconds

       2. Minutes after the hour, range 0-59

       3. Hours past midnight, range 0-23

       4. Day of month, range 0-31

       5. Number of months since January, range 0-12

       6. Years since 1900

       7. Number of days since Sunday, range 0-6

       8. Days since January 1

       9. Daylight savings indicator: positive if daylight savings is in
               effect, zero if not, and negative if the information is
          not       available.

_See also_:
     *Note CTIME::, *Note GMTIME::, *Note TIME::, *Note TIME8::



File: gfortran.info,  Node: MALLOC,  Next: MATMUL,  Prev: LTIME,  Up: Intrinsic Procedures

6.131 `MALLOC' -- Allocate dynamic memory
=========================================

_Description_:
     `MALLOC(SIZE)' allocates SIZE bytes of dynamic memory and returns
     the address of the allocated memory. The `MALLOC' intrinsic is an
     extension intended to be used with Cray pointers, and is provided
     in GNU Fortran to allow the user to compile legacy code. For new
     code using Fortran 95 pointers, the memory allocation intrinsic is
     `ALLOCATE'.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `PTR = MALLOC(SIZE)'

_Arguments_:
     SIZE       The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(K)', with K such that
     variables of type `INTEGER(K)' have the same size as C pointers
     (`sizeof(void *)').

_Example_:
     The following example demonstrates the use of `MALLOC' and `FREE'
     with Cray pointers. This example is intended to run on 32-bit
     systems, where the default integer kind is suitable to store
     pointers; on 64-bit systems, ptr_x would need to be declared as
     `integer(kind=8)'.

          program test_malloc
            integer i
            integer ptr_x
            real*8 x(*), z
            pointer(ptr_x,x)

            ptr_x = malloc(20*8)
            do i = 1, 20
              x(i) = sqrt(1.0d0 / i)
            end do
            z = 0
            do i = 1, 20
              z = z + x(i)
              print *, z
            end do
            call free(ptr_x)
          end program test_malloc

_See also_:
     *Note FREE::


File: gfortran.info,  Node: MATMUL,  Next: MAX,  Prev: MALLOC,  Up: Intrinsic Procedures

6.132 `MATMUL' -- matrix multiplication
=======================================

_Description_:
     Performs a matrix multiplication on numeric or logical arguments.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MATMUL(MATRIX_A, MATRIX_B)'

_Arguments_:
     MATRIX_A   An array of `INTEGER(*)',
                    `REAL(*)', `COMPLEX(*)', or
                `LOGICAL(*)' type, with a rank of 			  one or two.
     MATRIX_B   An array of `INTEGER(*)',
                    `REAL(*)', or `COMPLEX(*)' type if
                 MATRIX_A is of a numeric type; 			  otherwise,
                an array of `LOGICAL(*)' 			  type. The
                rank shall be one or two, and the 			  first (or
                only) dimension of MATRIX_B 			  shall be
                equal to the last (or only)
                dimension of MATRIX_A.

_Return value_:
     The matrix product of MATRIX_A and MATRIX_B.  The type and kind of
     the result follow the usual type and kind promotion rules, as for
     the `*' or `.AND.' operators.

_See also_:


File: gfortran.info,  Node: MAX,  Next: MAXEXPONENT,  Prev: MATMUL,  Up: Intrinsic Procedures

6.133 `MAX' -- Maximum value of an argument list
================================================

_Description_:
     Returns the argument with the largest (most positive) value.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MAX(A1, A2 [, A3 [, ...]])'

_Arguments_:
     A1         The type shall be `INTEGER(*)' or
                               `REAL(*)'.
     A2, A3,    An expression of the same type and kind
     ...                             as A1.  (As a GNU
                extension, 			     arguments of different
                kinds are 			     permitted.)

_Return value_:
     The return value corresponds to the maximum value among the
     arguments, and has the same type and kind as the first argument.

_Specific names_:
     Name          Argument      Return type   Standard
     `MAX0(I)'     `INTEGER(4)   `INTEGER(4)'  F77 and later
                   I'                          
     `AMAX0(I)'    `INTEGER(4)   `REAL(MAX(X))'F77 and later
                   I'                          
     `MAX1(X)'     `REAL(*) X'   `INT(MAX(X))' F77 and later
     `AMAX1(X)'    `REAL(4)      `REAL(4)'     F77 and later
                   X'                          
     `DMAX1(X)'    `REAL(8)      `REAL(8)'     F77 and later
                   X'                          

_See also_:
     *Note MAXLOC:: *Note MAXVAL::, *Note MIN::



File: gfortran.info,  Node: MAXEXPONENT,  Next: MAXLOC,  Prev: MAX,  Up: Intrinsic Procedures

6.134 `MAXEXPONENT' -- Maximum exponent of a real kind
======================================================

_Description_:
     `MAXEXPONENT(X)' returns the maximum exponent in the model of the
     type of `X'.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = MAXEXPONENT(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          program exponents
            real(kind=4) :: x
            real(kind=8) :: y

            print *, minexponent(x), maxexponent(x)
            print *, minexponent(y), maxexponent(y)
          end program exponents


File: gfortran.info,  Node: MAXLOC,  Next: MAXVAL,  Prev: MAXEXPONENT,  Up: Intrinsic Procedures

6.135 `MAXLOC' -- Location of the maximum value within an array
===============================================================

_Description_:
     Determines the location of the element in the array with the
     maximum value, or, if the DIM argument is supplied, determines the
     locations of the maximum element along each row of the array in the
     DIM direction.  If MASK is present, only the elements for which
     MASK is `.TRUE.' are considered.  If more than one element in the
     array has the maximum value, the location returned is that of the
     first such element in array element order.  If the array has zero
     size, or all of the elements of MASK are `.FALSE.', then the
     result is an array of zeroes.  Similarly, if DIM is supplied and
     all of the elements of MASK along a given row are zero, the result
     value for that row is zero.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MAXLOC(ARRAY, DIM [, MASK])'
     `RESULT = MAXLOC(ARRAY [, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER(*)',
                               `REAL(*)', or `CHARACTER(*)'.
     DIM        (Optional) Shall be a scalar of type
                            `INTEGER(*)', with a value
                between one 		       and the rank of
                ARRAY, inclusive.  It 		       may not be an
                optional dummy argument.
     MASK       Shall be an array of type `LOGICAL(*)',
                               and conformable with ARRAY.

_Return value_:
     If DIM is absent, the result is a rank-one array with a length
     equal to the rank of ARRAY.  If DIM is present, the result is an
     array with a rank one less than the rank of ARRAY, and a size
     corresponding to the size of ARRAY with the DIM dimension removed.
     If DIM is present and ARRAY has a rank of one, the result is a
     scalar.  In all cases, the result is of default `INTEGER' type.

_See also_:
     *Note MAX::, *Note MAXVAL::



File: gfortran.info,  Node: MAXVAL,  Next: MCLOCK,  Prev: MAXLOC,  Up: Intrinsic Procedures

6.136 `MAXVAL' -- Maximum value of an array
===========================================

_Description_:
     Determines the maximum value of the elements in an array value,
     or, if the DIM argument is supplied, determines the maximum value
     along each row of the array in the DIM direction.  If MASK is
     present, only the elements for which MASK is `.TRUE.' are
     considered.  If the array has zero size, or all of the elements of
     MASK are `.FALSE.', then the result is the most negative number of
     the type and kind of ARRAY if ARRAY is numeric, or a string of
     nulls if ARRAY is of character type.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MAXVAL(ARRAY, DIM [, MASK])'
     `RESULT = MAXVAL(ARRAY [, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER(*)',
                               `REAL(*)', or `CHARACTER(*)'.
     DIM        (Optional) Shall be a scalar of type
                            `INTEGER(*)', with a value
                between one 		       and the rank of
                ARRAY, inclusive.  It 		       may not be an
                optional dummy argument.
     MASK       Shall be an array of type `LOGICAL(*)',
                               and conformable with ARRAY.

_Return value_:
     If DIM is absent, or if ARRAY has a rank of one, the result is a
     scalar.  If DIM is present, the result is an array with a rank one
     less than the rank of ARRAY, and a size corresponding to the size
     of ARRAY with the DIM dimension removed.  In all cases, the result
     is of the same type and kind as ARRAY.

_See also_:
     *Note MAX::, *Note MAXLOC::


File: gfortran.info,  Node: MCLOCK,  Next: MCLOCK8,  Prev: MAXVAL,  Up: Intrinsic Procedures

6.137 `MCLOCK' -- Time function
===============================

_Description_:
     Returns the number of clock ticks since the start of the process,
     based on the UNIX function `clock(3)'.

     This intrinsic is not fully portable, such as to systems with
     32-bit `INTEGER' types but supporting times wider than 32 bits.
     Therefore, the values returned by this intrinsic might be, or
     become, negative, or numerically less than previous values, during
     a single run of the compiled program.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = MCLOCK()'

_Return value_:
     The return value is a scalar of type `INTEGER(4)', equal to the
     number of clock ticks since the start of the process, or `-1' if
     the system does not support `clock(3)'.

_See also_:
     *Note CTIME::, *Note GMTIME::, *Note LTIME::, *Note MCLOCK::,
     *Note TIME::



File: gfortran.info,  Node: MCLOCK8,  Next: MERGE,  Prev: MCLOCK,  Up: Intrinsic Procedures

6.138 `MCLOCK8' -- Time function (64-bit)
=========================================

_Description_:
     Returns the number of clock ticks since the start of the process,
     based on the UNIX function `clock(3)'.

     _Warning:_ this intrinsic does not increase the range of the timing
     values over that returned by `clock(3)'. On a system with a 32-bit
     `clock(3)', `MCLOCK8()' will return a 32-bit value, even though it
     is converted to a 64-bit `INTEGER(8)' value. That means overflows
     of the 32-bit value can still occur. Therefore, the values
     returned by this intrinsic might be or become negative or
     numerically less than previous values during a single run of the
     compiled program.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = MCLOCK8()'

_Return value_:
     The return value is a scalar of type `INTEGER(8)', equal to the
     number of clock ticks since the start of the process, or `-1' if
     the system does not support `clock(3)'.

_See also_:
     *Note CTIME::, *Note GMTIME::, *Note LTIME::, *Note MCLOCK::,
     *Note TIME8::



File: gfortran.info,  Node: MERGE,  Next: MIN,  Prev: MCLOCK8,  Up: Intrinsic Procedures

6.139 `MERGE' -- Merge variables
================================

_Description_:
     Select values from two arrays according to a logical mask.  The
     result is equal to TSOURCE if MASK is `.TRUE.', or equal to
     FSOURCE if it is `.FALSE.'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MERGE(TSOURCE, FSOURCE, MASK)'

_Arguments_:
     TSOURCE    May be of any type.
     FSOURCE    Shall be of the same type and type parameters
                                       as TSOURCE.
     MASK       Shall be of type `LOGICAL(*)'.

_Return value_:
     The result is of the same type and type parameters as TSOURCE.



File: gfortran.info,  Node: MIN,  Next: MINEXPONENT,  Prev: MERGE,  Up: Intrinsic Procedures

6.140 `MIN' -- Minimum value of an argument list
================================================

_Description_:
     Returns the argument with the smallest (most negative) value.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MIN(A1, A2 [, A3, ...])'

_Arguments_:
     A1         The type shall be `INTEGER(*)' or
                               `REAL(*)'.
     A2, A3,    An expression of the same type and kind
     ...                             as A1.  (As a GNU
                extension, 			     arguments of different
                kinds are 			     permitted.)

_Return value_:
     The return value corresponds to the maximum value among the
     arguments, and has the same type and kind as the first argument.

_Specific names_:
     Name          Argument      Return type   Standard
     `MIN0(I)'     `INTEGER(4)   `INTEGER(4)'  F77 and later
                   I'                          
     `AMIN0(I)'    `INTEGER(4)   `REAL(MIN(X))'F77 and later
                   I'                          
     `MIN1(X)'     `REAL(*) X'   `INT(MIN(X))' F77 and later
     `AMIN1(X)'    `REAL(4)      `REAL(4)'     F77 and later
                   X'                          
     `DMIN1(X)'    `REAL(8)      `REAL(8)'     F77 and later
                   X'                          

_See also_:
     *Note MAX::, *Note MINLOC::, *Note MINVAL::


File: gfortran.info,  Node: MINEXPONENT,  Next: MINLOC,  Prev: MIN,  Up: Intrinsic Procedures

6.141 `MINEXPONENT' -- Minimum exponent of a real kind
======================================================

_Description_:
     `MINEXPONENT(X)' returns the minimum exponent in the model of the
     type of `X'.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = MINEXPONENT(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
     See `MAXEXPONENT' for an example.


File: gfortran.info,  Node: MINLOC,  Next: MINVAL,  Prev: MINEXPONENT,  Up: Intrinsic Procedures

6.142 `MINLOC' -- Location of the minimum value within an array
===============================================================

_Description_:
     Determines the location of the element in the array with the
     minimum value, or, if the DIM argument is supplied, determines the
     locations of the minimum element along each row of the array in the
     DIM direction.  If MASK is present, only the elements for which
     MASK is `.TRUE.' are considered.  If more than one element in the
     array has the minimum value, the location returned is that of the
     first such element in array element order.  If the array has zero
     size, or all of the elements of MASK are `.FALSE.', then the
     result is an array of zeroes.  Similarly, if DIM is supplied and
     all of the elements of MASK along a given row are zero, the result
     value for that row is zero.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MINLOC(ARRAY, DIM [, MASK])'
     `RESULT = MINLOC(ARRAY [, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER(*)',
                               `REAL(*)', or `CHARACTER(*)'.
     DIM        (Optional) Shall be a scalar of type
                            `INTEGER(*)', with a value
                between one 		       and the rank of
                ARRAY, inclusive.  It 		       may not be an
                optional dummy argument.
     MASK       Shall be an array of type `LOGICAL(*)',
                               and conformable with ARRAY.

_Return value_:
     If DIM is absent, the result is a rank-one array with a length
     equal to the rank of ARRAY.  If DIM is present, the result is an
     array with a rank one less than the rank of ARRAY, and a size
     corresponding to the size of ARRAY with the DIM dimension removed.
     If DIM is present and ARRAY has a rank of one, the result is a
     scalar.  In all cases, the result is of default `INTEGER' type.

_See also_:
     *Note MIN::, *Note MINVAL::



File: gfortran.info,  Node: MINVAL,  Next: MOD,  Prev: MINLOC,  Up: Intrinsic Procedures

6.143 `MINVAL' -- Minimum value of an array
===========================================

_Description_:
     Determines the minimum value of the elements in an array value,
     or, if the DIM argument is supplied, determines the minimum value
     along each row of the array in the DIM direction.  If MASK is
     present, only the elements for which MASK is `.TRUE.' are
     considered.  If the array has zero size, or all of the elements of
     MASK are `.FALSE.', then the result is `HUGE(ARRAY)' if ARRAY is
     numeric, or a string of `CHAR(255)' characters if ARRAY is of
     character type.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MINVAL(ARRAY, DIM [, MASK])'
     `RESULT = MINVAL(ARRAY [, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER(*)',
                               `REAL(*)', or `CHARACTER(*)'.
     DIM        (Optional) Shall be a scalar of type
                            `INTEGER(*)', with a value
                between one 		       and the rank of
                ARRAY, inclusive.  It 		       may not be an
                optional dummy argument.
     MASK       Shall be an array of type `LOGICAL(*)',
                               and conformable with ARRAY.

_Return value_:
     If DIM is absent, or if ARRAY has a rank of one, the result is a
     scalar.  If DIM is present, the result is an array with a rank one
     less than the rank of ARRAY, and a size corresponding to the size
     of ARRAY with the DIM dimension removed.  In all cases, the result
     is of the same type and kind as ARRAY.

_See also_:
     *Note MIN::, *Note MINLOC::



File: gfortran.info,  Node: MOD,  Next: MODULO,  Prev: MINVAL,  Up: Intrinsic Procedures

6.144 `MOD' -- Remainder function
=================================

_Description_:
     `MOD(A,P)' computes the remainder of the division of A by P. It is
     calculated as `A - (INT(A/P) * P)'.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MOD(A, P)'

_Arguments_:
     A          Shall be a scalar of type `INTEGER' or `REAL'
     P          Shall be a scalar of the same type as A and not
                equal to zero

_Return value_:
     The kind of the return value is the result of cross-promoting the
     kinds of the arguments.

_Example_:
          program test_mod
            print *, mod(17,3)
            print *, mod(17.5,5.5)
            print *, mod(17.5d0,5.5)
            print *, mod(17.5,5.5d0)

            print *, mod(-17,3)
            print *, mod(-17.5,5.5)
            print *, mod(-17.5d0,5.5)
            print *, mod(-17.5,5.5d0)

            print *, mod(17,-3)
            print *, mod(17.5,-5.5)
            print *, mod(17.5d0,-5.5)
            print *, mod(17.5,-5.5d0)
          end program test_mod

_Specific names_:
     Name          Arguments     Return type   Standard
     `AMOD(A,P)'   `REAL(4)'     `REAL(4)'     F95 and later
     `DMOD(A,P)'   `REAL(8)'     `REAL(8)'     F95 and later


File: gfortran.info,  Node: MODULO,  Next: MOVE_ALLOC,  Prev: MOD,  Up: Intrinsic Procedures

6.145 `MODULO' -- Modulo function
=================================

_Description_:
     `MODULO(A,P)' computes the A modulo P.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MODULO(A, P)'

_Arguments_:
     A          Shall be a scalar of type `INTEGER' or `REAL'
     P          Shall be a scalar of the same type and kind as
                A

_Return value_:
     The type and kind of the result are those of the arguments.
    If A and P are of type `INTEGER':
          `MODULO(A,P)' has the value R such that `A=Q*P+R', where Q is
          an integer and R is between 0 (inclusive) and P (exclusive).

    If A and P are of type `REAL':
          `MODULO(A,P)' has the value of `A - FLOOR (A / P) * P'.
     In all cases, if P is zero the result is processor-dependent.

_Example_:
          program test_modulo
            print *, modulo(17,3)
            print *, modulo(17.5,5.5)

            print *, modulo(-17,3)
            print *, modulo(-17.5,5.5)

            print *, modulo(17,-3)
            print *, modulo(17.5,-5.5)
          end program



File: gfortran.info,  Node: MOVE_ALLOC,  Next: MVBITS,  Prev: MODULO,  Up: Intrinsic Procedures

6.146 `MOVE_ALLOC' -- Move allocation from one object to another
================================================================

_Description_:
     `MOVE_ALLOC(SRC, DEST)' moves the allocation from SRC to DEST.
     SRC will become deallocated in the process.

_Standard_:
     F2003 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL MOVE_ALLOC(SRC, DEST)'

_Arguments_:
     SRC        `ALLOCATABLE', `INTENT(INOUT)', may be
                             of any type and kind.
     DEST       `ALLOCATABLE', `INTENT(OUT)', shall be
                             of the same type, kind and rank
                as SRC

_Return value_:
     None

_Example_:
          program test_move_alloc
              integer, allocatable :: a(:), b(:)

              allocate(a(3))
              a = [ 1, 2, 3 ]
              call move_alloc(a, b)
              print *, allocated(a), allocated(b)
              print *, b
          end program test_move_alloc


File: gfortran.info,  Node: MVBITS,  Next: NEAREST,  Prev: MOVE_ALLOC,  Up: Intrinsic Procedures

6.147 `MVBITS' -- Move bits from one integer to another
=======================================================

_Description_:
     Moves LEN bits from positions FROMPOS through `FROMPOS+LEN-1' of
     FROM to positions TOPOS through `TOPOS+LEN-1' of TO. The portion
     of argument TO not affected by the movement of bits is unchanged.
     The values of `FROMPOS+LEN-1' and `TOPOS+LEN-1' must be less than
     `BIT_SIZE(FROM)'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MVBITS(FROM, FROMPOS, LEN, TO, TOPOS)'

_Arguments_:
     FROM       The type shall be `INTEGER(*)'.
     FROMPOS    The type shall be `INTEGER(*)'.
     LEN        The type shall be `INTEGER(*)'.
     TO         The type shall be `INTEGER(*)', of the
                                same kind as FROM.
     TOPOS      The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)' and of the same kind as
     FROM.

_See also_:
     *Note IBCLR::, *Note IBSET::, *Note IBITS::, *Note IAND::, *Note
     IOR::, *Note IEOR::



File: gfortran.info,  Node: NEAREST,  Next: NEW_LINE,  Prev: MVBITS,  Up: Intrinsic Procedures

6.148 `NEAREST' -- Nearest representable number
===============================================

_Description_:
     `NEAREST(X, S)' returns the processor-representable number nearest
     to `X' in the direction indicated by the sign of `S'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = NEAREST(X, S)'

_Arguments_:
     X          Shall be of type `REAL'.
     S          (Optional) shall be of type `REAL' and not
                equal to zero.

_Return value_:
     The return value is of the same type as `X'. If `S' is positive,
     `NEAREST' returns the processor-representable number greater than
     `X' and nearest to it. If `S' is negative, `NEAREST' returns the
     processor-representable number smaller than `X' and nearest to it.

_Example_:
          program test_nearest
            real :: x, y
            x = nearest(42.0, 1.0)
            y = nearest(42.0, -1.0)
            write (*,"(3(G20.15))") x, y, x - y
          end program test_nearest


File: gfortran.info,  Node: NEW_LINE,  Next: NINT,  Prev: NEAREST,  Up: Intrinsic Procedures

6.149 `NEW_LINE' -- New line character
======================================

_Description_:
     `NEW_LINE(C)' returns the new-line character.

_Standard_:
     F2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = NEW_LINE(C)'

_Arguments_:
     C          The argument shall be a scalar or array of the
                                     type `CHARACTER'.

_Return value_:
     Returns a CHARACTER scalar of length one with the new-line
     character of the same kind as parameter C.

_Example_:
          program newline
            implicit none
            write(*,'(A)') 'This is record 1.'//NEW_LINE('A')//'This is record 2.'
          end program newline


File: gfortran.info,  Node: NINT,  Next: NOT,  Prev: NEW_LINE,  Up: Intrinsic Procedures

6.150 `NINT' -- Nearest whole number
====================================

_Description_:
     `NINT(X)' rounds its argument to the nearest whole number.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = NINT(X)'

_Arguments_:
     X          The type of the argument shall be `REAL'.

_Return value_:
     Returns A with the fractional portion of its magnitude eliminated
     by rounding to the nearest whole number and with its sign
     preserved, converted to an `INTEGER' of the default kind.

_Example_:
          program test_nint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, nint(x4), idnint(x8)
          end program test_nint

_Specific names_:
     Name              Argument          Standard
     `IDNINT(X)'       `REAL(8)'         F95 and later

_See also_:
     *Note CEILING::, *Note FLOOR::



File: gfortran.info,  Node: NOT,  Next: NULL,  Prev: NINT,  Up: Intrinsic Procedures

6.151 `NOT' -- Logical negation
===============================

_Description_:
     `NOT' returns the bitwise boolean inverse of I.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = NOT(I)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.

_Return value_:
     The return type is `INTEGER(*)', of the same kind as the argument.

_See also_:
     *Note IAND::, *Note IEOR::, *Note IOR::, *Note IBITS::, *Note
     IBSET::, *Note IBCLR::



File: gfortran.info,  Node: NULL,  Next: OR,  Prev: NOT,  Up: Intrinsic Procedures

6.152 `NULL' -- Function that returns an disassociated pointer
==============================================================

_Description_:
     Returns a disassociated pointer.

     If MOLD is present, a dissassociated pointer of the same type is
     returned, otherwise the type is determined by context.

     In Fortran 95, MOLD is optional. Please note that F2003 includes
     cases where it is required.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `PTR => NULL([MOLD])'

_Arguments_:
     MOLD       (Optional) shall be a pointer of any
                association status and of any type.

_Return value_:
     A disassociated pointer.

_Example_:
          REAL, POINTER, DIMENSION(:) :: VEC => NULL ()

_See also_:
     *Note ASSOCIATED::


File: gfortran.info,  Node: OR,  Next: PACK,  Prev: NULL,  Up: Intrinsic Procedures

6.153 `OR' -- Bitwise logical OR
================================

_Description_:
     Bitwise logical `OR'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *Note IOR:: intrinsic defined by the Fortran
     standard.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = OR(X, Y)'

_Arguments_:
     X          The type shall be either `INTEGER(*)' or
                `LOGICAL'.
     Y          The type shall be either `INTEGER(*)' or
                `LOGICAL'.

_Return value_:
     The return type is either `INTEGER(*)' or `LOGICAL' after
     cross-promotion of the arguments.

_Example_:
          PROGRAM test_or
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) OR(T, T), OR(T, F), OR(F, T), OR(F, F)
            WRITE (*,*) OR(a, b)
          END PROGRAM

_See also_:
     F95 elemental function: *Note IOR::


File: gfortran.info,  Node: PACK,  Next: PERROR,  Prev: OR,  Up: Intrinsic Procedures

6.154 `PACK' -- Pack an array into an array of rank one
=======================================================

_Description_:
     Stores the elements of ARRAY in an array of rank one.

     The beginning of the resulting array is made up of elements whose
     MASK equals `TRUE'. Afterwards, positions are filled with elements
     taken from VECTOR.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = PACK(ARRAY, MASK[,VECTOR]'

_Arguments_:
     ARRAY      Shall be an array of any type.
     MASK       Shall be an array of type `LOGICAL' and of the
                same size as ARRAY. Alternatively, it may be a
                `LOGICAL' scalar.
     VECTOR     (Optional) shall be an array of the same type
                as ARRAY and of rank one. If present, the
                number of elements in VECTOR shall be equal to
                or greater than the number of true elements in
                MASK. If MASK is scalar, the number of
                elements in VECTOR shall be equal to or
                greater than the number of elements in ARRAY.

_Return value_:
     The result is an array of rank one and the same type as that of
     ARRAY.  If VECTOR is present, the result size is that of VECTOR,
     the number of `TRUE' values in MASK otherwise.

_Example_:
     Gathering non-zero elements from an array:
          PROGRAM test_pack_1
            INTEGER :: m(6)
            m = (/ 1, 0, 0, 0, 5, 0 /)
            WRITE(*, FMT="(6(I0, ' '))") pack(m, m /= 0)  ! "1 5"
          END PROGRAM

     Gathering non-zero elements from an array and appending elements
     from VECTOR:
          PROGRAM test_pack_2
            INTEGER :: m(4)
            m = (/ 1, 0, 0, 2 /)
            WRITE(*, FMT="(4(I0, ' '))") pack(m, m /= 0, (/ 0, 0, 3, 4 /))  ! "1 2 3 4"
          END PROGRAM

_See also_:
     *Note UNPACK::


File: gfortran.info,  Node: PERROR,  Next: PRECISION,  Prev: PACK,  Up: Intrinsic Procedures

6.155 `PERROR' -- Print system error message
============================================

_Description_:
     Prints (on the C `stderr' stream) a newline-terminated error
     message corresponding to the last system error. This is prefixed by
     STRING, a colon and a space. See `perror(3)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL PERROR(STRING)'

_Arguments_:
     STRING     A scalar of default `CHARACTER' type.

_See also_:
     *Note IERRNO::


File: gfortran.info,  Node: PRECISION,  Next: PRESENT,  Prev: PERROR,  Up: Intrinsic Procedures

6.156 `PRECISION' -- Decimal precision of a real kind
=====================================================

_Description_:
     `PRECISION(X)' returns the decimal precision in the model of the
     type of `X'.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = PRECISION(X)'

_Arguments_:
     X          Shall be of type `REAL' or `COMPLEX'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          program prec_and_range
            real(kind=4) :: x(2)
            complex(kind=8) :: y

            print *, precision(x), range(x)
            print *, precision(y), range(y)
          end program prec_and_range


File: gfortran.info,  Node: PRESENT,  Next: PRODUCT,  Prev: PRECISION,  Up: Intrinsic Procedures

6.157 `PRESENT' -- Determine whether an optional dummy argument is specified
============================================================================

_Description_:
     Determines whether an optional dummy argument is present.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = PRESENT(A)'

_Arguments_:
     A          May be of any type and may be a pointer,
                scalar or array value, or a dummy procedure.
                It shall be the name of an optional dummy
                argument accessible within the current
                subroutine or function.

_Return value_:
     Returns either `TRUE' if the optional argument A is present, or
     `FALSE' otherwise.

_Example_:
          PROGRAM test_present
            WRITE(*,*) f(), f(42)      ! "F T"
          CONTAINS
            LOGICAL FUNCTION f(x)
              INTEGER, INTENT(IN), OPTIONAL :: x
              f = PRESENT(x)
            END FUNCTION
          END PROGRAM


File: gfortran.info,  Node: PRODUCT,  Next: RADIX,  Prev: PRESENT,  Up: Intrinsic Procedures

6.158 `PRODUCT' -- Product of array elements
============================================

_Description_:
     Multiplies the elements of ARRAY along dimension DIM if the
     corresponding element in MASK is `TRUE'.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = PRODUCT(ARRAY[, MASK])' `RESULT = PRODUCT(ARRAY, DIM[,
     MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER(*)',
                `REAL(*)' or `COMPLEX(*)'.
     DIM        (Optional) shall be a scalar of type `INTEGER'
                with a value in the range from 1 to n, where n
                equals the rank of ARRAY.
     MASK       (Optional) shall be of type `LOGICAL' and
                either be a scalar or an array of the same
                shape as ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the product of all elements in
     ARRAY is returned. Otherwise, an array of rank n-1, where n equals
     the rank of ARRAY, and a shape similar to that of ARRAY with
     dimension DIM dropped is returned.

_Example_:
          PROGRAM test_product
            INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)
            print *, PRODUCT(x)                    ! all elements, product = 120
            print *, PRODUCT(x, MASK=MOD(x, 2)==1) ! odd elements, product = 15
          END PROGRAM

_See also_:
     *Note SUM::


File: gfortran.info,  Node: RADIX,  Next: RANDOM_NUMBER,  Prev: PRODUCT,  Up: Intrinsic Procedures

6.159 `RADIX' -- Base of a model number
=======================================

_Description_:
     `RADIX(X)' returns the base of the model representing the entity X.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = RADIX(X)'

_Arguments_:
     X          Shall be of type `INTEGER' or `REAL'

_Return value_:
     The return value is a scalar of type `INTEGER' and of the default
     integer kind.

_Example_:
          program test_radix
            print *, "The radix for the default integer kind is", radix(0)
            print *, "The radix for the default real kind is", radix(0.0)
          end program test_radix



File: gfortran.info,  Node: RAN,  Next: REAL,  Prev: RANGE,  Up: Intrinsic Procedures

6.160 `RAN' -- Real pseudo-random number
========================================

_Description_:
     For compatibility with HP FORTRAN 77/iX, the `RAN' intrinsic is
     provided as an alias for `RAND'.  See *Note RAND:: for complete
     documentation.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_See also_:
     *Note RAND::, *Note RANDOM_NUMBER::


File: gfortran.info,  Node: RAND,  Next: RANGE,  Prev: RANDOM_SEED,  Up: Intrinsic Procedures

6.161 `RAND' -- Real pseudo-random number
=========================================

_Description_:
     `RAND(FLAG)' returns a pseudo-random number from a uniform
     distribution between 0 and 1. If FLAG is 0, the next number in the
     current sequence is returned; if FLAG is 1, the generator is
     restarted by `CALL SRAND(0)'; if FLAG has any other value, it is
     used as a new seed with `SRAND'.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = RAND(FLAG)'

_Arguments_:
     FLAG       Shall be a scalar `INTEGER' of kind 4.

_Return value_:
     The return value is of `REAL' type and the default kind.

_Example_:
          program test_rand
            integer,parameter :: seed = 86456

            call srand(seed)
            print *, rand(), rand(), rand(), rand()
            print *, rand(seed), rand(), rand(), rand()
          end program test_rand

_See also_:
     *Note SRAND::, *Note RANDOM_NUMBER::



File: gfortran.info,  Node: RANDOM_NUMBER,  Next: RANDOM_SEED,  Prev: RADIX,  Up: Intrinsic Procedures

6.162 `RANDOM_NUMBER' -- Pseudo-random number
=============================================

_Description_:
     Returns a single pseudorandom number or an array of pseudorandom
     numbers from the uniform distribution over the range  0 \leq x < 1.

_Standard_:
     F95 and later

_Class_:
     Elemental subroutine

_Syntax_:
     `RANDOM_NUMBER(HARVEST)'

_Arguments_:
     HARVEST    Shall be a scalar or an array of type
                `REAL(*)'.

_Example_:
          program test_random_number
            REAL :: r(5,5)
            CALL init_random_seed()         ! see example of RANDOM_SEED
            CALL RANDOM_NUMBER(r)
          end program

_Note_:
     The implemented random number generator is thread safe if used
     within OpenMP directives, i. e. its state will be consistent while
     called from multiple threads. Please note that the currently
     implemented KISS generator does not create random numbers in
     parallel from multiple sources, but in sequence from a single
     source. If your OpenMP-enabled application heavily relies on
     random numbers, you should consider employing a dedicated parallel
     random number generator instead.

_See also_:
     *Note RANDOM_SEED::


File: gfortran.info,  Node: RANDOM_SEED,  Next: RAND,  Prev: RANDOM_NUMBER,  Up: Intrinsic Procedures

6.163 `RANDOM_SEED' -- Initialize a pseudo-random number sequence
=================================================================

_Description_:
     Restarts or queries the state of the pseudorandom number generator
     used by `RANDOM_NUMBER'.

     If `RANDOM_SEED' is called without arguments, it is initialized to
     a default state. The example below shows how to initialize the
     random seed based on the system's time.

_Standard_:
     F95 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL RANDOM_SEED(SIZE, PUT, GET)'

_Arguments_:
     SIZE       (Optional) Shall be a scalar and of type
                default `INTEGER', with `INTENT(OUT)'. It
                specifies the minimum size of the arrays used
                with the PUT and GET arguments.
     PUT        (Optional) Shall be an array of type default
                `INTEGER' and rank one. It is `INTENT(IN)' and
                the size of the array must be larger than or
                equal to the number returned by the SIZE
                argument.
     GET        (Optional) Shall be an array of type default
                `INTEGER' and rank one. It is `INTENT(OUT)'
                and the size of the array must be larger than
                or equal to the number returned by the SIZE
                argument.

_Example_:
          SUBROUTINE init_random_seed()
            INTEGER :: i, n, clock
            INTEGER, DIMENSION(:), ALLOCATABLE :: seed

            CALL RANDOM_SEED(size = n)
            ALLOCATE(seed(n))

            CALL SYSTEM_CLOCK(COUNT=clock)

            seed = clock + 37 * (/ (i - 1, i = 1, n) /)
            CALL RANDOM_SEED(PUT = seed)

            DEALLOCATE(seed)
          END SUBROUTINE

_See also_:
     *Note RANDOM_NUMBER::


File: gfortran.info,  Node: RANGE,  Next: RAN,  Prev: RAND,  Up: Intrinsic Procedures

6.164 `RANGE' -- Decimal exponent range of a real kind
======================================================

_Description_:
     `RANGE(X)' returns the decimal exponent range in the model of the
     type of `X'.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = RANGE(X)'

_Arguments_:
     X          Shall be of type `REAL' or `COMPLEX'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
     See `PRECISION' for an example.


File: gfortran.info,  Node: REAL,  Next: RENAME,  Prev: RAN,  Up: Intrinsic Procedures

6.165 `REAL' -- Convert to real type
====================================

_Description_:
     `REAL(X [, KIND])' converts its argument X to a real type.  The
     `REALPART(X)' function is provided for compatibility with `g77',
     and its use is strongly discouraged.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = REAL(X [, KIND])'
     `RESULT = REALPART(Z)'

_Arguments_:
     X          Shall be `INTEGER(*)', `REAL(*)', or
                           `COMPLEX(*)'.
     KIND       (Optional) An `INTEGER(*)' initialization
                                expression indicating the
                kind parameter of 		      the result.

_Return value_:
     These functions return a `REAL(*)' variable or array under the
     following rules:

    (A)
          `REAL(X)' is converted to a default real type if X is an
          integer or real variable.

    (B)
          `REAL(X)' is converted to a real type with the kind type
          parameter of X if X is a complex variable.

    (C)
          `REAL(X, KIND)' is converted to a real type with kind type
          parameter KIND if X is a complex, integer, or real variable.

_Example_:
          program test_real
            complex :: x = (1.0, 2.0)
            print *, real(x), real(x,8), realpart(x)
          end program test_real

_See also_:
     *Note DBLE::, *Note DFLOAT::, *Note FLOAT::



File: gfortran.info,  Node: RENAME,  Next: REPEAT,  Prev: REAL,  Up: Intrinsic Procedures

6.166 `RENAME' -- Rename a file
===============================

_Description_:
     Renames a file from file PATH1 to PATH2. A null character
     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see `rename(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL RENAME(PATH1, PATH2 [, STATUS])'
     `STATUS = RENAME(PATH1, PATH2)'

_Arguments_:
     PATH1      Shall be of default `CHARACTER' type.
     PATH2      Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:
     *Note LINK::



File: gfortran.info,  Node: REPEAT,  Next: RESHAPE,  Prev: RENAME,  Up: Intrinsic Procedures

6.167 `REPEAT' -- Repeated string concatenation
===============================================

_Description_:
     Concatenates NCOPIES copies of a string.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = REPEAT(STRING, NCOPIES)'

_Arguments_:
     STRING     Shall be scalar and of type `CHARACTER(*)'.
     NCOPIES    Shall be scalar and of type `INTEGER(*)'.

_Return value_:
     A new scalar of type `CHARACTER' built up from NCOPIES copies of
     STRING.

_Example_:
          program test_repeat
            write(*,*) repeat("x", 5)   ! "xxxxx"
          end program


File: gfortran.info,  Node: RESHAPE,  Next: RRSPACING,  Prev: REPEAT,  Up: Intrinsic Procedures

6.168 `RESHAPE' -- Function to reshape an array
===============================================

_Description_:
     Reshapes SOURCE to correspond to SHAPE. If necessary, the new
     array may be padded with elements from PAD or permuted as defined
     by ORDER.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = RESHAPE(SOURCE, SHAPE[, PAD, ORDER])'

_Arguments_:
     SOURCE     Shall be an array of any type.
     SHAPE      Shall be of type `INTEGER' and an array of
                rank one. Its values must be positive or zero.
     PAD        (Optional) shall be an array of the same type
                as SOURCE.
     ORDER      (Optional) shall be of type `INTEGER' and an
                array of the same shape as SHAPE. Its values
                shall be a permutation of the numbers from 1
                to n, where n is the size of SHAPE. If ORDER
                is absent, the natural ordering shall be
                assumed.

_Return value_:
     The result is an array of shape SHAPE with the same type as SOURCE.

_Example_:
          PROGRAM test_reshape
            INTEGER, DIMENSION(4) :: x
            WRITE(*,*) SHAPE(x)                       ! prints "4"
            WRITE(*,*) SHAPE(RESHAPE(x, (/2, 2/)))    ! prints "2 2"
          END PROGRAM

_See also_:
     *Note SHAPE::


File: gfortran.info,  Node: RRSPACING,  Next: RSHIFT,  Prev: RESHAPE,  Up: Intrinsic Procedures

6.169 `RRSPACING' -- Reciprocal of the relative spacing
=======================================================

_Description_:
     `RRSPACING(X)' returns the  reciprocal of the relative spacing of
     model numbers near X.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = RRSPACING(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The return value is of the same type and kind as X.  The value
     returned is equal to `ABS(FRACTION(X)) *
     FLOAT(RADIX(X))**DIGITS(X)'.

_See also_:
     *Note SPACING::


File: gfortran.info,  Node: RSHIFT,  Next: SCALE,  Prev: RRSPACING,  Up: Intrinsic Procedures

6.170 `RSHIFT' -- Right shift bits
==================================

_Description_:
     `RSHIFT' returns a value corresponding to I with all of the bits
     shifted right by SHIFT places.  If the absolute value of SHIFT is
     greater than `BIT_SIZE(I)', the value is undefined.  Bits shifted
     out from the left end are lost; zeros are shifted in from the
     opposite end.

     This function has been superseded by the `ISHFT' intrinsic, which
     is standard in Fortran 95 and later.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = RSHIFT(I, SHIFT)'

_Arguments_:
     I          The type shall be `INTEGER(*)'.
     SHIFT      The type shall be `INTEGER(*)'.

_Return value_:
     The return value is of type `INTEGER(*)' and of the same kind as I.

_See also_:
     *Note ISHFT::, *Note ISHFTC::, *Note LSHIFT::



File: gfortran.info,  Node: SCALE,  Next: SCAN,  Prev: RSHIFT,  Up: Intrinsic Procedures

6.171 `SCALE' -- Scale a real value
===================================

_Description_:
     `SCALE(X,I)' returns `X * RADIX(X)**I'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SCALE(X, I)'

_Arguments_:
     X          The type of the argument shall be a `REAL'.
     I          The type of the argument shall be a `INTEGER'.

_Return value_:
     The return value is of the same type and kind as X.  Its value is
     `X * RADIX(X)**I'.

_Example_:
          program test_scale
            real :: x = 178.1387e-4
            integer :: i = 5
            print *, scale(x,i), x*radix(x)**i
          end program test_scale



File: gfortran.info,  Node: SCAN,  Next: SECNDS,  Prev: SCALE,  Up: Intrinsic Procedures

6.172 `SCAN' -- Scan a string for the presence of a set of characters
=====================================================================

_Description_:
     Scans a STRING for any of the characters in a SET of characters.

     If BACK is either absent or equals `FALSE', this function returns
     the position of the leftmost character of STRING that is in SET.
     If BACK equals `TRUE', the rightmost position is returned. If no
     character of SET is found in STRING, the result is zero.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SCAN(STRING, SET[, BACK])'

_Arguments_:
     STRING     Shall be of type `CHARACTER(*)'.
     SET        Shall be of type `CHARACTER(*)'.
     BACK       (Optional) shall be of type `LOGICAL'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          PROGRAM test_scan
            WRITE(*,*) SCAN("FORTRAN", "AO")          ! 2, found 'O'
            WRITE(*,*) SCAN("FORTRAN", "AO", .TRUE.)  ! 6, found 'A'
            WRITE(*,*) SCAN("FORTRAN", "C++")         ! 0, found none
          END PROGRAM

_See also_:
     *Note INDEX::, *Note VERIFY::


File: gfortran.info,  Node: SECNDS,  Next: SECOND,  Prev: SCAN,  Up: Intrinsic Procedures

6.173 `SECNDS' -- Time function
===============================

_Description_:
     `SECNDS(X)' gets the time in seconds from the real-time system
     clock.  X is a reference time, also in seconds. If this is zero,
     the time in seconds from midnight is returned. This function is
     non-standard and its use is discouraged.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = SECNDS (X)'

_Arguments_:
     T          Shall be of type `REAL(4)'.
     X          Shall be of type `REAL(4)'.

_Return value_:
     None

_Example_:
          program test_secnds
              integer :: i
              real(4) :: t1, t2
              print *, secnds (0.0)   ! seconds since midnight
              t1 = secnds (0.0)       ! reference time
              do i = 1, 10000000      ! do something
              end do
              t2 = secnds (t1)        ! elapsed time
              print *, "Something took ", t2, " seconds."
          end program test_secnds


File: gfortran.info,  Node: SECOND,  Next: SELECTED_INT_KIND,  Prev: SECNDS,  Up: Intrinsic Procedures

6.174 `SECOND' -- CPU time function
===================================

_Description_:
     Returns a `REAL(4)' value representing the elapsed CPU time in
     seconds.  This provides the same functionality as the standard
     `CPU_TIME' intrinsic, and is only included for backwards
     compatibility.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL SECOND(TIME)'
     `TIME = SECOND()'

_Arguments_:
     TIME       Shall be of type `REAL(4)'.

_Return value_:
     In either syntax, TIME is set to the process's current runtime in
     seconds.

_See also_:
     *Note CPU_TIME::



File: gfortran.info,  Node: SELECTED_INT_KIND,  Next: SELECTED_REAL_KIND,  Prev: SECOND,  Up: Intrinsic Procedures

6.175 `SELECTED_INT_KIND' -- Choose integer kind
================================================

_Description_:
     `SELECTED_INT_KIND(I)' return the kind value of the smallest
     integer type that can represent all values ranging from -10^I
     (exclusive) to 10^I (exclusive). If there is no integer kind that
     accommodates this range, `SELECTED_INT_KIND' returns -1.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SELECTED_INT_KIND(I)'

_Arguments_:
     I          Shall be a scalar and of type `INTEGER'.

_Example_:
          program large_integers
            integer,parameter :: k5 = selected_int_kind(5)
            integer,parameter :: k15 = selected_int_kind(15)
            integer(kind=k5) :: i5
            integer(kind=k15) :: i15

            print *, huge(i5), huge(i15)

            ! The following inequalities are always true
            print *, huge(i5) >= 10_k5**5-1
            print *, huge(i15) >= 10_k15**15-1
          end program large_integers


File: gfortran.info,  Node: SELECTED_REAL_KIND,  Next: SET_EXPONENT,  Prev: SELECTED_INT_KIND,  Up: Intrinsic Procedures

6.176 `SELECTED_REAL_KIND' -- Choose real kind
==============================================

_Description_:
     `SELECTED_REAL_KIND(P,R)' return the kind value of a real data type
     with decimal precision greater of at least `P' digits and exponent
     range greater at least `R'.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SELECTED_REAL_KIND(P, R)'

_Arguments_:
     P          (Optional) shall be a scalar and of type
                `INTEGER'.
     R          (Optional) shall be a scalar and of type
                `INTEGER'.
     At least one argument shall be present.

_Return value_:
     `SELECTED_REAL_KIND' returns the value of the kind type parameter
     of a real data type with decimal precision of at least `P' digits
     and a decimal exponent range of at least `R'. If more than one
     real data type meet the criteria, the kind of the data type with
     the smallest decimal precision is returned. If no real data type
     matches the criteria, the result is
    -1 if the processor does not support a real data type with a
          precision greater than or equal to `P'

    -2 if the processor does not support a real type with an exponent
          range greater than or equal to `R'

    -3 if neither is supported.

_Example_:
          program real_kinds
            integer,parameter :: p6 = selected_real_kind(6)
            integer,parameter :: p10r100 = selected_real_kind(10,100)
            integer,parameter :: r400 = selected_real_kind(r=400)
            real(kind=p6) :: x
            real(kind=p10r100) :: y
            real(kind=r400) :: z

            print *, precision(x), range(x)
            print *, precision(y), range(y)
            print *, precision(z), range(z)
          end program real_kinds


File: gfortran.info,  Node: SET_EXPONENT,  Next: SHAPE,  Prev: SELECTED_REAL_KIND,  Up: Intrinsic Procedures

6.177 `SET_EXPONENT' -- Set the exponent of the model
=====================================================

_Description_:
     `SET_EXPONENT(X, I)' returns the real number whose fractional part
     is that that of X and whose exponent part is I.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SET_EXPONENT(X, I)'

_Arguments_:
     X          Shall be of type `REAL'.
     I          Shall be of type `INTEGER'.

_Return value_:
     The return value is of the same type and kind as X.  The real
     number whose fractional part is that that of X and whose exponent
     part if I is returned; it is `FRACTION(X) * RADIX(X)**I'.

_Example_:
          PROGRAM test_setexp
            REAL :: x = 178.1387e-4
            INTEGER :: i = 17
            PRINT *, SET_EXPONENT(x, i), FRACTION(x) * RADIX(x)**i
          END PROGRAM



File: gfortran.info,  Node: SHAPE,  Next: SIGN,  Prev: SET_EXPONENT,  Up: Intrinsic Procedures

6.178 `SHAPE' -- Determine the shape of an array
================================================

_Description_:
     Determines the shape of an array.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = SHAPE(SOURCE)'

_Arguments_:
     SOURCE     Shall be an array or scalar of any type.  If
                SOURCE is a pointer it must be associated and
                allocatable arrays must be allocated.

_Return value_:
     An `INTEGER' array of rank one with as many elements as SOURCE has
     dimensions. The elements of the resulting array correspond to the
     extend of SOURCE along the respective dimensions. If SOURCE is a
     scalar, the result is the rank one array of size zero.

_Example_:
          PROGRAM test_shape
            INTEGER, DIMENSION(-1:1, -1:2) :: A
            WRITE(*,*) SHAPE(A)             ! (/ 3, 4 /)
            WRITE(*,*) SIZE(SHAPE(42))      ! (/ /)
          END PROGRAM

_See also_:
     *Note RESHAPE::, *Note SIZE::


File: gfortran.info,  Node: SIGN,  Next: SIGNAL,  Prev: SHAPE,  Up: Intrinsic Procedures

6.179 `SIGN' -- Sign copying function
=====================================

_Description_:
     `SIGN(A,B)' returns the value of A with the sign of B.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SIGN(A, B)'

_Arguments_:
     A          Shall be of type `INTEGER' or `REAL'
     B          Shall be of the same type and kind as A

_Return value_:
     The kind of the return value is that of A and B.  If B\ge 0 then
     the result is `ABS(A)', else it is `-ABS(A)'.

_Example_:
          program test_sign
            print *, sign(-12,1)
            print *, sign(-12,0)
            print *, sign(-12,-1)

            print *, sign(-12.,1.)
            print *, sign(-12.,0.)
            print *, sign(-12.,-1.)
          end program test_sign

_Specific names_:
     Name          Arguments     Return type   Standard
     `ISIGN(A,P)'  `INTEGER(4)'  `INTEGER(4)'  f95, gnu
     `DSIGN(A,P)'  `REAL(8)'     `REAL(8)'     f95, gnu


File: gfortran.info,  Node: SIGNAL,  Next: SIN,  Prev: SIGN,  Up: Intrinsic Procedures

6.180 `SIGNAL' -- Signal handling subroutine (or function)
==========================================================

_Description_:
     `SIGNAL(NUMBER, HANDLER [, STATUS])' causes external subroutine
     HANDLER to be executed with a single integer argument when signal
     NUMBER occurs.  If HANDLER is an integer, it can be used to turn
     off handling of signal NUMBER or revert to its default action.
     See `signal(2)'.

     If `SIGNAL' is called as a subroutine and the STATUS argument is
     supplied, it is set to the value returned by `signal(2)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL SIGNAL(NUMBER, HANDLER [, STATUS])'
     `STATUS = SIGNAL(NUMBER, HANDLER)'

_Arguments_:
     NUMBER     Shall be a scalar integer, with `INTENT(IN)'
     HANDLER    Signal handler (`INTEGER FUNCTION' or
                `SUBROUTINE') or dummy/global `INTEGER' scalar.
                `INTEGER'. It is `INTENT(IN)'.
     STATUS     (Optional) STATUS shall be a scalar integer.
                It has `INTENT(OUT)'.

_Return value_:
     The `SIGNAL' function returns the value returned by `signal(2)'.

_Example_:
          program test_signal
            intrinsic signal
            external handler_print

            call signal (12, handler_print)
            call signal (10, 1)

            call sleep (30)
          end program test_signal


File: gfortran.info,  Node: SIN,  Next: SINH,  Prev: SIGNAL,  Up: Intrinsic Procedures

6.181 `SIN' -- Sine function
============================

_Description_:
     `SIN(X)' computes the sine of X.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SIN(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          program test_sin
            real :: x = 0.0
            x = sin(x)
          end program test_sin

_Specific names_:
     Name          Argument      Return type   Standard
     `DSIN(X)'     `REAL(8) X'   `REAL(8)'     f95, gnu
     `CSIN(X)'     `COMPLEX(4)   `COMPLEX(4)'  f95, gnu
                   X'                          
     `ZSIN(X)'     `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
                   X'                          
     `CDSIN(X)'    `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
                   X'                          

_See also_:
     *Note ASIN::


File: gfortran.info,  Node: SINH,  Next: SIZE,  Prev: SIN,  Up: Intrinsic Procedures

6.182 `SINH' -- Hyperbolic sine function
========================================

_Description_:
     `SINH(X)' computes the hyperbolic sine of X.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SINH(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)'.

_Example_:
          program test_sinh
            real(8) :: x = - 1.0_8
            x = sinh(x)
          end program test_sinh

_Specific names_:
     Name          Argument      Return type   Standard
     `DSINH(X)'    `REAL(8) X'   `REAL(8)'     F95 and later

_See also_:
     *Note ASINH::


File: gfortran.info,  Node: SIZE,  Next: SLEEP,  Prev: SINH,  Up: Intrinsic Procedures

6.183 `SIZE' -- Determine the size of an array
==============================================

_Description_:
     Determine the extent of ARRAY along a specified dimension DIM, or
     the total number of elements in ARRAY if DIM is absent.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = SIZE(ARRAY[, DIM])'

_Arguments_:
     ARRAY      Shall be an array of any type. If ARRAY is a
                pointer it must be associated and allocatable
                arrays must be allocated.
     DIM        (Optional) shall be a scalar of type `INTEGER'
                and its value shall be in the range from 1 to
                n, where n equals the rank of ARRAY.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          PROGRAM test_size
            WRITE(*,*) SIZE((/ 1, 2 /))    ! 2
          END PROGRAM

_See also_:
     *Note SHAPE::, *Note RESHAPE::


File: gfortran.info,  Node: SLEEP,  Next: SNGL,  Prev: SIZE,  Up: Intrinsic Procedures

6.184 `SLEEP' -- Sleep for the specified number of seconds
==========================================================

_Description_:
     Calling this subroutine causes the process to pause for SECONDS
     seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL SLEEP(SECONDS)'

_Arguments_:
     SECONDS    The type shall be of default `INTEGER'.

_Example_:
          program test_sleep
            call sleep(5)
          end


File: gfortran.info,  Node: SNGL,  Next: SPACING,  Prev: SLEEP,  Up: Intrinsic Procedures

6.185 `SNGL' -- Convert double precision real to default real
=============================================================

_Description_:
     `SNGL(A)' converts the double precision real A to a default real
     value. This is an archaic form of `REAL' that is specific to one
     type for A.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SNGL(A)'

_Arguments_:
     A          The type shall be a double precision `REAL'.

_Return value_:
     The return value is of type default `REAL'.

_See also_:
     *Note DBLE::


File: gfortran.info,  Node: SPACING,  Next: SPREAD,  Prev: SNGL,  Up: Intrinsic Procedures

6.186 `SPACING' -- Smallest distance between two numbers of a given type
========================================================================

_Description_:
     Determines the distance between the argument X and the nearest
     adjacent number of the same type.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SPACING(X)'

_Arguments_:
     X          Shall be of type `REAL(*)'.

_Return value_:
     The result is of the same type as the input argument X.

_Example_:
          PROGRAM test_spacing
            INTEGER, PARAMETER :: SGL = SELECTED_REAL_KIND(p=6, r=37)
            INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(p=13, r=200)

            WRITE(*,*) spacing(1.0_SGL)      ! "1.1920929E-07"          on i686
            WRITE(*,*) spacing(1.0_DBL)      ! "2.220446049250313E-016" on i686
          END PROGRAM

_See also_:
     *Note RRSPACING::


File: gfortran.info,  Node: SPREAD,  Next: SQRT,  Prev: SPACING,  Up: Intrinsic Procedures

6.187 `SPREAD' -- Add a dimension to an array
=============================================

_Description_:
     Replicates a SOURCE array NCOPIES times along a specified
     dimension DIM.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SPREAD(SOURCE, DIM, NCOPIES)'

_Arguments_:
     SOURCE     Shall be a scalar or an array of any type and
                a rank less than seven.
     DIM        Shall be a scalar of type `INTEGER' with a
                value in the range from 1 to n+1, where n
                equals the rank of SOURCE.
     NCOPIES    Shall be a scalar of type `INTEGER'.

_Return value_:
     The result is an array of the same type as SOURCE and has rank n+1
     where n equals the rank of SOURCE.

_Example_:
          PROGRAM test_spread
            INTEGER :: a = 1, b(2) = (/ 1, 2 /)
            WRITE(*,*) SPREAD(A, 1, 2)            ! "1 1"
            WRITE(*,*) SPREAD(B, 1, 2)            ! "1 1 2 2"
          END PROGRAM

_See also_:
     *Note UNPACK::


File: gfortran.info,  Node: SQRT,  Next: SRAND,  Prev: SPREAD,  Up: Intrinsic Procedures

6.188 `SQRT' -- Square-root function
====================================

_Description_:
     `SQRT(X)' computes the square root of X.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SQRT(X)'

_Arguments_:
     X          The type shall be `REAL(*)' or `COMPLEX(*)'.

_Return value_:
     The return value is of type `REAL(*)' or `COMPLEX(*)'.  The kind
     type parameter is the same as X.

_Example_:
          program test_sqrt
            real(8) :: x = 2.0_8
            complex :: z = (1.0, 2.0)
            x = sqrt(x)
            z = sqrt(z)
          end program test_sqrt

_Specific names_:
     Name          Argument      Return type   Standard
     `DSQRT(X)'    `REAL(8) X'   `REAL(8)'     F95 and later
     `CSQRT(X)'    `COMPLEX(4)   `COMPLEX(4)'  F95 and later
                   X'                          
     `ZSQRT(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          
     `CDSQRT(X)'   `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          


File: gfortran.info,  Node: SRAND,  Next: STAT,  Prev: SQRT,  Up: Intrinsic Procedures

6.189 `SRAND' -- Reinitialize the random number generator
=========================================================

_Description_:
     `SRAND' reinitializes the pseudo-random number generator called by
     `RAND' and `IRAND'. The new seed used by the generator is
     specified by the required argument SEED.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL SRAND(SEED)'

_Arguments_:
     SEED       Shall be a scalar `INTEGER(kind=4)'.

_Return value_:
     Does not return.

_Example_:
     See `RAND' and `IRAND' for examples.

_Notes_:
     The Fortran 2003 standard specifies the intrinsic `RANDOM_SEED' to
     initialize the pseudo-random numbers generator and `RANDOM_NUMBER'
     to generate pseudo-random numbers. Please note that in GNU
     Fortran, these two sets of intrinsics (`RAND', `IRAND' and `SRAND'
     on the one hand, `RANDOM_NUMBER' and `RANDOM_SEED' on the other
     hand) access two independent pseudo-random number generators.

_See also_:
     *Note RAND::, *Note RANDOM_SEED::, *Note RANDOM_NUMBER::



File: gfortran.info,  Node: STAT,  Next: SUM,  Prev: SRAND,  Up: Intrinsic Procedures

6.190 `STAT' -- Get file status
===============================

_Description_:
     This function returns information about a file. No permissions are
     required on the file itself, but execute (search) permission is
     required on all of the directories in path that lead to the file.

     The elements that are obtained and stored in the array `BUFF':
     `buff(1)'  Device ID
     `buff(2)'  Inode number
     `buff(3)'  File mode
     `buff(4)'  Number of links
     `buff(5)'  Owner's uid
     `buff(6)'  Owner's gid
     `buff(7)'  ID of device containing directory entry for
                file (0 if not available)
     `buff(8)'  File size (bytes)
     `buff(9)'  Last access time
     `buff(10)' Last modification time
     `buff(11)' Last file status change time
     `buff(12)' Preferred I/O block size (-1 if not available)
     `buff(13)' Number of blocks allocated (-1 if not
                available)

     Not all these elements are relevant on all systems.  If an element
     is not relevant, it is returned as 0.

_Standard_:
     GNU extension

_Class_:
     Non-elemental subroutine

_Syntax_:
     `CALL STAT(FILE,BUFF[,STATUS])'

_Arguments_:
     FILE       The type shall be `CHARACTER(*)', a valid path
                within the file system.
     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
     STATUS     (Optional) status flag of type `INTEGER(4)'.
                Returns 0                         on success
                and a system specific error code otherwise.

_Example_:
          PROGRAM test_stat
            INTEGER, DIMENSION(13) :: buff
            INTEGER :: status

            CALL STAT("/etc/passwd", buff, status)

            IF (status == 0) THEN
              WRITE (*, FMT="('Device ID:',               T30, I19)") buff(1)
              WRITE (*, FMT="('Inode number:',            T30, I19)") buff(2)
              WRITE (*, FMT="('File mode (octal):',       T30, O19)") buff(3)
              WRITE (*, FMT="('Number of links:',         T30, I19)") buff(4)
              WRITE (*, FMT="('Owner''s uid:',            T30, I19)") buff(5)
              WRITE (*, FMT="('Owner''s gid:',            T30, I19)") buff(6)
              WRITE (*, FMT="('Device where located:',    T30, I19)") buff(7)
              WRITE (*, FMT="('File size:',               T30, I19)") buff(8)
              WRITE (*, FMT="('Last access time:',        T30, A19)") CTIME(buff(9))
              WRITE (*, FMT="('Last modification time',   T30, A19)") CTIME(buff(10))
              WRITE (*, FMT="('Last status change time:', T30, A19)") CTIME(buff(11))
              WRITE (*, FMT="('Preferred block size:',    T30, I19)") buff(12)
              WRITE (*, FMT="('No. of blocks allocated:', T30, I19)") buff(13)
            END IF
          END PROGRAM

_See also_:
     To stat an open file: *Note FSTAT::, to stat a link: *Note LSTAT::


File: gfortran.info,  Node: SUM,  Next: SYMLNK,  Prev: STAT,  Up: Intrinsic Procedures

6.191 `SUM' -- Sum of array elements
====================================

_Description_:
     Adds the elements of ARRAY along dimension DIM if the
     corresponding element in MASK is `TRUE'.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SUM(ARRAY[, MASK])' `RESULT = SUM(ARRAY, DIM[, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER(*)',
                `REAL(*)' or `COMPLEX(*)'.
     DIM        (Optional) shall be a scalar of type `INTEGER'
                with a value in the range from 1 to n, where n
                equals the rank of ARRAY.
     MASK       (Optional) shall be of type `LOGICAL' and
                either be a scalar or an array of the same
                shape as ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the sum of all elements in ARRAY
     is returned. Otherwise, an array of rank n-1, where n equals the
     rank of ARRAY,and a shape similar to that of ARRAY with dimension
     DIM dropped is returned.

_Example_:
          PROGRAM test_sum
            INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)
            print *, SUM(x)                        ! all elements, sum = 15
            print *, SUM(x, MASK=MOD(x, 2)==1)     ! odd elements, sum = 9
          END PROGRAM

_See also_:
     *Note PRODUCT::


File: gfortran.info,  Node: SYMLNK,  Next: SYSTEM,  Prev: SUM,  Up: Intrinsic Procedures

6.192 `SYMLNK' -- Create a symbolic link
========================================

_Description_:
     Makes a symbolic link from file PATH1 to PATH2. A null character
     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see `symlink(2)'.  If the system
     does not supply `symlink(2)', `ENOSYS' is returned.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL SYMLNK(PATH1, PATH2 [, STATUS])'
     `STATUS = SYMLNK(PATH1, PATH2)'

_Arguments_:
     PATH1      Shall be of default `CHARACTER' type.
     PATH2      Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:
     *Note LINK::, *Note UNLINK::



File: gfortran.info,  Node: SYSTEM,  Next: SYSTEM_CLOCK,  Prev: SYMLNK,  Up: Intrinsic Procedures

6.193 `SYSTEM' -- Execute a shell command
=========================================

_Description_:
     Passes the command COMMAND to a shell (see `system(3)'). If
     argument STATUS is present, it contains the value returned by
     `system(3)', which is presumably 0 if the shell command succeeded.
     Note that which shell is used to invoke the command is
     system-dependent and environment-dependent.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL SYSTEM(COMMAND [, STATUS])'
     `STATUS = SYSTEM(COMMAND)'

_Arguments_:
     COMMAND    Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:


File: gfortran.info,  Node: SYSTEM_CLOCK,  Next: TAN,  Prev: SYSTEM,  Up: Intrinsic Procedures

6.194 `SYSTEM_CLOCK' -- Time function
=====================================

_Description_:
     Determines the COUNT of milliseconds of wall clock time since the
     Epoch (00:00:00 UTC, January 1, 1970) modulo COUNT_MAX, COUNT_RATE
     determines the number of clock ticks per second.  COUNT_RATE and
     COUNT_MAX are constant and specific to `gfortran'.

     If there is no clock, COUNT is set to `-HUGE(COUNT)', and
     COUNT_RATE and COUNT_MAX are set to zero

_Standard_:
     F95 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL SYSTEM_CLOCK([COUNT, COUNT_RATE, COUNT_MAX])'

_Arguments_:

_Arguments_:
     COUNT      (Optional) shall be a scalar of type default
                `INTEGER' with `INTENT(OUT)'.
     COUNT_RATE (Optional) shall be a scalar of type default
                `INTEGER' with `INTENT(OUT)'.
     COUNT_MAX  (Optional) shall be a scalar of type default
                `INTEGER' with `INTENT(OUT)'.

_Example_:
          PROGRAM test_system_clock
            INTEGER :: count, count_rate, count_max
            CALL SYSTEM_CLOCK(count, count_rate, count_max)
            WRITE(*,*) count, count_rate, count_max
          END PROGRAM

_See also_:
     *Note DATE_AND_TIME::, *Note CPU_TIME::


File: gfortran.info,  Node: TAN,  Next: TANH,  Prev: SYSTEM_CLOCK,  Up: Intrinsic Procedures

6.195 `TAN' -- Tangent function
===============================

_Description_:
     `TAN(X)' computes the tangent of X.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = TAN(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)'.  The kind type parameter is
     the same as X.

_Example_:
          program test_tan
            real(8) :: x = 0.165_8
            x = tan(x)
          end program test_tan

_Specific names_:
     Name          Argument      Return type   Standard
     `DTAN(X)'     `REAL(8) X'   `REAL(8)'     F95 and later

_See also_:
     *Note ATAN::


File: gfortran.info,  Node: TANH,  Next: TIME,  Prev: TAN,  Up: Intrinsic Procedures

6.196 `TANH' -- Hyperbolic tangent function
===========================================

_Description_:
     `TANH(X)' computes the hyperbolic tangent of X.

_Standard_:
     F77 and later

_Class_:
     Elemental function

_Syntax_:
     `X = TANH(X)'

_Arguments_:
     X          The type shall be `REAL(*)'.

_Return value_:
     The return value is of type `REAL(*)' and lies in the range  - 1
     \leq tanh(x) \leq 1 .

_Example_:
          program test_tanh
            real(8) :: x = 2.1_8
            x = tanh(x)
          end program test_tanh

_Specific names_:
     Name          Argument      Return type   Standard
     `DTANH(X)'    `REAL(8) X'   `REAL(8)'     F95 and later

_See also_:
     *Note ATANH::


File: gfortran.info,  Node: TIME,  Next: TIME8,  Prev: TANH,  Up: Intrinsic Procedures

6.197 `TIME' -- Time function
=============================

_Description_:
     Returns the current time encoded as an integer (in the manner of
     the UNIX function `time(3)'). This value is suitable for passing to
     `CTIME()', `GMTIME()', and `LTIME()'.

     This intrinsic is not fully portable, such as to systems with
     32-bit `INTEGER' types but supporting times wider than 32 bits.
     Therefore, the values returned by this intrinsic might be, or
     become, negative, or numerically less than previous values, during
     a single run of the compiled program.

     See *Note TIME8::, for information on a similar intrinsic that
     might be portable to more GNU Fortran implementations, though to
     fewer Fortran compilers.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = TIME()'

_Return value_:
     The return value is a scalar of type `INTEGER(4)'.

_See also_:
     *Note CTIME::, *Note GMTIME::, *Note LTIME::, *Note MCLOCK::,
     *Note TIME8::



File: gfortran.info,  Node: TIME8,  Next: TINY,  Prev: TIME,  Up: Intrinsic Procedures

6.198 `TIME8' -- Time function (64-bit)
=======================================

_Description_:
     Returns the current time encoded as an integer (in the manner of
     the UNIX function `time(3)'). This value is suitable for passing to
     `CTIME()', `GMTIME()', and `LTIME()'.

     _Warning:_ this intrinsic does not increase the range of the timing
     values over that returned by `time(3)'. On a system with a 32-bit
     `time(3)', `TIME8()' will return a 32-bit value, even though it is
     converted to a 64-bit `INTEGER(8)' value. That means overflows of
     the 32-bit value can still occur. Therefore, the values returned
     by this intrinsic might be or become negative or numerically less
     than previous values during a single run of the compiled program.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = TIME8()'

_Return value_:
     The return value is a scalar of type `INTEGER(8)'.

_See also_:
     *Note CTIME::, *Note GMTIME::, *Note LTIME::, *Note MCLOCK8::,
     *Note TIME::



File: gfortran.info,  Node: TINY,  Next: TRANSFER,  Prev: TIME8,  Up: Intrinsic Procedures

6.199 `TINY' -- Smallest positive number of a real kind
=======================================================

_Description_:
     `TINY(X)' returns the smallest positive (non zero) number in the
     model of the type of `X'.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = TINY(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The return value is of the same type and kind as X

_Example_:
     See `HUGE' for an example.


File: gfortran.info,  Node: TRANSFER,  Next: TRANSPOSE,  Prev: TINY,  Up: Intrinsic Procedures

6.200 `TRANSFER' -- Transfer bit patterns
=========================================

_Description_:
     Interprets the bitwise representation of SOURCE in memory as if it
     is the representation of a variable or array of the same type and
     type parameters as MOLD.

     This is approximately equivalent to the C concept of _casting_ one
     type to another.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = TRANSFER(SOURCE, MOLD[, SIZE])'

_Arguments_:
     SOURCE     Shall be a scalar or an array of any type.
     MOLD       Shall be a scalar or an array of any type.
     SIZE       (Optional) shall be a scalar of type `INTEGER'.

_Return value_:
     The result has the same type as MOLD, with the bit level
     representation of SOURCE.  If SIZE is present, the result is a
     one-dimensional array of length SIZE.  If SIZE is absent but MOLD
     is an array (of any size or shape), the result is a one-
     dimensional array of the minimum length needed to contain the
     entirety of the bitwise representation of SOURCE.   If SIZE is
     absent and MOLD is a scalar, the result is a scalar.

     If the bitwise representation of the result is longer than that of
     SOURCE, then the leading bits of the result correspond to those of
     SOURCE and any trailing bits are filled arbitrarily.

     When the resulting bit representation does not correspond to a
     valid representation of a variable of the same type as MOLD, the
     results are undefined, and subsequent operations on the result
     cannot be guaranteed to produce sensible behavior.  For example,
     it is possible to create `LOGICAL' variables for which `VAR' and
     `.NOT.VAR' both appear to be true.

_Example_:
          PROGRAM test_transfer
            integer :: x = 2143289344
            print *, transfer(x, 1.0)    ! prints "NaN" on i686
          END PROGRAM


File: gfortran.info,  Node: TRANSPOSE,  Next: TRIM,  Prev: TRANSFER,  Up: Intrinsic Procedures

6.201 `TRANSPOSE' -- Transpose an array of rank two
===================================================

_Description_:
     Transpose an array of rank two. Element (i, j) of the result has
     the value `MATRIX(j, i)', for all i, j.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = TRANSPOSE(MATRIX)'

_Arguments_:
     MATRIX     Shall be an array of any type and have a rank
                of two.

_Return value_:
     The result has the the same type as MATRIX, and has shape `(/ m, n
     /)' if MATRIX has shape `(/ n, m /)'.


File: gfortran.info,  Node: TRIM,  Next: TTYNAM,  Prev: TRANSPOSE,  Up: Intrinsic Procedures

6.202 `TRIM' -- Remove trailing blank characters of a string
============================================================

_Description_:
     Removes trailing blank characters of a string.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = TRIM(STRING)'

_Arguments_:
     STRING     Shall be a scalar of type `CHARACTER(*)'.

_Return value_:
     A scalar of type `CHARACTER(*)' which length is that of STRING
     less the number of trailing blanks.

_Example_:
          PROGRAM test_trim
            CHARACTER(len=10), PARAMETER :: s = "GFORTRAN  "
            WRITE(*,*) LEN(s), LEN(TRIM(s))  ! "10 8", with/without trailing blanks
          END PROGRAM

_See also_:
     *Note ADJUSTL::, *Note ADJUSTR::


File: gfortran.info,  Node: TTYNAM,  Next: UBOUND,  Prev: TRIM,  Up: Intrinsic Procedures

6.203 `TTYNAM' -- Get the name of a terminal device.
====================================================

_Description_:
     Get the name of a terminal device. For more information, see
     `ttyname(3)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL TTYNAM(UNIT, NAME)'
     `NAME = TTYNAM(UNIT)'

_Arguments_:
     UNIT       Shall be a scalar `INTEGER(*)'.
     NAME       Shall be of type `CHARACTER(*)'.

_Example_:
          PROGRAM test_ttynam
            INTEGER :: unit
            DO unit = 1, 10
              IF (isatty(unit=unit)) write(*,*) ttynam(unit)
            END DO
          END PROGRAM

_See also_:
     *Note ISATTY::


File: gfortran.info,  Node: UBOUND,  Next: UMASK,  Prev: TTYNAM,  Up: Intrinsic Procedures

6.204 `UBOUND' -- Upper dimension bounds of an array
====================================================

_Description_:
     Returns the upper bounds of an array, or a single upper bound
     along the DIM dimension.

_Standard_:
     F95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = UBOUND(ARRAY [, DIM])'

_Arguments_:
     ARRAY      Shall be an array, of any type.
     DIM        (Optional) Shall be a scalar `INTEGER(*)'.

_Return value_:
     If DIM is absent, the result is an array of the upper bounds of
     ARRAY.  If DIM is present, the result is a scalar corresponding to
     the upper bound of the array along that dimension.  If ARRAY is an
     expression rather than a whole array or array structure component,
     or if it has a zero extent along the relevant dimension, the upper
     bound is taken to be the number of elements along the relevant
     dimension.

_See also_:
     *Note LBOUND::


File: gfortran.info,  Node: UMASK,  Next: UNLINK,  Prev: UBOUND,  Up: Intrinsic Procedures

6.205 `UMASK' -- Set the file creation mask
===========================================

_Description_:
     Sets the file creation mask to MASK and returns the old value in
     argument OLD if it is supplied. See `umask(2)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL UMASK(MASK [, OLD])'

_Arguments_:
     MASK       Shall be a scalar of type `INTEGER(*)'.
     MASK       (Optional) Shall be a scalar of type
                           `INTEGER(*)'.



File: gfortran.info,  Node: UNLINK,  Next: UNPACK,  Prev: UMASK,  Up: Intrinsic Procedures

6.206 `UNLINK' -- Remove a file from the file system
====================================================

_Description_:
     Unlinks the file PATH. A null character (`CHAR(0)') can be used to
     mark the end of the name in PATH; otherwise, trailing blanks in
     the file name are ignored.  If the STATUS argument is supplied, it
     contains 0 on success or a nonzero error code upon return; see
     `unlink(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, non-elemental function

_Syntax_:
     `CALL UNLINK(PATH [, STATUS])'
     `STATUS = UNLINK(PATH)'

_Arguments_:
     PATH       Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:
     *Note LINK::, *Note SYMLNK::


File: gfortran.info,  Node: UNPACK,  Next: VERIFY,  Prev: UNLINK,  Up: Intrinsic Procedures

6.207 `UNPACK' -- Unpack an array of rank one into an array
===========================================================

_Description_:
     Store the elements of VECTOR in an array of higher rank.

_Standard_:
     F95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = UNPACK(VECTOR, MASK, FIELD)'

_Arguments_:
     VECTOR     Shall be an array of any type and rank one. It
                shall have at least as many elements as MASK
                has `TRUE' values.
     MASK       Shall be an array of type `LOGICAL'.
     FIELD      Shall be of the sam type as VECTOR and have
                the same shape as MASK.

_Return value_:
     The resulting array corresponds to FIELD with `TRUE' elements of
     MASK replaced by values from VECTOR in array element order.

_Example_:
          PROGRAM test_unpack
            integer :: vector(2)  = (/1,1/)
            logical :: mask(4)  = (/ .TRUE., .FALSE., .FALSE., .TRUE. /)
            integer :: field(2,2) = 0, unity(2,2)

            ! result: unity matrix
            unity = unpack(vector, reshape(mask, (/2,2/)), field)
          END PROGRAM

_See also_:
     *Note PACK::, *Note SPREAD::


File: gfortran.info,  Node: VERIFY,  Next: XOR,  Prev: UNPACK,  Up: Intrinsic Procedures

6.208 `VERIFY' -- Scan a string for the absence of a set of characters
======================================================================

_Description_:
     Verifies that all the characters in a SET are present in a STRING.

     If BACK is either absent or equals `FALSE', this function returns
     the position of the leftmost character of STRING that is not in
     SET. If BACK equals `TRUE', the rightmost position is returned. If
     all characters of SET are found in STRING, the result is zero.

_Standard_:
     F95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = VERFIY(STRING, SET[, BACK])'

_Arguments_:
     STRING     Shall be of type `CHARACTER(*)'.
     SET        Shall be of type `CHARACTER(*)'.
     BACK       (Optional) shall be of type `LOGICAL'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          PROGRAM test_verify
            WRITE(*,*) VERIFY("FORTRAN", "AO")           ! 1, found 'F'
            WRITE(*,*) VERIFY("FORTRAN", "FOO")          ! 3, found 'R'
            WRITE(*,*) VERIFY("FORTRAN", "C++")          ! 1, found 'F'
            WRITE(*,*) VERIFY("FORTRAN", "C++", .TRUE.)  ! 7, found 'N'
            WRITE(*,*) VERIFY("FORTRAN", "FORTRAN")      ! 0' found none
          END PROGRAM

_See also_:
     *Note SCAN::, *Note INDEX::


File: gfortran.info,  Node: XOR,  Prev: VERIFY,  Up: Intrinsic Procedures

6.209 `XOR' -- Bitwise logical exclusive OR
===========================================

_Description_:
     Bitwise logical exclusive or.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *Note IEOR:: intrinsic defined by the Fortran
     standard.

_Standard_:
     GNU extension

_Class_:
     Non-elemental function

_Syntax_:
     `RESULT = XOR(X, Y)'

_Arguments_:
     X          The type shall be either `INTEGER(*)' or
                `LOGICAL'.
     Y          The type shall be either `INTEGER(*)' or
                `LOGICAL'.

_Return value_:
     The return type is either `INTEGER(*)' or `LOGICAL' after
     cross-promotion of the arguments.

_Example_:
          PROGRAM test_xor
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) XOR(T, T), XOR(T, F), XOR(F, T), XOR(F, F)
            WRITE (*,*) XOR(a, b)
          END PROGRAM

_See also_:
     F95 elemental function: *Note IEOR::


File: gfortran.info,  Node: Contributing,  Next: Copying,  Prev: Intrinsic Procedures,  Up: Top

Contributing
************

Free software is only possible if people contribute to efforts to
create it.  We're always in need of more people helping out with ideas
and comments, writing documentation and contributing code.

   If you want to contribute to GNU Fortran, have a look at the long
lists of projects you can take on.  Some of these projects are small,
some of them are large; some are completely orthogonal to the rest of
what is happening on GNU Fortran, but others are "mainstream" projects
in need of enthusiastic hackers.  All of these projects are important!
We'll eventually get around to the things here, but they are also
things doable by someone who is willing and able.

* Menu:

* Contributors::
* Projects::
* Proposed Extensions::


File: gfortran.info,  Node: Contributors,  Next: Projects,  Up: Contributing

Contributors to GNU Fortran
===========================

Most of the parser was hand-crafted by _Andy Vaught_, who is also the
initiator of the whole project.  Thanks Andy!  Most of the interface
with GCC was written by _Paul Brook_.

   The following individuals have contributed code and/or ideas and
significant help to the GNU Fortran project (in no particular order):

   - Andy Vaught

   - Katherine Holcomb

   - Tobias Schlu"ter

   - Steven Bosscher

   - Toon Moene

   - Tim Prince

   - Niels Kristian Bech Jensen

   - Steven Johnson

   - Paul Brook

   - Feng Wang

   - Bud Davis

   - Paul Thomas

   - Franc,ois-Xavier Coudert

   - Steven G. Kargl

   - Jerry Delisle

   - Janne Blomqvist

   - Erik Edelmann

   - Thomas Koenig

   - Asher Langton

   - Jakub Jelinek

   - Roger Sayle

   - H.J. Lu

   - Richard Henderson

   - Richard Sandiford

   - Richard Guenther

   - Bernhard Fischer

   The following people have contributed bug reports, smaller or larger
patches, and much needed feedback and encouragement for the GNU Fortran
project:

   - Erik Schnetter

   - Bill Clodius

   - Kate Hedstrom

   Many other individuals have helped debug, test and improve the GNU
Fortran compiler over the past few years, and we welcome you to do the
same!  If you already have done so, and you would like to see your name
listed in the list above, please contact us.


File: gfortran.info,  Node: Projects,  Next: Proposed Extensions,  Prev: Contributors,  Up: Contributing

Projects
========

_Help build the test suite_
     Solicit more code for donation to the test suite.  We can keep
     code private on request.

_Bug hunting/squishing_
     Find bugs and write more test cases!  Test cases are especially
     very welcome, because it allows us to concentrate on fixing bugs
     instead of isolating them.

_Smaller projects ("bug" fixes):_
        - Allow init exprs to be numbers raised to integer powers.

        - Implement correct rounding.

        - Implement F restrictions on Fortran 95 syntax.

        - See about making Emacs-parsable error messages.

If you wish to work on the runtime libraries, please contact a project
maintainer.


File: gfortran.info,  Node: Proposed Extensions,  Prev: Projects,  Up: Contributing

Proposed Extensions
===================

Here's a list of proposed extensions for the GNU Fortran compiler, in
no particular order.  Most of these are necessary to be fully
compatible with existing Fortran compilers, but they are not part of
the official J3 Fortran 95 standard.

Compiler extensions:
--------------------

   * User-specified alignment rules for structures.

   * Flag to generate `Makefile' info.

   * Automatically extend single precision constants to double.

   * Compile code that conserves memory by dynamically allocating
     common and module storage either on stack or heap.

   * Compile flag to generate code for array conformance checking
     (suggest -CC).

   * User control of symbol names (underscores, etc).

   * Compile setting for maximum size of stack frame size before
     spilling parts to static or heap.

   * Flag to force local variables into static space.

   * Flag to force local variables onto stack.

   * Flag for maximum errors before ending compile.

   * Option to initialize otherwise uninitialized integer and floating
     point variables.

Environment Options
-------------------

   * Pluggable library modules for random numbers, linear algebra.  LA
     should use BLAS calling conventions.

   * Environment variables controlling actions on arithmetic exceptions
     like overflow, underflow, precision loss--Generate NaN, abort,
     default.  action.

   * Set precision for fp units that support it (i387).

   * Variable for setting fp rounding mode.

   * Variable to fill uninitialized variables with a user-defined bit
     pattern.

   * Environment variable controlling filename that is opened for that
     unit number.

   * Environment variable to clear/trash memory being freed.

   * Environment variable to control tracing of allocations and frees.

   * Environment variable to display allocated memory at normal program
     end.

   * Environment variable for filename for * IO-unit.

   * Environment variable for temporary file directory.

   * Environment variable forcing standard output to be line buffered
     (unix).



File: gfortran.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: Contributing,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY
 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
Appendix: How to Apply These Terms to Your New Programs
=======================================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) YEAR NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
     `Gnomovision' (which makes passes at compilers) written by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: gfortran.info,  Node: GNU Free Documentation License,  Next: Funding,  Prev: Copying,  Up: Top

GNU Free Documentation License
******************************

                      Version 1.2, November 2002

     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.2
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: gfortran.info,  Node: Funding,  Next: Option Index,  Prev: GNU Free Documentation License,  Up: Top

Funding Free Software
*********************

If you want to have more free software a few years from now, it makes
sense for you to help encourage people to contribute funds for its
development.  The most effective approach known is to encourage
commercial redistributors to donate.

   Users of free software systems can boost the pace of development by
encouraging for-a-fee distributors to donate part of their selling price
to free software developers--the Free Software Foundation, and others.

   The way to convince distributors to do this is to demand it and
expect it from them.  So when you compare distributors, judge them
partly by how much they give to free software development.  Show
distributors they must compete to be the one who gives the most.

   To make this approach work, you must insist on numbers that you can
compare, such as, "We will donate ten dollars to the Frobnitz project
for each disk sold."  Don't be satisfied with a vague promise, such as
"A portion of the profits are donated," since it doesn't give a basis
for comparison.

   Even a precise fraction "of the profits from this disk" is not very
meaningful, since creative accounting and unrelated business decisions
can greatly alter what fraction of the sales price counts as profit.
If the price you pay is $50, ten percent of the profit is probably less
than a dollar; it might be a few cents, or nothing at all.

   Some redistributors do development work themselves.  This is useful
too; but to keep everyone honest, you need to inquire how much they do,
and what kind.  Some kinds of development make much more long-term
difference than others.  For example, maintaining a separate version of
a program contributes very little; maintaining the standard version of a
program for the whole community contributes much.  Easy new ports
contribute little, since someone else would surely do them; difficult
ports such as adding a new CPU to the GNU Compiler Collection
contribute more; major new features or packages contribute the most.

   By establishing the idea that supporting further development is "the
proper thing to do" when distributing free software for a fee, we can
assure a steady flow of resources into making more free software.

     Copyright (C) 1994 Free Software Foundation, Inc.
     Verbatim copying and redistribution of this section is permitted
     without royalty; alteration is not permitted.


File: gfortran.info,  Node: Option Index,  Next: Keyword Index,  Prev: Funding,  Up: Top

Option Index
************

`gfortran''s command line options are indexed here without any initial
`-' or `--'. Where an option has both positive and negative forms (such
as -foption and -fno-option), relevant entries in the manual are
indexed under the most appropriate form; it may sometimes be useful to
look up both forms.

 [index ]
* Menu:

* fall-intrinsics:                       Fortran Dialect Options.
                                                              (line  18)
* fbounds-check:                         Code Gen Options.    (line 126)
* fconvert=CONVERSION:                   Runtime Options.     (line   9)
* fcray-pointer:                         Fortran Dialect Options.
                                                              (line  80)
* fd-lines-as-code:                      Fortran Dialect Options.
                                                              (line  26)
* fd-lines-as-comments:                  Fortran Dialect Options.
                                                              (line  26)
* fdefault-double-8:                     Fortran Dialect Options.
                                                              (line  33)
* fdefault-integer-8:                    Fortran Dialect Options.
                                                              (line  36)
* fdefault-real-8:                       Fortran Dialect Options.
                                                              (line  40)
* fdollar-ok:                            Fortran Dialect Options.
                                                              (line  44)
* fdump-parse-tree:                      Debugging Options.   (line  10)
* ff2c:                                  Code Gen Options.    (line  21)
* ffixed-line-length-N:                  Fortran Dialect Options.
                                                              (line  51)
* ffpe-trap=LIST:                        Debugging Options.   (line  14)
* ffree-form:                            Fortran Dialect Options.
                                                              (line  12)
* ffree-line-length-N:                   Fortran Dialect Options.
                                                              (line  64)
* fimplicit-none:                        Fortran Dialect Options.
                                                              (line  75)
* fmax-errors-N:                         Error and Warning Options.
                                                              (line  27)
* fmax-identifier-length=N:              Fortran Dialect Options.
                                                              (line  71)
* fmax-stack-var-size:                   Code Gen Options.    (line 135)
* fmax-subrecord-length=LENGTH:          Runtime Options.     (line  28)
* fno-automatic:                         Code Gen Options.    (line  15)
* fno-backslash:                         Fortran Dialect Options.
                                                              (line  47)
* fno-fixed-form:                        Fortran Dialect Options.
                                                              (line  12)
* fno-underscoring:                      Code Gen Options.    (line  50)
* fopenmp:                               Fortran Dialect Options.
                                                              (line  84)
* fpack-derived:                         Code Gen Options.    (line 145)
* frange-check:                          Fortran Dialect Options.
                                                              (line  92)
* frecord-marker=LENGTH:                 Runtime Options.     (line  20)
* frepack-arrays:                        Code Gen Options.    (line 151)
* fsecond-underscore:                    Code Gen Options.    (line 109)
* fshort-enums <1>:                      Fortran 2003 status. (line  20)
* fshort-enums:                          Code Gen Options.    (line 161)
* fsyntax-only:                          Error and Warning Options.
                                                              (line  33)
* IDIR:                                  Directory Options.   (line  14)
* JDIR:                                  Directory Options.   (line  31)
* MDIR:                                  Directory Options.   (line  31)
* pedantic:                              Error and Warning Options.
                                                              (line  37)
* pedantic-errors:                       Error and Warning Options.
                                                              (line  55)
* std=STD option:                        Fortran Dialect Options.
                                                              (line 102)
* W:                                     Error and Warning Options.
                                                              (line 135)
* w:                                     Error and Warning Options.
                                                              (line  59)
* Waliasing:                             Error and Warning Options.
                                                              (line  68)
* Wall:                                  Error and Warning Options.
                                                              (line  62)
* Wampersand:                            Error and Warning Options.
                                                              (line  85)
* Wcharacter-truncation:                 Error and Warning Options.
                                                              (line  93)
* Wconversion:                           Error and Warning Options.
                                                              (line  96)
* Werror:                                Error and Warning Options.
                                                              (line 132)
* Wimplicit-interface:                   Error and Warning Options.
                                                              (line  99)
* Wnonstd-intrinsics:                    Error and Warning Options.
                                                              (line 105)
* Wsurprising:                           Error and Warning Options.
                                                              (line 109)
* Wtabs:                                 Error and Warning Options.
                                                              (line 122)
* Wunderflow:                            Error and Warning Options.
                                                              (line 128)


File: gfortran.info,  Node: Keyword Index,  Prev: Option Index,  Up: Top

Keyword Index
*************

 [index ]
* Menu:

* $:                                     Fortran Dialect Options.
                                                              (line  44)
* &:                                     Error and Warning Options.
                                                              (line  85)
* [...]:                                 Fortran 2003 status. (line  13)
* ABORT:                                 ABORT.               (line   6)
* ABS:                                   ABS.                 (line   6)
* absolute value:                        ABS.                 (line   6)
* ACCESS:                                ACCESS.              (line   6)
* ACCESS='STREAM' I/O:                   Fortran 2003 status. (line  32)
* ACHAR:                                 ACHAR.               (line   6)
* ACOS:                                  ACOS.                (line   6)
* ACOSH:                                 ACOSH.               (line   6)
* adjust string <1>:                     ADJUSTR.             (line   6)
* adjust string:                         ADJUSTL.             (line   6)
* ADJUSTL:                               ADJUSTL.             (line   6)
* ADJUSTR:                               ADJUSTR.             (line   6)
* AIMAG:                                 AIMAG.               (line   6)
* AINT:                                  AINT.                (line   6)
* ALARM:                                 ALARM.               (line   6)
* aliasing:                              Error and Warning Options.
                                                              (line  68)
* ALL:                                   ALL.                 (line   6)
* all warnings:                          Error and Warning Options.
                                                              (line  62)
* ALLOCATABLE components of derived types: Fortran 2003 status.
                                                              (line  30)
* ALLOCATABLE dummy arguments:           Fortran 2003 status. (line  26)
* ALLOCATABLE function results:          Fortran 2003 status. (line  28)
* ALLOCATED:                             ALLOCATED.           (line   6)
* allocation, moving:                    MOVE_ALLOC.          (line   6)
* allocation, status:                    ALLOCATED.           (line   6)
* ALOG:                                  LOG.                 (line   6)
* ALOG10:                                LOG10.               (line   6)
* AMAX0:                                 MAX.                 (line   6)
* AMAX1:                                 MAX.                 (line   6)
* AMIN0:                                 MIN.                 (line   6)
* AMIN1:                                 MIN.                 (line   6)
* AMOD:                                  MOD.                 (line   6)
* AND:                                   AND.                 (line   6)
* ANINT:                                 ANINT.               (line   6)
* ANY:                                   ANY.                 (line   6)
* area hyperbolic cosine:                ACOSH.               (line   6)
* area hyperbolic sine:                  ASINH.               (line   6)
* area hyperbolic tangent:               ATANH.               (line   6)
* arguments, to program <1>:             IARGC.               (line   6)
* arguments, to program <2>:             GET_COMMAND_ARGUMENT.
                                                              (line   6)
* arguments, to program <3>:             GET_COMMAND.         (line   6)
* arguments, to program <4>:             GETARG.              (line   6)
* arguments, to program:                 COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* array, add elements:                   SUM.                 (line   6)
* array, apply condition <1>:            ANY.                 (line   6)
* array, apply condition:                ALL.                 (line   6)
* array, bounds checking:                Code Gen Options.    (line 126)
* array, change dimensions:              RESHAPE.             (line   6)
* array, combine arrays:                 MERGE.               (line   6)
* array, condition testing <1>:          ANY.                 (line   6)
* array, condition testing:              ALL.                 (line   6)
* array, conditionally add elements:     SUM.                 (line   6)
* array, conditionally count elements:   COUNT.               (line   6)
* array, conditionally multiply elements: PRODUCT.            (line   6)
* array, constructors:                   Fortran 2003 status. (line  13)
* array, count elements:                 SIZE.                (line   6)
* array, duplicate dimensions:           SPREAD.              (line   6)
* array, duplicate elementes:            SPREAD.              (line   6)
* array, element counting:               COUNT.               (line   6)
* array, gather elements:                PACK.                (line   6)
* array, increase dimension <1>:         UNPACK.              (line   6)
* array, increase dimension:             SPREAD.              (line   6)
* array, indices of type real:           Real array indices.  (line   6)
* array, location of maximum element:    MAXLOC.              (line   6)
* array, location of minimum element:    MINLOC.              (line   6)
* array, lower bound:                    LBOUND.              (line   6)
* array, maximum value:                  MAXVAL.              (line   6)
* array, merge arrays:                   MERGE.               (line   6)
* array, minmum value:                   MINVAL.              (line   6)
* array, multiply elements:              PRODUCT.             (line   6)
* array, number of elements <1>:         SIZE.                (line   6)
* array, number of elements:             COUNT.               (line   6)
* array, packing:                        PACK.                (line   6)
* array, permutation:                    CSHIFT.              (line   6)
* array, product:                        PRODUCT.             (line   6)
* array, reduce dimension:               PACK.                (line   6)
* array, rotate:                         CSHIFT.              (line   6)
* array, scatter elements:               UNPACK.              (line   6)
* array, shape:                          SHAPE.               (line   6)
* array, shift:                          EOSHIFT.             (line   6)
* array, shift circularly:               CSHIFT.              (line   6)
* array, size:                           SIZE.                (line   6)
* array, sum:                            SUM.                 (line   6)
* array, transmogrify:                   RESHAPE.             (line   6)
* array, transpose:                      TRANSPOSE.           (line   6)
* array, unpacking:                      UNPACK.              (line   6)
* array, upper bound:                    UBOUND.              (line   6)
* ASCII collating sequence <1>:          IACHAR.              (line   6)
* ASCII collating sequence:              ACHAR.               (line   6)
* ASIN:                                  ASIN.                (line   6)
* ASINH <1>:                             ATANH.               (line   6)
* ASINH:                                 ASINH.               (line   6)
* ASSOCIATED:                            ASSOCIATED.          (line   6)
* association status:                    ASSOCIATED.          (line   6)
* ATAN:                                  ATAN.                (line   6)
* ATAN2:                                 ATAN2.               (line   6)
* Authors:                               Contributors.        (line   6)
* backslash:                             Fortran Dialect Options.
                                                              (line  47)
* BESJ0:                                 BESJ0.               (line   6)
* BESJ1:                                 BESJ1.               (line   6)
* BESJN:                                 BESJN.               (line   6)
* Bessel function, first kind <1>:       BESJN.               (line   6)
* Bessel function, first kind <2>:       BESJ1.               (line   6)
* Bessel function, first kind:           BESJ0.               (line   6)
* Bessel function, second kind <1>:      BESYN.               (line   6)
* Bessel function, second kind <2>:      BESY1.               (line   6)
* Bessel function, second kind:          BESY0.               (line   6)
* BESY0:                                 BESY0.               (line   6)
* BESY1:                                 BESY1.               (line   6)
* BESYN:                                 BESYN.               (line   6)
* BIT_SIZE:                              BIT_SIZE.            (line   6)
* bits, clear:                           IBCLR.               (line   6)
* bits, extract:                         IBITS.               (line   6)
* bits, get:                             IBITS.               (line   6)
* bits, move <1>:                        TRANSFER.            (line   6)
* bits, move:                            MVBITS.              (line   6)
* bits, negate:                          NOT.                 (line   6)
* bits, number of:                       BIT_SIZE.            (line   6)
* bits, set:                             IBSET.               (line   6)
* bits, shift:                           ISHFT.               (line   6)
* bits, shift circular:                  ISHFTC.              (line   6)
* bits, shift left:                      LSHIFT.              (line   6)
* bits, shift right:                     RSHIFT.              (line   6)
* bits, testing:                         BTEST.               (line   6)
* bits, unset:                           IBCLR.               (line   6)
* bitwise logical and <1>:               IAND.                (line   6)
* bitwise logical and:                   AND.                 (line   6)
* bitwise logical exclusive or <1>:      XOR.                 (line   6)
* bitwise logical exclusive or:          IEOR.                (line   6)
* bitwise logical not:                   NOT.                 (line   6)
* bitwise logical or <1>:                OR.                  (line   6)
* bitwise logical or:                    IOR.                 (line   6)
* bounds checking:                       Code Gen Options.    (line 126)
* BOZ literal constants:                 BOZ literal constants.
                                                              (line   6)
* BTEST:                                 BTEST.               (line   6)
* CABS:                                  ABS.                 (line   6)
* calling convention:                    Code Gen Options.    (line  21)
* CCOS:                                  COS.                 (line   6)
* CDABS:                                 ABS.                 (line   6)
* CDCOS:                                 COS.                 (line   6)
* CDEXP:                                 EXP.                 (line   6)
* CDLOG:                                 LOG.                 (line   6)
* CDSIN:                                 SIN.                 (line   6)
* CDSQRT:                                SQRT.                (line   6)
* ceiling:                               CEILING.             (line   6)
* CEILING:                               CEILING.             (line   6)
* ceiling:                               ANINT.               (line   6)
* CEXP:                                  EXP.                 (line   6)
* CHAR:                                  CHAR.                (line   6)
* character set:                         Fortran Dialect Options.
                                                              (line  44)
* CHDIR:                                 CHDIR.               (line   6)
* checking subscripts:                   Code Gen Options.    (line 126)
* CHMOD:                                 CHMOD.               (line   6)
* clock ticks <1>:                       SYSTEM_CLOCK.        (line   6)
* clock ticks <2>:                       MCLOCK8.             (line   6)
* clock ticks:                           MCLOCK.              (line   6)
* CLOG:                                  LOG.                 (line   6)
* CMPLX:                                 CMPLX.               (line   6)
* code generation, conventions:          Code Gen Options.    (line   6)
* collating sequence, ASCII <1>:         IACHAR.              (line   6)
* collating sequence, ASCII:             ACHAR.               (line   6)
* command options:                       Invoking GNU Fortran.
                                                              (line   6)
* command-line arguments <1>:            IARGC.               (line   6)
* command-line arguments <2>:            GET_COMMAND_ARGUMENT.
                                                              (line   6)
* command-line arguments <3>:            GET_COMMAND.         (line   6)
* command-line arguments <4>:            GETARG.              (line   6)
* command-line arguments:                COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* command-line arguments, number of <1>: IARGC.               (line   6)
* command-line arguments, number of:     COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* COMMAND_ARGUMENT_COUNT:                COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* COMPLEX:                               COMPLEX.             (line   6)
* complex conjugate:                     CONJG.               (line   6)
* complex numbers, conversion to <1>:    DCMPLX.              (line   6)
* complex numbers, conversion to <2>:    COMPLEX.             (line   6)
* complex numbers, conversion to:        CMPLX.               (line   6)
* complex numbers, imaginary part:       AIMAG.               (line   6)
* complex numbers, real part <1>:        REAL.                (line   6)
* complex numbers, real part:            DREAL.               (line   6)
* CONJG:                                 CONJG.               (line   6)
* Contributing:                          Contributing.        (line   6)
* Contributors:                          Contributors.        (line   6)
* conversion:                            Error and Warning Options.
                                                              (line  96)
* conversion, to character:              CHAR.                (line   6)
* conversion, to complex <1>:            DCMPLX.              (line   6)
* conversion, to complex <2>:            COMPLEX.             (line   6)
* conversion, to complex:                CMPLX.               (line   6)
* conversion, to integer <1>:            LONG.                (line   6)
* conversion, to integer <2>:            INT8.                (line   6)
* conversion, to integer <3>:            INT2.                (line   6)
* conversion, to integer <4>:            INT.                 (line   6)
* conversion, to integer <5>:            ICHAR.               (line   6)
* conversion, to integer <6>:            IACHAR.              (line   6)
* conversion, to integer:                Implicitly convert LOGICAL and INTEGER values.
                                                              (line   6)
* conversion, to logical <1>:            LOGICAL.             (line   6)
* conversion, to logical:                Implicitly convert LOGICAL and INTEGER values.
                                                              (line   6)
* conversion, to real <1>:               SNGL.                (line   6)
* conversion, to real <2>:               REAL.                (line   6)
* conversion, to real <3>:               FLOAT.               (line   6)
* conversion, to real <4>:               DFLOAT.              (line   6)
* conversion, to real:                   DBLE.                (line   6)
* conversion, to string:                 CTIME.               (line   6)
* CONVERT specifier:                     CONVERT specifier.   (line   6)
* core, dump:                            ABORT.               (line   6)
* COS:                                   COS.                 (line   6)
* COSH:                                  COSH.                (line   6)
* cosine:                                COS.                 (line   6)
* cosine, hyperbolic:                    COSH.                (line   6)
* cosine, hyperbolic, inverse:           ACOSH.               (line   6)
* cosine, inverse:                       ACOS.                (line   6)
* COUNT:                                 COUNT.               (line   6)
* CPU_TIME:                              CPU_TIME.            (line   6)
* Credits:                               Contributors.        (line   6)
* CSHIFT:                                CSHIFT.              (line   6)
* CSIN:                                  SIN.                 (line   6)
* CSQRT:                                 SQRT.                (line   6)
* CTIME:                                 CTIME.               (line   6)
* current date <1>:                      IDATE.               (line   6)
* current date <2>:                      FDATE.               (line   6)
* current date:                          DATE_AND_TIME.       (line   6)
* current time <1>:                      TIME8.               (line   6)
* current time <2>:                      TIME.                (line   6)
* current time <3>:                      ITIME.               (line   6)
* current time <4>:                      FDATE.               (line   6)
* current time:                          DATE_AND_TIME.       (line   6)
* DABS:                                  ABS.                 (line   6)
* DACOS:                                 ACOS.                (line   6)
* DACOSH:                                ACOSH.               (line   6)
* DASIN:                                 ASIN.                (line   6)
* DASINH <1>:                            ATANH.               (line   6)
* DASINH:                                ASINH.               (line   6)
* DATAN:                                 ATAN.                (line   6)
* DATAN2:                                ATAN2.               (line   6)
* date, current <1>:                     IDATE.               (line   6)
* date, current <2>:                     FDATE.               (line   6)
* date, current:                         DATE_AND_TIME.       (line   6)
* DATE_AND_TIME:                         DATE_AND_TIME.       (line   6)
* DBESJ0:                                BESJ0.               (line   6)
* DBESJ1:                                BESJ1.               (line   6)
* DBESJN:                                BESJN.               (line   6)
* DBESY0:                                BESY0.               (line   6)
* DBESY1:                                BESY1.               (line   6)
* DBESYN:                                BESYN.               (line   6)
* DBLE:                                  DBLE.                (line   6)
* DCMPLX:                                DCMPLX.              (line   6)
* DCONJG:                                CONJG.               (line   6)
* DCOS:                                  COS.                 (line   6)
* DCOSH:                                 COSH.                (line   6)
* DDIM:                                  DIM.                 (line   6)
* debugging information options:         Debugging Options.   (line   6)
* delayed execution <1>:                 SLEEP.               (line   6)
* delayed execution:                     ALARM.               (line   6)
* DEXP:                                  EXP.                 (line   6)
* DFLOAT:                                DFLOAT.              (line   6)
* dialect options:                       Fortran Dialect Options.
                                                              (line   6)
* DIGITS:                                DIGITS.              (line   6)
* DIM:                                   DIM.                 (line   6)
* DIMAG:                                 AIMAG.               (line   6)
* DINT:                                  AINT.                (line   6)
* directive, INCLUDE:                    Directory Options.   (line   6)
* directory, options:                    Directory Options.   (line   6)
* directory, search paths for inclusion: Directory Options.   (line  14)
* division, modulo:                      MODULO.              (line   6)
* division, remainder:                   MOD.                 (line   6)
* DLOG:                                  LOG.                 (line   6)
* DLOG10:                                LOG10.               (line   6)
* DMAX1:                                 MAX.                 (line   6)
* DMIN1:                                 MIN.                 (line   6)
* DMOD:                                  MOD.                 (line   6)
* DNINT:                                 ANINT.               (line   6)
* dot product:                           DOT_PRODUCT.         (line   6)
* DOT_PRODUCT:                           DOT_PRODUCT.         (line   6)
* DPROD:                                 DPROD.               (line   6)
* DREAL:                                 DREAL.               (line   6)
* DSIGN:                                 SIGN.                (line   6)
* DSIN:                                  SIN.                 (line   6)
* DSINH:                                 SINH.                (line   6)
* DSQRT:                                 SQRT.                (line   6)
* DTAN:                                  TAN.                 (line   6)
* DTANH:                                 TANH.                (line   6)
* DTIME:                                 DTIME.               (line   6)
* elapsed time <1>:                      SECOND.              (line   6)
* elapsed time <2>:                      SECNDS.              (line   6)
* elapsed time:                          DTIME.               (line   6)
* ENUM statement:                        Fortran 2003 status. (line  20)
* ENUMERATOR statement:                  Fortran 2003 status. (line  20)
* environment variable <1>:              GET_ENVIRONMENT_VARIABLE.
                                                              (line   6)
* environment variable <2>:              GETENV.              (line   6)
* environment variable <3>:              Runtime.             (line   6)
* environment variable:                  Environment Variables.
                                                              (line   6)
* EOSHIFT:                               EOSHIFT.             (line   6)
* EPSILON:                               EPSILON.             (line   6)
* ERF:                                   ERF.                 (line   6)
* ERFC:                                  ERFC.                (line   6)
* error function:                        ERF.                 (line   6)
* error function, complementary:         ERFC.                (line   6)
* errors, limiting:                      Error and Warning Options.
                                                              (line  27)
* escape characters:                     Fortran Dialect Options.
                                                              (line  47)
* ETIME:                                 ETIME.               (line   6)
* EXIT:                                  EXIT.                (line   6)
* EXP:                                   EXP.                 (line   6)
* EXPONENT:                              EXPONENT.            (line   6)
* exponential function:                  EXP.                 (line   6)
* exponential function, inverse <1>:     LOG10.               (line   6)
* exponential function, inverse:         LOG.                 (line   6)
* Extension:                             Extensions.          (line   6)
* extra warnings:                        Error and Warning Options.
                                                              (line 135)
* f2c calling convention:                Code Gen Options.    (line  21)
* FDATE:                                 FDATE.               (line   6)
* FDL, GNU Free Documentation License:   GNU Free Documentation License.
                                                              (line   6)
* FGET:                                  FGET.                (line   6)
* FGETC:                                 FGETC.               (line   6)
* file format, fixed:                    Fortran Dialect Options.
                                                              (line  12)
* file format, free:                     Fortran Dialect Options.
                                                              (line  12)
* file operation, file number:           FNUM.                (line   6)
* file operation, flush:                 FLUSH.               (line   6)
* file operation, position <1>:          FTELL.               (line   6)
* file operation, position:              FSEEK.               (line   6)
* file operation, read character <1>:    FGETC.               (line   6)
* file operation, read character:        FGET.                (line   6)
* file operation, seek:                  FSEEK.               (line   6)
* file operation, write character <1>:   FPUTC.               (line   6)
* file operation, write character:       FPUT.                (line   6)
* file system, access mode:              ACCESS.              (line   6)
* file system, change access mode:       CHMOD.               (line   6)
* file system, create link <1>:          SYMLNK.              (line   6)
* file system, create link:              LINK.                (line   6)
* file system, file creation mask:       UMASK.               (line   6)
* file system, file status <1>:          STAT.                (line   6)
* file system, file status <2>:          LSTAT.               (line   6)
* file system, file status:              FSTAT.               (line   6)
* file system, hard link:                LINK.                (line   6)
* file system, remove file:              UNLINK.              (line   6)
* file system, rename file:              RENAME.              (line   6)
* file system, soft link:                SYMLNK.              (line   6)
* FLOAT:                                 FLOAT.               (line   6)
* floating point, exponent:              EXPONENT.            (line   6)
* floating point, fraction:              FRACTION.            (line   6)
* floating point, nearest different:     NEAREST.             (line   6)
* floating point, relative spacing <1>:  SPACING.             (line   6)
* floating point, relative spacing:      RRSPACING.           (line   6)
* floating point, scale:                 SCALE.               (line   6)
* floating point, set exponent:          SET_EXPONENT.        (line   6)
* floor:                                 FLOOR.               (line   6)
* FLOOR:                                 FLOOR.               (line   6)
* floor:                                 AINT.                (line   6)
* FLUSH:                                 FLUSH.               (line   6)
* FLUSH statement:                       Fortran 2003 status. (line  16)
* FNUM:                                  FNUM.                (line   6)
* Fortran 77:                            GNU Fortran and G77. (line   6)
* FPUT:                                  FPUT.                (line   6)
* FPUTC:                                 FPUTC.               (line   6)
* FRACTION:                              FRACTION.            (line   6)
* FREE:                                  FREE.                (line   6)
* FSEEK:                                 FSEEK.               (line   6)
* FSTAT:                                 FSTAT.               (line   6)
* FTELL:                                 FTELL.               (line   6)
* g77:                                   GNU Fortran and G77. (line   6)
* g77 calling convention:                Code Gen Options.    (line  21)
* GCC:                                   GNU Fortran and GCC. (line   6)
* GERROR:                                GERROR.              (line   6)
* GET_COMMAND:                           GET_COMMAND.         (line   6)
* GET_COMMAND_ARGUMENT:                  GET_COMMAND_ARGUMENT.
                                                              (line   6)
* GET_ENVIRONMENT_VARIABLE:              GET_ENVIRONMENT_VARIABLE.
                                                              (line   6)
* GETARG:                                GETARG.              (line   6)
* GETCWD:                                GETCWD.              (line   6)
* GETENV:                                GETENV.              (line   6)
* GETGID:                                GETGID.              (line   6)
* GETLOG:                                GETLOG.              (line   6)
* GETPID:                                GETPID.              (line   6)
* GETUID:                                GETUID.              (line   6)
* GMTIME:                                GMTIME.              (line   6)
* GNU Compiler Collection:               GNU Fortran and GCC. (line   6)
* GNU Fortran command options:           Invoking GNU Fortran.
                                                              (line   6)
* Hollerith constants:                   Hollerith constants support.
                                                              (line   6)
* HOSTNM:                                HOSTNM.              (line   6)
* HUGE:                                  HUGE.                (line   6)
* hyperbolic arccosine:                  ACOSH.               (line   6)
* hyperbolic arcsine:                    ASINH.               (line   6)
* hyperbolic arctangent:                 ATANH.               (line   6)
* hyperbolic cosine:                     COSH.                (line   6)
* hyperbolic function, cosine:           COSH.                (line   6)
* hyperbolic function, cosine, inverse:  ACOSH.               (line   6)
* hyperbolic function, sine:             SINH.                (line   6)
* hyperbolic function, sine, inverse:    ASINH.               (line   6)
* hyperbolic function, tangent:          TANH.                (line   6)
* hyperbolic function, tangent, inverse: ATANH.               (line   6)
* hyperbolic sine:                       SINH.                (line   6)
* hyperbolic tangent:                    TANH.                (line   6)
* I/O item lists:                        I/O item lists.      (line   6)
* IABS:                                  ABS.                 (line   6)
* IACHAR:                                IACHAR.              (line   6)
* IAND:                                  IAND.                (line   6)
* IARGC:                                 IARGC.               (line   6)
* IBCLR:                                 IBCLR.               (line   6)
* IBITS:                                 IBITS.               (line   6)
* IBSET:                                 IBSET.               (line   6)
* ICHAR:                                 ICHAR.               (line   6)
* IDATE:                                 IDATE.               (line   6)
* IDIM:                                  DIM.                 (line   6)
* IDINT:                                 INT.                 (line   6)
* IDNINT:                                NINT.                (line   6)
* IEOR:                                  IEOR.                (line   6)
* IERRNO:                                IERRNO.              (line   6)
* IFIX:                                  INT.                 (line   6)
* IMAG:                                  AIMAG.               (line   6)
* IMAGPART:                              AIMAG.               (line   6)
* INCLUDE directive:                     Directory Options.   (line   6)
* inclusion, directory search paths for: Directory Options.   (line  14)
* INDEX:                                 INDEX.               (line   6)
* INT:                                   INT.                 (line   6)
* INT2:                                  INT2.                (line   6)
* INT8:                                  INT8.                (line   6)
* integer kind:                          SELECTED_INT_KIND.   (line   6)
* intrinsic procedures:                  Intrinsic Procedures.
                                                              (line   6)
* Introduction:                          Top.                 (line   6)
* IOMSG= specifier:                      Fortran 2003 status. (line  18)
* IOR:                                   IOR.                 (line   6)
* IRAND:                                 IRAND.               (line   6)
* ISATTY:                                ISATTY.              (line   6)
* ISHFT:                                 ISHFT.               (line   6)
* ISHFTC:                                ISHFTC.              (line   6)
* ISIGN:                                 SIGN.                (line   6)
* ITIME:                                 ITIME.               (line   6)
* KILL:                                  KILL.                (line   6)
* kind:                                  KIND.                (line   6)
* KIND:                                  KIND.                (line   6)
* kind, integer:                         SELECTED_INT_KIND.   (line   6)
* kind, old-style:                       Old-style kind specifications.
                                                              (line   6)
* kind, real:                            SELECTED_REAL_KIND.  (line   6)
* language, dialect options:             Fortran Dialect Options.
                                                              (line   6)
* LBOUND:                                LBOUND.              (line   6)
* LEN:                                   LEN.                 (line   6)
* LEN_TRIM:                              LEN_TRIM.            (line   6)
* lexical comparison of strings <1>:     LLT.                 (line   6)
* lexical comparison of strings <2>:     LLE.                 (line   6)
* lexical comparison of strings <3>:     LGT.                 (line   6)
* lexical comparison of strings:         LGE.                 (line   6)
* LGE:                                   LGE.                 (line   6)
* LGT:                                   LGT.                 (line   6)
* libf2c calling convention:             Code Gen Options.    (line  21)
* limits, largest number:                HUGE.                (line   6)
* limits, smallest number:               TINY.                (line   6)
* LINK:                                  LINK.                (line   6)
* LLE:                                   LLE.                 (line   6)
* LLT:                                   LLT.                 (line   6)
* LNBLNK:                                LNBLNK.              (line   6)
* LOC:                                   LOC.                 (line   6)
* location of a variable in memory:      LOC.                 (line   6)
* LOG:                                   LOG.                 (line   6)
* LOG10:                                 LOG10.               (line   6)
* logarithmic function <1>:              LOG10.               (line   6)
* logarithmic function:                  LOG.                 (line   6)
* logarithmic function, inverse:         EXP.                 (line   6)
* LOGICAL:                               LOGICAL.             (line   6)
* logical and, bitwise <1>:              IAND.                (line   6)
* logical and, bitwise:                  AND.                 (line   6)
* logical exclusive or, bitwise <1>:     XOR.                 (line   6)
* logical exclusive or, bitwise:         IEOR.                (line   6)
* logical not, bitwise:                  NOT.                 (line   6)
* logical or, bitwise <1>:               OR.                  (line   6)
* logical or, bitwise:                   IOR.                 (line   6)
* login name:                            GETLOG.              (line   6)
* LONG:                                  LONG.                (line   6)
* LSHIFT:                                LSHIFT.              (line   6)
* LSTAT:                                 LSTAT.               (line   6)
* LTIME:                                 LTIME.               (line   6)
* MALLOC:                                MALLOC.              (line   6)
* MATMUL:                                MATMUL.              (line   6)
* matrix multiplication:                 MATMUL.              (line   6)
* matrix, transpose:                     TRANSPOSE.           (line   6)
* MAX:                                   MAX.                 (line   6)
* MAX0:                                  MAX.                 (line   6)
* MAX1:                                  MAX.                 (line   6)
* MAXEXPONENT:                           MAXEXPONENT.         (line   6)
* maximum value <1>:                     MAXVAL.              (line   6)
* maximum value:                         MAX.                 (line   6)
* MAXLOC:                                MAXLOC.              (line   6)
* MAXVAL:                                MAXVAL.              (line   6)
* MCLOCK:                                MCLOCK.              (line   6)
* MCLOCK8:                               MCLOCK8.             (line   6)
* MERGE:                                 MERGE.               (line   6)
* messages, error:                       Error and Warning Options.
                                                              (line   6)
* messages, warning:                     Error and Warning Options.
                                                              (line   6)
* MIN:                                   MIN.                 (line   6)
* MIN0:                                  MIN.                 (line   6)
* MIN1:                                  MIN.                 (line   6)
* MINEXPONENT:                           MINEXPONENT.         (line   6)
* minimum value <1>:                     MINVAL.              (line   6)
* minimum value:                         MIN.                 (line   6)
* MINLOC:                                MINLOC.              (line   6)
* MINVAL:                                MINVAL.              (line   6)
* MOD:                                   MOD.                 (line   6)
* model representation, base:            RADIX.               (line   6)
* model representation, epsilon:         EPSILON.             (line   6)
* model representation, largest number:  HUGE.                (line   6)
* model representation, maximum exponent: MAXEXPONENT.        (line   6)
* model representation, minimum exponent: MINEXPONENT.        (line   6)
* model representation, precision:       PRECISION.           (line   6)
* model representation, radix:           RADIX.               (line   6)
* model representation, range:           RANGE.               (line   6)
* model representation, significant digits: DIGITS.           (line   6)
* model representation, smallest number: TINY.                (line   6)
* module search path:                    Directory Options.   (line  14)
* modulo:                                MODULO.              (line   6)
* MODULO:                                MODULO.              (line   6)
* MOVE_ALLOC:                            MOVE_ALLOC.          (line   6)
* moving allocation:                     MOVE_ALLOC.          (line   6)
* multiply array elements:               PRODUCT.             (line   6)
* MVBITS:                                MVBITS.              (line   6)
* Namelist:                              Extensions to namelist.
                                                              (line   6)
* NEAREST:                               NEAREST.             (line   6)
* NEW_LINE:                              NEW_LINE.            (line   6)
* newline:                               NEW_LINE.            (line   6)
* NINT:                                  NINT.                (line   6)
* NOT:                                   NOT.                 (line   6)
* NULL:                                  NULL.                (line   6)
* OpenMP <1>:                            OpenMP.              (line   6)
* OpenMP:                                Fortran Dialect Options.
                                                              (line  84)
* operators, unary:                      Unary operators.     (line   6)
* options, code generation:              Code Gen Options.    (line   6)
* options, debugging:                    Debugging Options.   (line   6)
* options, dialect:                      Fortran Dialect Options.
                                                              (line   6)
* options, directory search:             Directory Options.   (line   6)
* options, errors:                       Error and Warning Options.
                                                              (line   6)
* options, fortran dialect:              Fortran Dialect Options.
                                                              (line  12)
* options, gfortran command:             Invoking GNU Fortran.
                                                              (line   6)
* options, negative forms:               Invoking GNU Fortran.
                                                              (line  13)
* options, run-time:                     Code Gen Options.    (line   6)
* options, runtime:                      Runtime Options.     (line   6)
* options, warnings:                     Error and Warning Options.
                                                              (line   6)
* OR:                                    OR.                  (line   6)
* output, newline:                       NEW_LINE.            (line   6)
* PACK:                                  PACK.                (line   6)
* paths, search:                         Directory Options.   (line  14)
* PERROR:                                PERROR.              (line   6)
* pointer, cray <1>:                     MALLOC.              (line   6)
* pointer, cray <2>:                     FREE.                (line   6)
* pointer, cray:                         Cray pointers.       (line   6)
* pointer, disassociated:                NULL.                (line   6)
* pointer, status <1>:                   NULL.                (line   6)
* pointer, status:                       ASSOCIATED.          (line   6)
* positive difference:                   DIM.                 (line   6)
* PRECISION:                             PRECISION.           (line   6)
* PRESENT:                               PRESENT.             (line   6)
* process id:                            GETPID.              (line   6)
* PRODUCT:                               PRODUCT.             (line   6)
* product, double-precision:             DPROD.               (line   6)
* product, matrix:                       MATMUL.              (line   6)
* product, vector:                       DOT_PRODUCT.         (line   6)
* program termination:                   EXIT.                (line   6)
* program termination, with core dump:   ABORT.               (line   6)
* RADIX:                                 RADIX.               (line   6)
* RAN:                                   RAN.                 (line   6)
* RAND:                                  RAND.                (line   6)
* random number generation <1>:          RANDOM_NUMBER.       (line   6)
* random number generation <2>:          RAND.                (line   6)
* random number generation <3>:          RAN.                 (line   6)
* random number generation:              IRAND.               (line   6)
* random number generation, seeding <1>: SRAND.               (line   6)
* random number generation, seeding:     RANDOM_SEED.         (line   6)
* RANDOM_NUMBER:                         RANDOM_NUMBER.       (line   6)
* RANDOM_SEED:                           RANDOM_SEED.         (line   6)
* RANGE:                                 RANGE.               (line   6)
* range checking:                        Code Gen Options.    (line 126)
* read character, stream mode <1>:       FGETC.               (line   6)
* read character, stream mode:           FGET.                (line   6)
* REAL:                                  REAL.                (line   6)
* real kind:                             SELECTED_REAL_KIND.  (line   6)
* real number, exponent:                 EXPONENT.            (line   6)
* real number, fraction:                 FRACTION.            (line   6)
* real number, nearest different:        NEAREST.             (line   6)
* real number, relative spacing <1>:     SPACING.             (line   6)
* real number, relative spacing:         RRSPACING.           (line   6)
* real number, scale:                    SCALE.               (line   6)
* real number, set exponent:             SET_EXPONENT.        (line   6)
* REALPART:                              REAL.                (line   6)
* remainder:                             MOD.                 (line   6)
* RENAME:                                RENAME.              (line   6)
* repacking arrays:                      Code Gen Options.    (line 151)
* REPEAT:                                REPEAT.              (line   6)
* RESHAPE:                               RESHAPE.             (line   6)
* root:                                  SQRT.                (line   6)
* rounding, ceiling <1>:                 CEILING.             (line   6)
* rounding, ceiling:                     ANINT.               (line   6)
* rounding, floor <1>:                   FLOOR.               (line   6)
* rounding, floor:                       AINT.                (line   6)
* rounding, nearest whole number:        NINT.                (line   6)
* RRSPACING:                             RRSPACING.           (line   6)
* RSHIFT:                                RSHIFT.              (line   6)
* SAVE statement:                        Code Gen Options.    (line  15)
* SCALE:                                 SCALE.               (line   6)
* SCAN:                                  SCAN.                (line   6)
* search path:                           Directory Options.   (line   6)
* search paths, for included files:      Directory Options.   (line  14)
* SECNDS:                                SECNDS.              (line   6)
* SECOND:                                SECOND.              (line   6)
* seeding a random number generator <1>: SRAND.               (line   6)
* seeding a random number generator:     RANDOM_SEED.         (line   6)
* SELECTED_INT_KIND:                     SELECTED_INT_KIND.   (line   6)
* SELECTED_REAL_KIND:                    SELECTED_REAL_KIND.  (line   6)
* SET_EXPONENT:                          SET_EXPONENT.        (line   6)
* SHAPE:                                 SHAPE.               (line   6)
* SHORT:                                 INT2.                (line   6)
* SIGN:                                  SIGN.                (line   6)
* sign copying:                          SIGN.                (line   6)
* SIGNAL:                                SIGNAL.              (line   6)
* SIN:                                   SIN.                 (line   6)
* sine:                                  SIN.                 (line   6)
* sine, hyperbolic:                      SINH.                (line   6)
* sine, hyperbolic, inverse:             ASINH.               (line   6)
* sine, inverse:                         ASIN.                (line   6)
* SINH:                                  SINH.                (line   6)
* SIZE:                                  SIZE.                (line   6)
* size of a variable, in bits:           BIT_SIZE.            (line   6)
* SLEEP:                                 SLEEP.               (line   6)
* SNGL:                                  SNGL.                (line   6)
* SPACING:                               SPACING.             (line   6)
* SPREAD:                                SPREAD.              (line   6)
* SQRT:                                  SQRT.                (line   6)
* square-root:                           SQRT.                (line   6)
* SRAND:                                 SRAND.               (line   6)
* Standards:                             Standards.           (line   6)
* STAT:                                  STAT.                (line   6)
* statement, ENUM:                       Fortran 2003 status. (line  20)
* statement, ENUMERATOR:                 Fortran 2003 status. (line  20)
* statement, FLUSH:                      Fortran 2003 status. (line  16)
* statement, SAVE:                       Code Gen Options.    (line  15)
* STREAM I/O:                            Fortran 2003 status. (line  32)
* stream mode, read character <1>:       FGETC.               (line   6)
* stream mode, read character:           FGET.                (line   6)
* stream mode, write character <1>:      FPUTC.               (line   6)
* stream mode, write character:          FPUT.                (line   6)
* string, adjust left:                   ADJUSTL.             (line   6)
* string, adjust right:                  ADJUSTR.             (line   6)
* string, comparison <1>:                LLT.                 (line   6)
* string, comparison <2>:                LLE.                 (line   6)
* string, comparison <3>:                LGT.                 (line   6)
* string, comparison:                    LGE.                 (line   6)
* string, concatenate:                   REPEAT.              (line   6)
* string, find missing set:              VERIFY.              (line   6)
* string, find non-blank character:      LNBLNK.              (line   6)
* string, find subset:                   SCAN.                (line   6)
* string, find substring:                INDEX.               (line   6)
* string, length:                        LEN.                 (line   6)
* string, length, without trailing whitespace: LEN_TRIM.      (line   6)
* string, remove trailing whitespace:    TRIM.                (line   6)
* string, repeat:                        REPEAT.              (line   6)
* structure packing:                     Code Gen Options.    (line 145)
* subscript checking:                    Code Gen Options.    (line 126)
* substring position:                    INDEX.               (line   6)
* SUM:                                   SUM.                 (line   6)
* sum array elements:                    SUM.                 (line   6)
* suppressing warnings:                  Error and Warning Options.
                                                              (line   6)
* symbol names:                          Fortran Dialect Options.
                                                              (line  44)
* symbol names, transforming:            Code Gen Options.    (line  50)
* symbol names, underscores:             Code Gen Options.    (line  50)
* SYMLNK:                                SYMLNK.              (line   6)
* syntax checking:                       Error and Warning Options.
                                                              (line  33)
* SYSTEM:                                SYSTEM.              (line   6)
* system, error handling <1>:            PERROR.              (line   6)
* system, error handling <2>:            IERRNO.              (line   6)
* system, error handling:                GERROR.              (line   6)
* system, group id:                      GETGID.              (line   6)
* system, host name:                     HOSTNM.              (line   6)
* system, login name:                    GETLOG.              (line   6)
* system, process id:                    GETPID.              (line   6)
* system, signal handling:               SIGNAL.              (line   6)
* system, system call:                   SYSTEM.              (line   6)
* system, terminal <1>:                  TTYNAM.              (line   6)
* system, terminal:                      ISATTY.              (line   6)
* system, user id:                       GETUID.              (line   6)
* system, working directory <1>:         GETCWD.              (line   6)
* system, working directory:             CHDIR.               (line   6)
* SYSTEM_CLOCK:                          SYSTEM_CLOCK.        (line   6)
* tabulators:                            Error and Warning Options.
                                                              (line 122)
* TAN:                                   TAN.                 (line   6)
* tangent:                               TAN.                 (line   6)
* tangent, hyperbolic:                   TANH.                (line   6)
* tangent, hyperbolic, inverse:          ATANH.               (line   6)
* tangent, inverse <1>:                  ATAN2.               (line   6)
* tangent, inverse:                      ATAN.                (line   6)
* TANH:                                  TANH.                (line   6)
* terminate program:                     EXIT.                (line   6)
* terminate program, with core dump:     ABORT.               (line   6)
* TIME:                                  TIME.                (line   6)
* time, clock ticks <1>:                 SYSTEM_CLOCK.        (line   6)
* time, clock ticks <2>:                 MCLOCK8.             (line   6)
* time, clock ticks:                     MCLOCK.              (line   6)
* time, conversion to GMT info:          GMTIME.              (line   6)
* time, conversion to string:            CTIME.               (line   6)
* time, converstion to local time info:  LTIME.               (line   6)
* time, current <1>:                     TIME8.               (line   6)
* time, current <2>:                     TIME.                (line   6)
* time, current <3>:                     ITIME.               (line   6)
* time, current <4>:                     FDATE.               (line   6)
* time, current:                         DATE_AND_TIME.       (line   6)
* time, elapsed <1>:                     SECOND.              (line   6)
* time, elapsed <2>:                     SECNDS.              (line   6)
* time, elapsed <3>:                     ETIME.               (line   6)
* time, elapsed <4>:                     DTIME.               (line   6)
* time, elapsed:                         CPU_TIME.            (line   6)
* TIME8:                                 TIME8.               (line   6)
* TINY:                                  TINY.                (line   6)
* TR 15581:                              Fortran 2003 status. (line  25)
* TRANSFER:                              TRANSFER.            (line   6)
* transforming symbol names:             Code Gen Options.    (line  50)
* transpose:                             TRANSPOSE.           (line   6)
* TRANSPOSE:                             TRANSPOSE.           (line   6)
* trigonometric function, cosine:        COS.                 (line   6)
* trigonometric function, cosine, inverse: ACOS.              (line   6)
* trigonometric function, sine:          SIN.                 (line   6)
* trigonometric function, sine, inverse: ASIN.                (line   6)
* trigonometric function, tangent:       TAN.                 (line   6)
* trigonometric function, tangent, inverse <1>: ATAN2.        (line   6)
* trigonometric function, tangent, inverse: ATAN.             (line   6)
* TRIM:                                  TRIM.                (line   6)
* TTYNAM:                                TTYNAM.              (line   6)
* type cast:                             TRANSFER.            (line   6)
* UBOUND:                                UBOUND.              (line   6)
* UMASK:                                 UMASK.               (line   6)
* underflow:                             Error and Warning Options.
                                                              (line 128)
* underscore:                            Code Gen Options.    (line  50)
* UNLINK:                                UNLINK.              (line   6)
* UNPACK:                                UNPACK.              (line   6)
* user id:                               GETUID.              (line   6)
* vector product:                        DOT_PRODUCT.         (line   6)
* VERIFY:                                VERIFY.              (line   6)
* warnings, aliasing:                    Error and Warning Options.
                                                              (line  68)
* warnings, all:                         Error and Warning Options.
                                                              (line  62)
* warnings, ampersand:                   Error and Warning Options.
                                                              (line  85)
* warnings, character truncation:        Error and Warning Options.
                                                              (line  93)
* warnings, conversion:                  Error and Warning Options.
                                                              (line  96)
* warnings, extra:                       Error and Warning Options.
                                                              (line 135)
* warnings, implicit interface:          Error and Warning Options.
                                                              (line  99)
* warnings, non-stdandard intrinsics:    Error and Warning Options.
                                                              (line 105)
* warnings, none:                        Error and Warning Options.
                                                              (line  59)
* warnings, suppressing:                 Error and Warning Options.
                                                              (line   6)
* warnings, suspicious code:             Error and Warning Options.
                                                              (line 109)
* warnings, tabs:                        Error and Warning Options.
                                                              (line 122)
* warnings, to errors:                   Error and Warning Options.
                                                              (line 132)
* warnings, underflow:                   Error and Warning Options.
                                                              (line 128)
* write character, stream mode <1>:      FPUTC.               (line   6)
* write character, stream mode:          FPUT.                (line   6)
* XOR:                                   XOR.                 (line   6)
* ZABS:                                  ABS.                 (line   6)
* ZCOS:                                  COS.                 (line   6)
* ZEXP:                                  EXP.                 (line   6)
* ZLOG:                                  LOG.                 (line   6)
* ZSIN:                                  SIN.                 (line   6)
* ZSQRT:                                 SQRT.                (line   6)



Tag Table:
Node: Top2086
Node: Introduction3234
Node: About GNU Fortran3908
Node: GNU Fortran and GCC7966
Node: GNU Fortran and G779631
Node: Project Status10182
Node: Standards12680
Node: Invoking GNU Fortran13337
Node: Option Summary14931
Node: Fortran Dialect Options17346
Node: Error and Warning Options22397
Node: Debugging Options28197
Node: Directory Options29533
Node: Runtime Options30880
Node: Code Gen Options32335
Node: Environment Variables40152
Node: Runtime40755
Node: GFORTRAN_STDIN_UNIT41764
Node: GFORTRAN_STDOUT_UNIT42131
Node: GFORTRAN_STDERR_UNIT42532
Node: GFORTRAN_USE_STDERR42930
Node: GFORTRAN_TMPDIR43375
Node: GFORTRAN_UNBUFFERED_ALL43816
Node: GFORTRAN_SHOW_LOCUS44294
Node: GFORTRAN_OPTIONAL_PLUS44779
Node: GFORTRAN_DEFAULT_RECL45254
Node: GFORTRAN_LIST_SEPARATOR45743
Node: GFORTRAN_CONVERT_UNIT46352
Node: Fortran 2003 status49195
Node: Extensions50285
Node: Old-style kind specifications51492
Node: Old-style variable initialization52326
Node: Extensions to namelist53607
Node: X format descriptor without count field55572
Node: Commas in FORMAT specifications56068
Node: Missing period in FORMAT specifications56554
Node: I/O item lists57085
Node: BOZ literal constants57443
Node: Real array indices58953
Node: Unary operators59219
Node: Implicitly convert LOGICAL and INTEGER values59602
Node: Hollerith constants support60358
Node: Cray pointers62099
Node: CONVERT specifier67478
Node: OpenMP69445
Node: Intrinsic Procedures70095
Node: Introduction to Intrinsics82695
Node: ABORT85008
Node: ABS85725
Node: ACCESS87217
Node: ACHAR89106
Node: ACOS90046
Node: ACOSH90976
Node: ADJUSTL91949
Node: ADJUSTR92843
Node: AIMAG93743
Node: AINT95153
Node: ALARM96598
Node: ALL98232
Node: ALLOCATED100149
Node: AND101018
Node: ANINT102194
Node: ANY103532
Node: ASIN105461
Node: ASINH106406
Node: ASSOCIATED107359
Node: ATAN110184
Node: ATAN2111018
Node: ATANH112297
Node: BESJ0113279
Node: BESJ1114193
Node: BESJN115113
Node: BESY0116138
Node: BESY1116996
Node: BESYN117854
Node: BIT_SIZE118933
Node: BTEST119682
Node: CEILING120525
Node: CHAR121486
Node: CHDIR122573
Node: CHMOD123808
Node: CMPLX125601
Node: COMMAND_ARGUMENT_COUNT127140
Node: COMPLEX128030
Node: CONJG129185
Node: COS130194
Node: COSH131407
Node: COUNT132225
Node: CPU_TIME133759
Node: CSHIFT134683
Node: CTIME136326
Node: DATE_AND_TIME137539
Node: DBLE139902
Node: DCMPLX140742
Node: DFLOAT141981
Node: DIGITS142678
Node: DIM143622
Node: DOT_PRODUCT144758
Node: DPROD146188
Node: DREAL146907
Node: DTIME147571
Node: EOSHIFT149865
Node: EPSILON151926
Node: ERF152622
Node: ERFC153419
Node: ETIME154234
Node: EXIT156412
Node: EXP157271
Node: EXPONENT158368
Node: FDATE159114
Node: FLOAT160288
Node: FGET160998
Node: FGETC162647
Node: FLOOR164251
Node: FLUSH165193
Node: FNUM165845
Node: FPUT166581
Node: FPUTC168018
Node: FRACTION169594
Node: FREE170488
Node: FSEEK171325
Node: FSTAT171818
Node: FTELL172747
Node: GERROR173726
Node: GETARG174434
Node: GET_COMMAND176031
Node: GET_COMMAND_ARGUMENT176911
Node: GETCWD178307
Node: GETENV179111
Node: GET_ENVIRONMENT_VARIABLE180275
Node: GETGID181209
Node: GETLOG181744
Node: GETPID182500
Node: GETUID183228
Node: GMTIME183742
Node: HOSTNM185297
Node: HUGE186235
Node: IACHAR186950
Node: IAND187876
Node: IARGC188864
Node: IBCLR189892
Node: IBITS190553
Node: IBSET191471
Node: ICHAR192127
Node: IDATE193856
Node: IEOR194872
Node: IERRNO195751
Node: INDEX196310
Node: INT197404
Node: INT2198918
Node: INT8199698
Node: IOR200425
Node: IRAND201270
Node: ISATTY202359
Node: ISHFT203153
Node: ISHFTC204135
Node: ITIME205356
Node: KILL206373
Node: KIND207139
Node: LBOUND207977
Node: LEN208957
Node: LEN_TRIM209779
Node: LGE210491
Node: LGT211796
Node: LINK213066
Node: LLE214115
Node: LLT215412
Node: LNBLNK216675
Node: LOC217444
Node: LOG218175
Node: LOG10219377
Node: LOGICAL220243
Node: LONG221070
Node: LSHIFT221841
Node: LSTAT222804
Node: LTIME223830
Node: MALLOC225309
Node: MATMUL226987
Node: MAX228176
Node: MAXEXPONENT229681
Node: MAXLOC230490
Node: MAXVAL232623
Node: MCLOCK234415
Node: MCLOCK8235432
Node: MERGE236660
Node: MIN237421
Node: MINEXPONENT238923
Node: MINLOC239546
Node: MINVAL241679
Node: MOD243445
Node: MODULO244822
Node: MOVE_ALLOC246029
Node: MVBITS247087
Node: NEAREST248271
Node: NEW_LINE249387
Node: NINT250172
Node: NOT251192
Node: NULL251774
Node: OR252658
Node: PACK253815
Node: PERROR255802
Node: PRECISION256392
Node: PRESENT257211
Node: PRODUCT258310
Node: RADIX259837
Node: RAN260607
Node: RAND261077
Node: RANDOM_NUMBER262153
Node: RANDOM_SEED263482
Node: RANGE265358
Node: REAL265978
Node: RENAME267479
Node: REPEAT268512
Node: RESHAPE269237
Node: RRSPACING270699
Node: RSHIFT271385
Node: SCALE272356
Node: SCAN273123
Node: SECNDS274418
Node: SECOND275520
Node: SELECTED_INT_KIND276409
Node: SELECTED_REAL_KIND277565
Node: SET_EXPONENT279504
Node: SHAPE280493
Node: SIGN281599
Node: SIGNAL282675
Node: SIN284186
Node: SINH285227
Node: SIZE285984
Node: SLEEP287040
Node: SNGL287595
Node: SPACING288259
Node: SPREAD289267
Node: SQRT290405
Node: SRAND291589
Node: STAT292762
Node: SUM295742
Node: SYMLNK297213
Node: SYSTEM298359
Node: SYSTEM_CLOCK299321
Node: TAN300658
Node: TANH301439
Node: TIME302251
Node: TIME8303369
Node: TINY304520
Node: TRANSFER305117
Node: TRANSPOSE307142
Node: TRIM307826
Node: TTYNAM308682
Node: UBOUND309617
Node: UMASK310656
Node: UNLINK311244
Node: UNPACK312235
Node: VERIFY313515
Node: XOR314976
Node: Contributing316162
Node: Contributors317017
Node: Projects318487
Node: Proposed Extensions319279
Node: Copying321477
Node: GNU Free Documentation License340686
Node: Funding363098
Node: Option Index365623
Node: Keyword Index372277

End Tag Table
